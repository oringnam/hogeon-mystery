{"version":3,"file":"ink-full-es2015.js","sources":["../src/compiler/CompilerOptions.ts","../src/compiler/DebugSourceRange.ts","../src/compiler/Parser/ErrorType.ts","../src/compiler/Parser/ParsedHierarchy/Argument.ts","../src/engine/TypeAssertion.ts","../src/compiler/Parser/ParsedHierarchy/Object.ts","../src/compiler/Parser/ParsedHierarchy/AuthorWarning.ts","../src/engine/Path.ts","../src/engine/Debug.ts","../src/engine/Value.ts","../src/engine/PushPop.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/ControlCommand.ts","../src/compiler/Parser/ParsedHierarchy/Expression/Expression.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/compiler/Parser/ParsedHierarchy/Expression/NumberExpression.ts","../src/compiler/Parser/ParsedHierarchy/Expression/UnaryExpression.ts","../src/compiler/Parser/ParsedHierarchy/Expression/BinaryExpression.ts","../src/compiler/Parser/CharacterSet.ts","../src/compiler/Parser/CharacterRange.ts","../src/engine/ChoicePoint.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/compiler/Parser/ParsedHierarchy/SymbolType.ts","../src/engine/VariableAssignment.ts","../src/compiler/Parser/ParsedHierarchy/Choice.ts","../src/compiler/Parser/StringParser/StringParserElement.ts","../src/compiler/Parser/StringParser/StringParserState.ts","../src/compiler/Parser/StringParser/StringParser.ts","../src/compiler/Parser/CommentEliminator.ts","../src/compiler/Parser/ParsedHierarchy/Conditional/Conditional.ts","../src/compiler/Parser/ParsedHierarchy/Text.ts","../src/compiler/Parser/ParsedHierarchy/Declaration/ConstantDeclaration.ts","../src/compiler/Parser/ParsedHierarchy/Flow/FlowLevel.ts","../src/compiler/Parser/ParsedHierarchy/Gather/Gather.ts","../src/compiler/Parser/ParsedHierarchy/Path.ts","../src/compiler/Parser/ParsedHierarchy/ReturnType.ts","../src/compiler/Parser/ParsedHierarchy/Flow/ClosestFlowBase.ts","../src/compiler/Parser/ParsedHierarchy/Identifier.ts","../src/compiler/Parser/ParsedHierarchy/Flow/FlowBase.ts","../src/compiler/Parser/ParsedHierarchy/ContentList.ts","../src/engine/VariableReference.ts","../src/compiler/Parser/ParsedHierarchy/Variable/VariableReference.ts","../src/compiler/Parser/ParsedHierarchy/FunctionCall.ts","../src/compiler/Parser/ParsedHierarchy/Expression/MultipleConditionExpression.ts","../src/compiler/Parser/ParsedHierarchy/Divert/DivertTarget.ts","../src/compiler/Parser/ParsedHierarchy/Divert/Divert.ts","../src/compiler/Parser/ParsedHierarchy/Gather/GatherPointToResolve.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/SequenceDivertToResolve.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/SequenceType.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/Sequence.ts","../src/compiler/Parser/ParsedHierarchy/TunnelOnwards.ts","../src/engine/ListDefinition.ts","../src/compiler/Parser/ParsedHierarchy/List/ListDefinition.ts","../src/compiler/Parser/ParsedHierarchy/Variable/VariableAssignment.ts","../src/compiler/Parser/ParsedHierarchy/Weave.ts","../src/compiler/Parser/ParsedHierarchy/Conditional/ConditionalSingleBranch.ts","../src/compiler/Parser/CustomFlags.ts","../src/engine/DebugMetadata.ts","../src/compiler/Parser/ParsedHierarchy/Declaration/ExternalDeclaration.ts","../src/compiler/Parser/FlowDecl.ts","../src/compiler/Parser/ParsedHierarchy/Wrap.ts","../src/compiler/Parser/ParsedHierarchy/Glue.ts","../src/engine/Glue.ts","../src/compiler/Parser/ParsedHierarchy/Expression/IncDecExpression.ts","../src/compiler/Parser/ParsedHierarchy/IncludedFile.ts","../src/compiler/Parser/InfixOperator.ts","../src/compiler/Parser/ParsedHierarchy/Knot.ts","../src/compiler/Parser/ParsedHierarchy/List/List.ts","../src/compiler/Parser/ParsedHierarchy/List/ListElementDefinition.ts","../src/compiler/Parser/StatementLevel.ts","../src/compiler/Parser/ParsedHierarchy/Stitch.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Flow.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts","../src/engine/Error.ts","../src/engine/Story.ts","../src/compiler/Parser/ParsedHierarchy/Story.ts","../src/compiler/Parser/ParsedHierarchy/Expression/StringExpression.ts","../src/compiler/Parser/ParsedHierarchy/Tag.ts","../src/compiler/FileHandler/DefaultFileHandler.ts","../src/compiler/Parser/InkParser.ts","../src/compiler/Compiler.ts","../src/compiler/Stats.ts","../src/compiler/FileHandler/JsonFileHandler.ts"],"sourcesContent":["import { ErrorHandler } from \"../engine/Error\";\nimport { IFileHandler } from \"./IFileHandler\";\n\nexport class CompilerOptions {\n  constructor(\n    public readonly sourceFilename: string | null = null,\n    public readonly pluginNames: string[] = [],\n    public readonly countAllVisits: boolean = false,\n    public readonly errorHandler: ErrorHandler | null = null,\n    public readonly fileHandler: IFileHandler | null = null\n  ) {}\n}\n","import { DebugMetadata } from \"../engine/DebugMetadata\";\n\nexport class DebugSourceRange {\n  constructor(\n    public readonly length: number,\n    public readonly debugMetadata: DebugMetadata | null,\n    public text: string\n  ) {}\n}\n","// TODO: Unifify with Engine.\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { Identifier } from \"./Identifier\";\n\nexport class Argument {\n  constructor(\n    public identifier: Identifier | null = null,\n    public isByReference: boolean | null = null,\n    public isDivertTarget: boolean | null = null\n  ) {}\n\n  get typeName(): string {\n    return \"Argument\";\n  }\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n\nexport function filterUndef<T>(element: T | undefined): element is T {\n  return element != undefined;\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { DebugMetadata } from \"../../../engine/DebugMetadata\";\nimport { FindQueryFunc } from \"./FindQueryFunc\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Path as RuntimePath } from \"../../../engine/Path\";\nimport { Story } from \"./Story\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport abstract class ParsedObject {\n  public abstract readonly GenerateRuntimeObject: () => RuntimeObject | null;\n\n  private _alreadyHadError: boolean = false;\n  private _alreadyHadWarning: boolean = false;\n  private _debugMetadata: DebugMetadata | null = null;\n  private _runtimeObject: RuntimeObject | null = null;\n\n  public content: ParsedObject[] = [];\n  public parent: ParsedObject | null = null;\n\n  get debugMetadata() {\n    if (this._debugMetadata === null && this.parent) {\n      return this.parent.debugMetadata;\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value: DebugMetadata | null) {\n    this._debugMetadata = value;\n  }\n\n  get hasOwnDebugMetadata(): boolean {\n    return Boolean(this.debugMetadata);\n  }\n\n  get typeName(): string {\n    return \"ParsedObject\";\n  }\n\n  public readonly GetType = (): string => this.typeName;\n\n  get story(): Story {\n    let ancestor: ParsedObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n\n    return ancestor as Story;\n  }\n\n  get runtimeObject(): RuntimeObject {\n    if (!this._runtimeObject) {\n      this._runtimeObject = this.GenerateRuntimeObject();\n      if (this._runtimeObject) {\n        this._runtimeObject.debugMetadata = this.debugMetadata;\n      }\n    }\n\n    return this._runtimeObject as RuntimeObject;\n  }\n\n  set runtimeObject(value: RuntimeObject) {\n    this._runtimeObject = value;\n  }\n\n  get runtimePath(): RuntimePath {\n    if (!this.runtimeObject.path) {\n      throw new Error();\n    }\n\n    return this.runtimeObject.path;\n  }\n\n  // When counting visits and turns since, different object\n  // types may have different containers that needs to be counted.\n  // For most it'll just be the object's main runtime object,\n  // but for e.g. choices, it'll be the target container.\n  get containerForCounting(): RuntimeContainer | null {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  get ancestry(): ParsedObject[] {\n    let result = [];\n\n    let ancestor = this.parent;\n    while (ancestor) {\n      result.push(ancestor);\n      ancestor = ancestor.parent;\n    }\n\n    result = result.reverse();\n\n    return result;\n  }\n\n  /*\n  get descriptionOfScope(): string {\n    const locationNames: string[] = [];\n\n    let ancestor: ParsedObject | null = this;\n    while (ancestor) {\n      var ancestorFlow = ancestor as FlowBase;\n      if (ancestorFlow && ancestorFlow.name != null) {\n        locationNames.push(`'${ancestorFlow.name}'`);\n      }\n      ancestor = ancestor.parent;\n    }\n\n    let scopeSB = '';\n    if (locationNames.length > 0) {\n      const locationsListStr = locationNames.join(', ');\n      scopeSB += `${locationsListStr} and`;\n    }\n\n    scopeSB += 'at top scope';\n\n    return scopeSB;\n  }\n*/\n\n  // Return the object so that method can be chained easily\n  public readonly AddContent = <T extends ParsedObject, V extends T | T[]>(\n    subContent: V\n  ) => {\n    if (this.content === null) {\n      this.content = [];\n    }\n\n    const sub = Array.isArray(subContent) ? subContent : [subContent];\n\n    // Make resilient to content not existing, which can happen\n    // in the case of parse errors where we've already reported\n    // an error but still want a valid structure so we can\n    // carry on parsing.\n    for (const ss of sub) {\n      if (ss.hasOwnProperty(\"parent\")) {\n        ss.parent = this;\n      }\n      this.content.push(ss);\n    }\n\n    if (Array.isArray(subContent)) {\n      return;\n    } else {\n      return subContent;\n    }\n  };\n\n  public readonly InsertContent = <T extends ParsedObject>(\n    index: number,\n    subContent: T\n  ): T => {\n    if (this.content === null) {\n      this.content = [];\n    }\n\n    subContent.parent = this;\n    this.content.splice(index, 0, subContent);\n\n    return subContent;\n  };\n\n  public readonly Find =\n    <T extends ParsedObject>(\n      type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n    ) =>\n    (queryFunc: FindQueryFunc<T> | null = null): T | null => {\n      let tObj = asOrNull(this, type) as any as T;\n      if (tObj !== null && (queryFunc === null || queryFunc(tObj) === true)) {\n        return tObj;\n      }\n\n      if (this.content === null) {\n        return null;\n      }\n\n      for (const obj of this.content) {\n        let nestedResult = obj.Find && obj.Find(type)(queryFunc);\n        if (nestedResult) {\n          return nestedResult as T;\n        }\n      }\n\n      return null;\n    };\n\n  public readonly FindAll =\n    <T extends ParsedObject>(\n      type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n    ) =>\n    (queryFunc?: FindQueryFunc<T>, foundSoFar?: T[]): T[] => {\n      const found = Array.isArray(foundSoFar) ? foundSoFar : [];\n\n      const tObj = asOrNull(this, type);\n      if (tObj !== null && (!queryFunc || queryFunc(tObj) === true)) {\n        found.push(tObj);\n      }\n\n      if (this.content === null) {\n        return [];\n      }\n\n      for (const obj of this.content) {\n        obj.FindAll && obj.FindAll(type)(queryFunc, found);\n      }\n\n      return found;\n    };\n\n  public ResolveReferences(context: Story) {\n    if (this.content !== null) {\n      for (const obj of this.content) {\n        obj.ResolveReferences(context);\n      }\n    }\n  }\n\n  public Error(\n    message: string,\n    source: ParsedObject | null = null,\n    isWarning: boolean = false\n  ): void {\n    if (source === null) {\n      source = this;\n    }\n\n    // Only allow a single parsed object to have a single error *directly* associated with it\n    if (\n      (source._alreadyHadError && !isWarning) ||\n      (source._alreadyHadWarning && isWarning)\n    ) {\n      return;\n    }\n\n    if (this.parent) {\n      this.parent.Error(message, source, isWarning);\n    } else {\n      throw new Error(`No parent object to send error to: ${message}`);\n    }\n\n    if (isWarning) {\n      source._alreadyHadWarning = true;\n    } else {\n      source._alreadyHadError = true;\n    }\n  }\n\n  public readonly Warning = (\n    message: string,\n    source: ParsedObject | null = null\n  ): void => {\n    this.Error(message, source, true);\n  };\n}\n","import { ParsedObject } from \"./Object\";\n\nexport class AuthorWarning extends ParsedObject {\n  constructor(public readonly warningMessage: string) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"AuthorWarning\";\n  }\n\n  public readonly GenerateRuntimeObject = (): null => {\n    this.Warning(this.warningMessage);\n    return null;\n  };\n}\n","export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string },\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path | null = null) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            if (namedChild.name === null)\n              return throwNullException(\"namedChild.name\");\n            comps.unshift(new Path.Component(namedChild.name!));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n\n  public Equals(obj: any) {\n    return obj === this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n\n  public Clear() {\n    this.string = \"\";\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      let otherOriginNames = otherList.originNames as string[];\n      if (otherOriginNames !== null)\n        this._originNames = otherOriginNames.slice();\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    if (myListItem == null || myListItem == \"\") return new InkList();\n    let listValue =\n      originStory.listDefinitions?.FindSingleItemListWithName(myListItem);\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(\n    itemOrItemName: InkListItem | string | null,\n    storyObject: Story | null = null\n  ) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else if (itemOrItemName !== null) {\n      //itemOrItemName is a string\n      let itemName = itemOrItemName as string;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null) {\n        if (storyObject == null) {\n          throw new Error(\n            \"Could not add the item \" +\n              itemName +\n              \" to this list because it isn't known to any list definitions previously associated with this list.\"\n          );\n        } else {\n          let newItem = InkList.FromString(itemName, storyObject)\n            .orderedItems[0];\n          this.Add(newItem.Key, newItem.Value);\n        }\n      } else {\n        let item = new InkListItem(foundListDef.name, itemName);\n        let itemVal = foundListDef.ValueForItem(item);\n        this.Add(item, itemVal);\n      }\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public HasIntersection(otherList: InkList): boolean {\n    for (let [key] of this) {\n      if (otherList.has(key)) return true;\n    }\n    return false;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n\n  public Contains(key: string): boolean;\n  public Contains(otherList: InkList): boolean;\n  public Contains(what: string | InkList): boolean {\n    if (typeof what == \"string\") return this.ContainsItemNamed(what);\n    const otherList = what;\n    if (otherList.size == 0 || this.size == 0) return false;\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (maxBound instanceof InkList && maxBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n\n  get singleItem(): InkListItem | null {\n    for (let item of this.orderedItems) {\n      return item.Key;\n    }\n    return null;\n  }\n\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string | null = null;\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name!);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    if (namedContentObj.name === null)\n      return throwNullException(\"namedContentObj.name\");\n    this.namedContent.set(namedContentObj.name!, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null =\n        currentContainer.ContentWithPathComponent(comp);\n\n      // Couldn't resolve entire path?\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      // Are we about to loop into another container?\n      // Is the object a container as expected? It might\n      // no longer be if the content has shuffled around, so what\n      // was originally a container no longer is.\n      const nextContainer: Container | null = asOrNull(foundObj, Container);\n      if (i < partialPathLength - 1 && nextContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = nextContainer;\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content.splice(index, 0, contentObj);\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content.push(...otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Start = 0,\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public static BeginTag() {\n    return new ControlCommand(ControlCommand.CommandType.BeginTag);\n  }\n  public static EndTag() {\n    return new ControlCommand(ControlCommand.CommandType.EndTag);\n  }\n  public toString() {\n    return \"ControlCommand \" + this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart, // 0\n    EvalOutput, // 1\n    EvalEnd, // 2\n    Duplicate, // 3\n    PopEvaluatedValue, // 4\n    PopFunction, // 5\n    PopTunnel, // 6\n    BeginString, // 7\n    EndString, // 8\n    NoOp, // 9\n    ChoiceCount, // 10\n    Turns, // 11\n    TurnsSince, // 12\n    ReadCount, // 13\n    Random, // 14\n    SeedRandom, // 15\n    VisitIndex, // 16\n    SequenceShuffleIndex, // 17\n    StartThread, // 18\n    Done, // 19\n    End, // 20\n    ListFromInt, // 21\n    ListRange, // 22\n    ListRandom, // 23\n    BeginTag, // 24\n    EndTag, // 25\n\n    TOTAL_VALUES,\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport abstract class Expression extends ParsedObject {\n  public abstract GenerateIntoContainer: (container: RuntimeContainer) => void;\n\n  private _prototypeRuntimeConstantExpression: RuntimeContainer | null = null;\n  public outputWhenComplete: boolean = false;\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Tell Runtime to start evaluating the following content as an expression\n    container.AddContent(RuntimeControlCommand.EvalStart());\n\n    this.GenerateIntoContainer(container);\n\n    // Tell Runtime to output the result of the expression evaluation to the output stream\n    if (this.outputWhenComplete) {\n      container.AddContent(RuntimeControlCommand.EvalOutput());\n    }\n\n    // Tell Runtime to stop evaluating the content as an expression\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n\n    return container;\n  };\n\n  // When generating the value of a constant expression,\n  // we can't just keep generating the same constant expression into\n  // different places where the constant value is referenced, since then\n  // the same runtime objects would be used in multiple places, which\n  // is impossible since each runtime object should have one parent.\n  // Instead, we generate a prototype of the runtime object(s), then\n  // copy them each time they're used.\n  public readonly GenerateConstantIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    if (this._prototypeRuntimeConstantExpression === null) {\n      this._prototypeRuntimeConstantExpression = new RuntimeContainer();\n      this.GenerateIntoContainer(this._prototypeRuntimeConstantExpression);\n    }\n\n    for (const runtimeObj of this._prototypeRuntimeConstantExpression.content) {\n      const copy = runtimeObj.Copy();\n      if (copy) {\n        container.AddContent(copy);\n      }\n    }\n  };\n\n  get typeName(): string {\n    return \"Expression\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public Equals(obj: ParsedObject): boolean {\n    return false;\n  }\n\n  public readonly toString = () => \"No string value in JavaScript.\";\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {\n  public toString() {\n    return \"Void\";\n  }\n}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          \"Attempting to perform \" +\n            this.name +\n            ' on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T extends { toString: () => string }>(\n    parametersOfSingleType: Array<Value<T>>\n  ) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<ValueType, BinaryOp<any> | UnaryOp<any>> | null =\n    null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { BoolValue, FloatValue, IntValue } from \"../../../../engine/Value\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\nimport { ParsedObject } from \"../Object\";\n\n// This class is named Number in the C# codebase\n// but this conflict with the built-in Number class\nexport class NumberExpression extends Expression {\n  public value: number | boolean;\n  public subtype: \"int\" | \"float\" | \"bool\";\n\n  constructor(value: number | boolean, subtype: \"int\" | \"float\" | \"bool\") {\n    super();\n\n    if (\n      (typeof value === \"number\" && !Number.isNaN(value)) ||\n      typeof value == \"boolean\"\n    ) {\n      this.value = value;\n      this.subtype = subtype;\n    } else {\n      throw new Error(\"Unexpected object type in NumberExpression.\");\n    }\n  }\n\n  get typeName(): string {\n    return \"Number\";\n  }\n\n  public isInt = (): boolean => this.subtype == \"int\";\n\n  public isFloat = (): boolean => this.subtype == \"float\";\n\n  public isBool = (): boolean => this.subtype == \"bool\";\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    if (this.isInt()) {\n      container.AddContent(new IntValue(this.value as number));\n    } else if (this.isFloat()) {\n      container.AddContent(new FloatValue(this.value as number));\n    } else if (this.isBool()) {\n      container.AddContent(new BoolValue(this.value as boolean));\n    }\n  };\n\n  public readonly toString = (): string => String(this.value);\n\n  public Equals(obj: ParsedObject): boolean {\n    const numberExpression = asOrNull(obj, NumberExpression);\n    if (!numberExpression) return false;\n\n    return (\n      numberExpression.subtype == this.subtype &&\n      numberExpression.value == this.value\n    );\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { NumberExpression } from \"./NumberExpression\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class UnaryExpression extends Expression {\n  get nativeNameForOp(): string {\n    // Replace \"-\" with \"_\" to make it unique (compared to subtraction)\n    if (this.op === \"-\") {\n      return \"_\";\n    } else if (this.op === \"not\") {\n      return \"!\";\n    }\n\n    return this.op;\n  }\n\n  public innerExpression: Expression;\n\n  // Attempt to flatten inner expression immediately\n  // e.g. convert (-(5)) into (-5)\n  public static readonly WithInner = (\n    inner: Expression,\n    op: string\n  ): Expression => {\n    const innerNumber = asOrNull(inner, NumberExpression);\n\n    if (innerNumber) {\n      if (op === \"-\") {\n        if (innerNumber.isInt()) {\n          return new NumberExpression(-innerNumber.value, \"int\");\n        } else if (innerNumber.isFloat()) {\n          return new NumberExpression(-innerNumber.value, \"float\");\n        }\n      } else if (op == \"!\" || op == \"not\") {\n        if (innerNumber.isInt()) {\n          return new NumberExpression(innerNumber.value == 0, \"bool\");\n        } else if (innerNumber.isFloat()) {\n          return new NumberExpression(innerNumber.value == 0.0, \"bool\");\n        } else if (innerNumber.isBool()) {\n          return new NumberExpression(!innerNumber.value, \"bool\");\n        }\n      }\n\n      throw new Error(\"Unexpected operation or number type\");\n    }\n\n    // Normal fallback\n    const unary = new UnaryExpression(inner, op);\n\n    return unary;\n  };\n\n  constructor(\n    inner: Expression,\n    public readonly op: string\n  ) {\n    super();\n\n    this.innerExpression = this.AddContent(inner) as Expression;\n  }\n\n  get typeName(): string {\n    return \"UnaryExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (container: RuntimeContainer) => {\n    this.innerExpression.GenerateIntoContainer(container);\n    container.AddContent(NativeFunctionCall.CallWithName(this.nativeNameForOp));\n  };\n\n  public readonly toString = (): string =>\n    this.nativeNameForOp + this.innerExpression;\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { Story } from \"../Story\";\nimport { UnaryExpression } from \"./UnaryExpression\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class BinaryExpression extends Expression {\n  public readonly leftExpression: Expression;\n  public readonly rightExpression: Expression;\n\n  constructor(\n    left: Expression,\n    right: Expression,\n    public opName: string\n  ) {\n    super();\n\n    this.leftExpression = this.AddContent(left) as Expression;\n    this.rightExpression = this.AddContent(right) as Expression;\n\n    this.opName = opName;\n  }\n\n  get typeName(): string {\n    return \"BinaryExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (container: RuntimeContainer) => {\n    this.leftExpression.GenerateIntoContainer(container);\n    this.rightExpression.GenerateIntoContainer(container);\n    this.opName = this.NativeNameForOp(this.opName);\n    container.AddContent(NativeFunctionCall.CallWithName(this.opName));\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Check for the following case:\n    //\n    //    (not A) ? B\n    //\n    // Since this easy to accidentally do:\n    //\n    //    not A ? B\n    //\n    // when you intend:\n    //\n    //    not (A ? B)\n    if (this.NativeNameForOp(this.opName) === \"?\") {\n      const leftUnary = asOrNull(this.leftExpression, UnaryExpression);\n      if (\n        leftUnary !== null &&\n        (leftUnary.op === \"not\" || leftUnary.op === \"!\")\n      ) {\n        this.Error(\n          `Using 'not' or '!' here negates '${leftUnary.innerExpression}' rather than the result of the '?' or 'has' operator. You need to add parentheses around the (A ? B) expression.`\n        );\n      }\n    }\n  }\n\n  public readonly NativeNameForOp = (opName: string): string => {\n    if (opName === \"and\") {\n      return \"&&\";\n    } else if (opName === \"or\") {\n      return \"||\";\n    } else if (opName === \"mod\") {\n      return \"%\";\n    } else if (opName === \"has\") {\n      return \"?\";\n    } else if (opName === \"hasnt\") {\n      return \"!?\";\n    }\n\n    return opName;\n  };\n\n  public readonly toString = (): string =>\n    `(${this.leftExpression} ${this.opName} ${this.rightExpression})`;\n}\n","export class CharacterSet {\n  public static readonly FromRange = (\n    start: string,\n    end: string\n  ): CharacterSet => new CharacterSet().AddRange(start, end);\n\n  public set: Set<string> = new Set<string>();\n\n  constructor(arg?: string | string[] | CharacterSet) {\n    if (arg) {\n      this.AddCharacters(arg);\n    }\n  }\n\n  public readonly Add = (arg: string) => this.set.add(arg);\n\n  public readonly AddRange = (start: string, end: string): CharacterSet => {\n    for (let c = start.charCodeAt(0); c <= end.charCodeAt(0); ++c) {\n      this.Add(String.fromCharCode(c));\n    }\n\n    return this;\n  };\n\n  public readonly AddCharacters = (\n    chars: string | string[] | CharacterSet\n  ): CharacterSet => {\n    if (typeof chars === \"string\" || Array.isArray(chars)) {\n      for (const c of chars) {\n        this.Add(c);\n      }\n    } else {\n      for (const c of chars.set) {\n        this.Add(c);\n      }\n    }\n\n    return this;\n  };\n}\n","import { CharacterSet } from \"./CharacterSet\";\n\n/// <summary>\n/// A class representing a character range. Allows for lazy-loading a corresponding <see cref=\"CharacterSet\">character set</see>.\n/// </summary>\nexport class CharacterRange {\n  public static Define = (\n    start: string,\n    end: string,\n    excludes: string[] | CharacterSet = []\n  ): CharacterRange => new CharacterRange(start, end, excludes);\n\n  private _correspondingCharSet: CharacterSet = new CharacterSet();\n  private _excludes = new Set<string>();\n\n  constructor(\n    private _start: string,\n    private _end: string,\n    excludes: string[] | CharacterSet = []\n  ) {\n    if (excludes instanceof CharacterSet) {\n      this._excludes = excludes.set;\n    } else {\n      for (const item of excludes) {\n        this._excludes.add(item);\n      }\n    }\n  }\n\n  get start(): string {\n    return this._start;\n  }\n\n  get end(): string {\n    return this._end;\n  }\n\n  /// <summary>\n  /// Returns a <see cref=\"CharacterSet\">character set</see> instance corresponding to the character range\n  /// represented by the current instance.\n  /// </summary>\n  /// <remarks>\n  /// The internal character set is created once and cached in memory.\n  /// </remarks>\n  /// <returns>The char set.</returns>\n  public readonly ToCharacterSet = (): CharacterSet => {\n    if (this._correspondingCharSet.set.size === 0) {\n      for (\n        let ii = this.start.charCodeAt(0), c;\n        ii <= this.end.charCodeAt(0);\n        ii += 1\n      ) {\n        c = String.fromCharCode(ii);\n        if (!this._excludes.has(c)) {\n          this._correspondingCharSet.AddCharacters(c);\n        }\n      }\n    }\n\n    return this._correspondingCharSet;\n  };\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","export enum SymbolType {\n  Knot = 0,\n  List = 1,\n  ListItem = 2,\n  Var = 3,\n  SubFlowAndWeave = 4,\n  Arg = 5,\n  Temp = 6,\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { ChoicePoint } from \"../../../engine/ChoicePoint\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ContentList } from \"./ContentList\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../engine/Value\";\nimport { INamedContent } from \"../../../engine/INamedContent\";\nimport { IWeavePoint } from \"./IWeavePoint\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Path as RuntimePath } from \"../../../engine/Path\";\nimport { Story } from \"./Story\";\nimport { SymbolType } from \"./SymbolType\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../engine/VariableAssignment\";\nimport { Expression } from \"./Expression/Expression\";\nimport { Identifier } from \"./Identifier\";\n\nexport class Choice extends ParsedObject implements IWeavePoint, INamedContent {\n  private _condition: Expression | null = null;\n  private _innerContentContainer: RuntimeContainer | null = null;\n  private _outerContainer: RuntimeContainer | null = null;\n  private _runtimeChoice: ChoicePoint | null = null;\n  get runtimeChoice(): ChoicePoint {\n    if (!this._runtimeChoice) {\n      throw new Error();\n    }\n\n    return this._runtimeChoice;\n  }\n\n  private _returnToR1: DivertTargetValue | null = null;\n  private _returnToR2: DivertTargetValue | null = null;\n  private _r1Label: RuntimeContainer | null = null;\n  private _r2Label: RuntimeContainer | null = null;\n  private _divertToStartContentOuter: RuntimeDivert | null = null;\n  private _divertToStartContentInner: RuntimeDivert | null = null;\n  private _startContentRuntimeContainer: RuntimeContainer | null = null;\n\n  public startContent: ContentList;\n  public choiceOnlyContent: ContentList;\n  public innerContent: ContentList;\n  public identifier?: Identifier;\n  get name() {\n    return this.identifier?.name || null;\n  }\n  public onceOnly: boolean;\n  public isInvisibleDefault: boolean = false;\n  public indentationDepth: number;\n  public hasWeaveStyleInlineBrackets: boolean = false;\n\n  get condition() {\n    return this._condition;\n  }\n\n  set condition(value) {\n    this._condition = value;\n    if (value) {\n      this.AddContent(value as ParsedObject);\n    }\n  }\n\n  // Required for IWeavePoint interface\n  // Choice's target container. Used by weave to append any extra\n  // nested weave content into.\n  get runtimeContainer() {\n    return this._innerContentContainer;\n  }\n\n  get innerContentContainer() {\n    return this._innerContentContainer;\n  }\n\n  get containerForCounting() {\n    return this._innerContentContainer;\n  }\n\n  // Override runtimePath to point to the Choice's target content (after it's chosen),\n  // as opposed to the default implementation which would point to the choice itself\n  // (or it's outer container), which is what runtimeObject is.\n  get runtimePath(): RuntimePath {\n    if (!this.innerContentContainer || !this.innerContentContainer.path) {\n      throw new Error();\n    }\n\n    return this.innerContentContainer.path;\n  }\n\n  constructor(\n    startContent: ContentList,\n    choiceOnlyContent: ContentList,\n    innerContent: ContentList\n  ) {\n    super();\n\n    this.startContent = startContent;\n    this.choiceOnlyContent = choiceOnlyContent;\n    this.innerContent = innerContent;\n    this.indentationDepth = 1;\n\n    if (startContent) {\n      this.AddContent(this.startContent);\n    }\n\n    if (choiceOnlyContent) {\n      this.AddContent(this.choiceOnlyContent);\n    }\n\n    if (innerContent) {\n      this.AddContent(this.innerContent);\n    }\n\n    this.onceOnly = true; // default\n  }\n\n  get typeName(): string {\n    return \"Choice\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    this._outerContainer = new RuntimeContainer();\n\n    // Content names for different types of choice:\n    //  * start content [choice only content] inner content\n    //  * start content   -> divert\n    //  * start content\n    //  * [choice only content]\n\n    // Hmm, this structure has become slightly insane!\n    //\n    // [\n    //     EvalStart\n    //     assign $r = $r1   -- return target = return label 1\n    //     BeginString\n    //     -> s\n    //     [(r1)]            -- return label 1 (after start content)\n    //     EndString\n    //     BeginString\n    //     ... choice only content\n    //     EndEval\n    //     Condition expression\n    //     choice: -> \"c-0\"\n    //     (s) = [\n    //         start content\n    //         -> r          -- goto return label 1 or 2\n    //     ]\n    //  ]\n    //\n    //  in parent's container: (the inner content for the choice)\n    //\n    //  (c-0) = [\n    //      EvalStart\n    //      assign $r = $r2   -- return target = return label 2\n    //      EndEval\n    //      -> s\n    //      [(r2)]            -- return label 1 (after start content)\n    //      inner content\n    //  ]\n    //\n\n    this._runtimeChoice = new ChoicePoint(this.onceOnly);\n    this._runtimeChoice.isInvisibleDefault = this.isInvisibleDefault;\n\n    if (this.startContent || this.choiceOnlyContent || this.condition) {\n      this._outerContainer.AddContent(RuntimeControlCommand.EvalStart());\n    }\n\n    // Start content is put into a named container that's referenced both\n    // when displaying the choice initially, and when generating the text\n    // when the choice is chosen.\n    if (this.startContent) {\n      // Generate start content and return\n      //  - We can't use a function since it uses a call stack element, which would\n      //    put temporary values out of scope. Instead we manually divert around.\n      //  - $r is a variable divert target contains the return point\n      this._returnToR1 = new DivertTargetValue();\n      this._outerContainer.AddContent(this._returnToR1);\n\n      const varAssign = new RuntimeVariableAssignment(\"$r\", true);\n      this._outerContainer.AddContent(varAssign);\n\n      // Mark the start of the choice text generation, so that the runtime\n      // knows where to rewind to to extract the content from the output stream.\n      this._outerContainer.AddContent(RuntimeControlCommand.BeginString());\n\n      this._divertToStartContentOuter = new RuntimeDivert();\n      this._outerContainer.AddContent(this._divertToStartContentOuter);\n\n      // Start content itself in a named container\n      this._startContentRuntimeContainer =\n        this.startContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._startContentRuntimeContainer.name = \"s\";\n\n      // Effectively, the \"return\" statement - return to the point specified by $r\n      const varDivert = new RuntimeDivert();\n      varDivert.variableDivertName = \"$r\";\n      this._startContentRuntimeContainer.AddContent(varDivert);\n\n      // Add the container\n      this._outerContainer.AddToNamedContentOnly(\n        this._startContentRuntimeContainer\n      );\n\n      // This is the label to return to\n      this._r1Label = new RuntimeContainer();\n      this._r1Label.name = \"$r1\";\n      this._outerContainer.AddContent(this._r1Label);\n\n      this._outerContainer.AddContent(RuntimeControlCommand.EndString());\n\n      this._runtimeChoice.hasStartContent = true;\n    }\n\n    // Choice only content - mark the start, then generate it directly into the outer container\n    if (this.choiceOnlyContent) {\n      this._outerContainer.AddContent(RuntimeControlCommand.BeginString());\n\n      const choiceOnlyRuntimeContent =\n        this.choiceOnlyContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._outerContainer.AddContentsOfContainer(choiceOnlyRuntimeContent);\n\n      this._outerContainer.AddContent(RuntimeControlCommand.EndString());\n\n      this._runtimeChoice.hasChoiceOnlyContent = true;\n    }\n\n    // Generate any condition for this choice\n    if (this.condition) {\n      this.condition.GenerateIntoContainer(this._outerContainer);\n      this._runtimeChoice.hasCondition = true;\n    }\n\n    if (this.startContent || this.choiceOnlyContent || this.condition) {\n      this._outerContainer.AddContent(RuntimeControlCommand.EvalEnd());\n    }\n\n    // Add choice itself\n    this._outerContainer.AddContent(this._runtimeChoice);\n\n    // Container that choice points to for when it's chosen\n    this._innerContentContainer = new RuntimeContainer();\n\n    // Repeat start content by diverting to its container\n    if (this.startContent) {\n      // Set the return point when jumping back into the start content\n      //  - In this case, it's the $r2 point, within the choice content \"c\".\n      this._returnToR2 = new DivertTargetValue();\n      this._innerContentContainer.AddContent(RuntimeControlCommand.EvalStart());\n      this._innerContentContainer.AddContent(this._returnToR2);\n      this._innerContentContainer.AddContent(RuntimeControlCommand.EvalEnd());\n      const varAssign = new RuntimeVariableAssignment(\"$r\", true);\n      this._innerContentContainer.AddContent(varAssign);\n\n      // Main divert into start content\n      this._divertToStartContentInner = new RuntimeDivert();\n      this._innerContentContainer.AddContent(this._divertToStartContentInner);\n\n      // Define label to return to\n      this._r2Label = new RuntimeContainer();\n      this._r2Label.name = \"$r2\";\n      this._innerContentContainer.AddContent(this._r2Label);\n    }\n\n    // Choice's own inner content\n    if (this.innerContent) {\n      const innerChoiceOnlyContent =\n        this.innerContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._innerContentContainer.AddContentsOfContainer(\n        innerChoiceOnlyContent\n      );\n    }\n\n    if (this.story.countAllVisits) {\n      this._innerContentContainer.visitsShouldBeCounted = true;\n    }\n\n    this._innerContentContainer.countingAtStartOnly = true;\n\n    return this._outerContainer;\n  };\n\n  public ResolveReferences(context: Story): void {\n    // Weave style choice - target own content container\n    if (this._innerContentContainer) {\n      this.runtimeChoice.pathOnChoice = this._innerContentContainer.path;\n\n      if (this.onceOnly) {\n        this._innerContentContainer.visitsShouldBeCounted = true;\n      }\n    }\n\n    if (this._returnToR1) {\n      if (!this._r1Label) {\n        throw new Error();\n      }\n\n      this._returnToR1.targetPath = this._r1Label.path;\n    }\n\n    if (this._returnToR2) {\n      if (!this._r2Label) {\n        throw new Error();\n      }\n\n      this._returnToR2.targetPath = this._r2Label.path;\n    }\n\n    if (this._divertToStartContentOuter) {\n      if (!this._startContentRuntimeContainer) {\n        throw new Error();\n      }\n\n      this._divertToStartContentOuter.targetPath =\n        this._startContentRuntimeContainer.path;\n    }\n\n    if (this._divertToStartContentInner) {\n      if (!this._startContentRuntimeContainer) {\n        throw new Error();\n      }\n\n      this._divertToStartContentInner.targetPath =\n        this._startContentRuntimeContainer.path;\n    }\n\n    super.ResolveReferences(context);\n\n    if (this.identifier && (this.identifier?.name || \"\").length > 0) {\n      context.CheckForNamingCollisions(\n        this as ParsedObject,\n        this.identifier,\n        SymbolType.SubFlowAndWeave\n      );\n    }\n  }\n\n  public readonly toString = () => {\n    if (this.choiceOnlyContent !== null) {\n      return `* ${this.startContent}[${this.choiceOnlyContent}]...`;\n    }\n\n    return `* ${this.startContent}...`;\n  };\n}\n","export class StringParserElement {\n  public static _uniqueIdCounter: number = 1000;\n\n  public characterIndex: number = 0;\n  public characterInLineIndex: number = 0;\n  public lineIndex: number = 0;\n  public reportedErrorInScope: boolean = false;\n  public uniqueId: number = 0;\n  public customFlags: number = 0;\n\n  public readonly CopyFrom = (fromElement: StringParserElement): void => {\n    StringParserElement._uniqueIdCounter++;\n    this.uniqueId = StringParserElement._uniqueIdCounter;\n    this.characterIndex = fromElement.characterIndex;\n    this.characterInLineIndex = fromElement.characterInLineIndex;\n    this.lineIndex = fromElement.lineIndex;\n    this.customFlags = fromElement.customFlags;\n    this.reportedErrorInScope = false;\n  };\n\n  // Squash is used when succeeding from a rule,\n  // so only the state information we wanted to carry forward is\n  // retained. e.g. characterIndex and lineIndex are global,\n  // however uniqueId is specific to the individual rule,\n  // and likewise, custom flags are designed for the temporary\n  // state of the individual rule too.\n  public readonly SquashFrom = (fromElement: StringParserElement): void => {\n    this.characterIndex = fromElement.characterIndex;\n    this.characterInLineIndex = fromElement.characterInLineIndex;\n    this.lineIndex = fromElement.lineIndex;\n    this.reportedErrorInScope = fromElement.reportedErrorInScope;\n    this.customFlags = fromElement.customFlags;\n  };\n}\n","import { StringParserElement } from \"./StringParserElement\";\n\nexport class StringParserState {\n  private _stack: StringParserElement[] = [];\n  private _numElements: number = 0;\n\n  get currentElement(): StringParserElement {\n    return this._stack[this._numElements - 1];\n  }\n\n  get lineIndex(): number {\n    return this.currentElement.lineIndex;\n  }\n\n  set lineIndex(value: number) {\n    this.currentElement.lineIndex = value;\n  }\n\n  get characterIndex(): number {\n    return this.currentElement.characterIndex;\n  }\n\n  set characterIndex(value: number) {\n    this.currentElement.characterIndex = value;\n  }\n\n  get characterInLineIndex(): number {\n    return this.currentElement.characterInLineIndex;\n  }\n\n  set characterInLineIndex(value: number) {\n    this.currentElement.characterInLineIndex = value;\n  }\n\n  get customFlags(): number {\n    return this.currentElement.customFlags;\n  }\n\n  set customFlags(value: number) {\n    this.currentElement.customFlags = value;\n  }\n\n  get errorReportedAlreadyInScope(): boolean {\n    return this.currentElement.reportedErrorInScope;\n  }\n\n  get stackHeight(): number {\n    return this._numElements;\n  }\n\n  constructor() {\n    const kExpectedMaxStackDepth = 200;\n    for (let i = 0; i < kExpectedMaxStackDepth; i++) {\n      this._stack[i] = new StringParserElement();\n    }\n    this._numElements = 1;\n  }\n\n  public readonly StringParserState = (): void => {\n    const kExpectedMaxStackDepth: number = 200;\n    this._stack = new Array(kExpectedMaxStackDepth);\n\n    for (let ii = 0; ii < kExpectedMaxStackDepth; ++ii) {\n      this._stack[ii] = new StringParserElement();\n    }\n\n    this._numElements = 1;\n  };\n\n  public readonly Push = (): number => {\n    if (this._numElements >= this._stack.length && this._numElements > 0) {\n      throw new Error(\"Stack overflow in parser state.\");\n    }\n\n    const prevElement = this._stack[this._numElements - 1];\n    const newElement = this._stack[this._numElements];\n    this._numElements++;\n\n    newElement.CopyFrom(prevElement);\n\n    return newElement.uniqueId;\n  };\n\n  public readonly Pop = (expectedRuleId: number): void => {\n    if (this._numElements == 1) {\n      throw new Error(\n        \"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\"\n      );\n    }\n\n    if (this.currentElement.uniqueId != expectedRuleId) {\n      throw new Error(\n        \"Mismatched rule IDs while Poping - do you have mismatched Begin/Succeed/Fail?\"\n      );\n    }\n\n    // Restore state\n    this._numElements -= 1;\n  };\n\n  public Peek = (expectedRuleId: number) => {\n    if (this.currentElement.uniqueId != expectedRuleId) {\n      throw new Error(\n        \"Mismatched rule IDs while Peeking - do you have mismatched Begin/Succeed/Fail?\"\n      );\n    }\n\n    return this._stack[this._numElements - 1];\n  };\n\n  public readonly PeekPenultimate = (): StringParserElement | null => {\n    if (this._numElements >= 2) {\n      return this._stack[this._numElements - 2];\n    }\n\n    return null;\n  };\n\n  // Reduce stack height while maintaining currentElement\n  // Remove second last element: i.e. \"squash last two elements together\"\n  // Used when succeeding from a rule (and ONLY when succeeding, since\n  // the state of the top element is retained).\n  public readonly Squash = (): void => {\n    if (this._numElements < 2) {\n      throw new Error(\n        \"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\"\n      );\n    }\n\n    const penultimateEl = this._stack[this._numElements - 2];\n    const lastEl = this._stack[this._numElements - 1];\n\n    penultimateEl.SquashFrom(lastEl);\n\n    this._numElements -= 1;\n  };\n\n  public readonly NoteErrorReported = (): void => {\n    for (const el of this._stack) {\n      el.reportedErrorInScope = true;\n    }\n  };\n}\n","import { CharacterSet } from \"../CharacterSet\";\nimport { ParsedObject } from \"../ParsedHierarchy/Object\";\nimport { StringParserState } from \"./StringParserState\";\nimport { StringParserElement } from \"./StringParserElement\";\n\nexport const ParseSuccess = Symbol(\"ParseSuccessStruct\");\n\nexport type ParseRule = () => ParseRuleReturn;\n\nexport type ParseRuleReturn =\n  | object\n  | string\n  | null\n  | number\n  | (typeof StringParser)[\"ParseSuccess\"];\n\nexport type SpecificParseRule<T extends ParseRule> = T;\n\nexport class StringParser {\n  public ParseRule: ParseRule | null = null;\n\n  public static readonly ParseSuccess: typeof ParseSuccess = ParseSuccess;\n  public static readonly numbersCharacterSet = new CharacterSet(\"0123456789\");\n\n  private _chars: string[];\n\n  public errorHandler:\n    | null\n    | ((\n        message: string,\n        index: number,\n        lineIndex?: number,\n        isWarning?: boolean\n      ) => void) = null;\n  public state: StringParserState;\n  public hadError: boolean = false;\n\n  constructor(str: string) {\n    const strPreProc = this.PreProcessInputString(str);\n    this.state = new StringParserState();\n\n    if (str) {\n      this._chars = strPreProc.split(\"\");\n    } else {\n      this._chars = [];\n    }\n\n    this.inputString = strPreProc;\n  }\n\n  get currentCharacter(): string {\n    if (this.index >= 0 && this.remainingLength > 0) {\n      return this._chars[this.index];\n    }\n\n    return \"0\";\n  }\n\n  // Don't do anything by default, but provide ability for subclasses\n  // to manipulate the string before it's used as input (converted to a char array)\n  public PreProcessInputString(str: string): string {\n    return str;\n  }\n\n  //--------------------------------\n  // Parse state\n  //--------------------------------\n\n  public readonly BeginRule = (): number => this.state.Push();\n\n  public readonly FailRule = (expectedRuleId: number): ParseRuleReturn => {\n    this.state.Pop(expectedRuleId);\n    return null;\n  };\n\n  public readonly CancelRule = (expectedRuleId: number): void => {\n    this.state.Pop(expectedRuleId);\n  };\n\n  public readonly SucceedRule = (\n    expectedRuleId: number,\n    result: ParseRuleReturn = null\n  ): ParseRuleReturn => {\n    // Get state at point where this rule stared evaluating\n    const stateAtSucceedRule = this.state.Peek(expectedRuleId);\n    const stateAtBeginRule = this.state.PeekPenultimate();\n\n    // Allow subclass to receive callback\n    if (this.RuleDidSucceed) {\n      this.RuleDidSucceed(result, stateAtBeginRule, stateAtSucceedRule);\n    }\n\n    // Flatten state stack so that we maintain the same values,\n    // but remove one level in the stack.\n    this.state.Squash();\n\n    let finalResult: ParseRuleReturn = result;\n    if (finalResult === null) {\n      finalResult = StringParser.ParseSuccess;\n    }\n\n    return finalResult;\n  };\n\n  public RuleDidSucceed?: (\n    result: ParseRuleReturn,\n    startState: StringParserElement | null,\n    endState: StringParserElement\n  ) => void;\n\n  public readonly Expect = (\n    rule: ParseRule,\n    message: string | null = null,\n    recoveryRule: ParseRule | null = null\n  ): ParseRuleReturn => {\n    let result: ParseRuleReturn = this.ParseObject(rule);\n    if (result === null) {\n      if (message === null) {\n        message = rule.name;\n      }\n\n      let butSaw: string;\n      const lineRemainder: string = this.LineRemainder();\n      if (lineRemainder === null || lineRemainder.length === 0) {\n        butSaw = \"end of line\";\n      } else {\n        butSaw = `'${lineRemainder}'`;\n      }\n\n      this.Error(`Expected ${message} but saw ${butSaw}`);\n\n      if (recoveryRule !== null) {\n        result = recoveryRule();\n      }\n    }\n\n    return result;\n  };\n\n  public Error = (message: string, isWarning: boolean = false): void => {\n    this.ErrorOnLine(message, this.lineIndex + 1, isWarning);\n  };\n\n  public readonly ErrorWithParsedObject = (\n    message: string,\n    result: ParsedObject,\n    isWarning: boolean = false\n  ): void => {\n    this.ErrorOnLine(\n      message,\n      result.debugMetadata ? result.debugMetadata.startLineNumber : -1,\n      isWarning\n    );\n  };\n\n  public readonly ErrorOnLine = (\n    message: string,\n    lineNumber: number,\n    isWarning: boolean\n  ): void => {\n    if (!this.state.errorReportedAlreadyInScope) {\n      const errorType = isWarning ? \"Warning\" : \"Error\";\n\n      if (!this.errorHandler) {\n        throw new Error(`${errorType} on line ${lineNumber}: ${message}`);\n      } else {\n        this.errorHandler(message, this.index, lineNumber - 1, isWarning);\n      }\n\n      this.state.NoteErrorReported();\n    }\n\n    if (!isWarning) {\n      this.hadError = true;\n    }\n  };\n\n  public readonly Warning = (message: string): void =>\n    this.Error(message, true);\n\n  get endOfInput(): boolean {\n    return this.index >= this._chars.length;\n  }\n\n  get remainingString(): string {\n    return this._chars\n      .slice(this.index, this.index + this.remainingLength)\n      .join(\"\");\n  }\n\n  public readonly LineRemainder = (): string =>\n    this.Peek(() => this.ParseUntilCharactersFromString(\"\\n\\r\")) as string;\n\n  get remainingLength() {\n    return this._chars.length - this.index;\n  }\n\n  public inputString: string;\n\n  get lineIndex() {\n    return this.state.lineIndex;\n  }\n\n  set lineIndex(value: number) {\n    this.state.lineIndex = value;\n  }\n\n  set characterInLineIndex(value: number) {\n    this.state.characterInLineIndex = value;\n  }\n\n  get characterInLineIndex() {\n    return this.state.characterInLineIndex;\n  }\n\n  get index(): number {\n    // If we want subclass parsers to be able to set the index directly,\n    // then we would need to know what the lineIndex of the new\n    // index would be - would we have to step through manually\n    // counting the newlines to do so?\n    return this.state.characterIndex;\n  }\n\n  set index(value: number) {\n    this.state.characterIndex = value;\n  }\n\n  public readonly SetFlag = (flag: number, trueOrFalse: boolean): void => {\n    if (trueOrFalse) {\n      this.state.customFlags |= flag;\n    } else {\n      this.state.customFlags &= ~flag;\n    }\n  };\n\n  public readonly GetFlag = (flag: number): boolean =>\n    Boolean(this.state.customFlags & flag);\n\n  //--------------------------------\n  // Structuring\n  //--------------------------------\n\n  public ParseObject = (rule: ParseRule): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n    const stackHeightBefore = this.state.stackHeight;\n    const result = rule();\n\n    if (stackHeightBefore !== this.state.stackHeight) {\n      throw new Error(\"Mismatched Begin/Fail/Succeed rules\");\n    }\n\n    if (result === null) {\n      return this.FailRule(ruleId);\n    }\n\n    this.SucceedRule(ruleId, result);\n\n    return result;\n  };\n\n  public readonly Parse = <T extends ParseRule>(\n    rule: SpecificParseRule<T>\n  ): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n\n    const result: ParseRuleReturn = rule();\n    if (result === null) {\n      this.FailRule(ruleId);\n      return null;\n    }\n\n    this.SucceedRule(ruleId, result);\n\n    return result;\n  };\n\n  public readonly OneOf = (array: ParseRule[]): ParseRuleReturn => {\n    for (const rule of array) {\n      const result = this.ParseObject(rule);\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  public readonly OneOrMore = (rule: ParseRule): ParseRuleReturn[] | null => {\n    const results: ParseRuleReturn[] = [];\n    let result: ParseRuleReturn = null;\n\n    do {\n      result = this.ParseObject(rule);\n      if (result !== null) {\n        results.push(result);\n      }\n    } while (result !== null);\n\n    if (results.length > 0) {\n      return results;\n    }\n\n    return null;\n  };\n\n  public readonly Optional =\n    (rule: ParseRule): ParseRule =>\n    () => {\n      const result = this.ParseObject(rule);\n      if (result === null) return StringParser.ParseSuccess;\n      return result;\n    };\n\n  // Return ParseSuccess instead the real result so that it gets excluded\n  // from result arrays (e.g. Interleave)\n  public readonly Exclude =\n    (rule: ParseRule): ParseRule =>\n    () =>\n      this.ParseObject(rule) && StringParser.ParseSuccess;\n\n  // Combination of both of the above\n  public readonly OptionalExclude =\n    (rule: ParseRule): ParseRule =>\n    () => {\n      this.ParseObject(rule);\n      return StringParser.ParseSuccess;\n    };\n\n  // Convenience method for creating more readable ParseString rules that can be combined\n  // in other structuring rules (like OneOf etc)\n  // e.g. OneOf(String(\"one\"), String(\"two\"))\n  public readonly String =\n    (str: string): ParseRule =>\n    () =>\n      this.ParseString(str);\n\n  private readonly TryAddResultToList = <T>(\n    result: ParseRuleReturn,\n    list: T[],\n    flatten: boolean = true\n  ): void => {\n    if (result === StringParser.ParseSuccess) {\n      return;\n    }\n\n    if (flatten && Array.isArray(result)) {\n      const resultCollection = result as ParseRuleReturn[];\n      if (resultCollection !== null) {\n        for (const obj of resultCollection) {\n          list.push(obj as any);\n        }\n\n        return;\n      }\n    }\n\n    list.push(result as any);\n  };\n\n  public readonly Interleave = <T>(\n    ruleA: ParseRule,\n    ruleB: ParseRule,\n    untilTerminator: ParseRule | null = null,\n    flatten: boolean = true\n  ): T[] => {\n    const ruleId: number = this.BeginRule();\n    const results: T[] = [];\n\n    // First outer padding\n    const firstA = this.ParseObject(ruleA);\n    if (firstA === null) {\n      return this.FailRule(ruleId) as any;\n    } else {\n      this.TryAddResultToList(firstA, results, flatten);\n    }\n\n    let lastMainResult: ParseRuleReturn | null = null;\n    let outerResult: ParseRuleReturn | null = null;\n    do {\n      // \"until\" condition hit?\n      if (untilTerminator !== null && this.Peek(untilTerminator) !== null) {\n        break;\n      }\n\n      // Main inner\n      lastMainResult = this.ParseObject(ruleB);\n      if (lastMainResult === null) {\n        break;\n      } else {\n        this.TryAddResultToList(lastMainResult, results, flatten);\n      }\n\n      // Outer result (i.e. last A in ABA)\n      outerResult = null;\n      if (lastMainResult !== null) {\n        outerResult = this.ParseObject(ruleA);\n\n        if (outerResult === null) {\n          break;\n        } else {\n          this.TryAddResultToList(outerResult, results, flatten);\n        }\n      }\n\n      // Stop if there are no results, or if both are the placeholder \"ParseSuccess\" (i.e. Optional success rather than a true value)\n    } while (\n      (lastMainResult !== null || outerResult !== null) &&\n      !(\n        (lastMainResult as any) === StringParser.ParseSuccess &&\n        outerResult == StringParser.ParseSuccess\n      ) &&\n      this.remainingLength > 0\n    );\n\n    if (results.length === 0) {\n      return this.FailRule(ruleId) as T[];\n    }\n\n    return this.SucceedRule(ruleId, results) as T[];\n  };\n\n  //--------------------------------\n  // Basic string parsing\n  //--------------------------------\n\n  public readonly ParseString = (str: string): string | null => {\n    if (str.length > this.remainingLength) {\n      return null;\n    }\n\n    const ruleId: number = this.BeginRule();\n\n    // Optimisation from profiling:\n    // Store in temporary local variables\n    // since they're properties that would have to access\n    // the rule stack every time otherwise.\n    let i: number = this.index;\n    let cli: number = this.characterInLineIndex;\n    let li: number = this.lineIndex;\n\n    let success: boolean = true;\n    for (let tempIdx = 0; tempIdx < str.length; tempIdx += 1) {\n      const c = str[tempIdx];\n\n      if (this._chars[i] !== c) {\n        success = false;\n        break;\n      }\n      if (c === \"\\n\") {\n        li++;\n        cli = -1;\n      }\n\n      i++;\n      cli++;\n    }\n\n    this.index = i;\n    this.characterInLineIndex = cli;\n    this.lineIndex = li;\n\n    if (success) {\n      return this.SucceedRule(ruleId, str) as any;\n    }\n\n    return this.FailRule(ruleId) as any;\n  };\n\n  public readonly ParseSingleCharacter = (): string => {\n    if (this.remainingLength > 0) {\n      const c = this._chars[this.index];\n      if (c === \"\\n\") {\n        this.lineIndex += 1;\n        this.characterInLineIndex = -1;\n      }\n\n      this.index += 1;\n      this.characterInLineIndex += 1;\n\n      return c;\n    }\n\n    return \"0\";\n  };\n\n  public readonly ParseUntilCharactersFromString = (\n    str: string,\n    maxCount: number = -1\n  ): string | null => this.ParseCharactersFromString(str, false, maxCount);\n\n  public readonly ParseUntilCharactersFromCharSet = (\n    charSet: CharacterSet,\n    maxCount: number = -1\n  ): string | null => this.ParseCharactersFromCharSet(charSet, false, maxCount);\n\n  public readonly ParseCharactersFromString = (\n    str: string,\n    maxCountOrShouldIncludeStrChars: boolean | number = -1,\n    maxCount: number = -1\n  ): string | null => {\n    const charSet = new CharacterSet(str);\n    if (typeof maxCountOrShouldIncludeStrChars === \"number\") {\n      return this.ParseCharactersFromCharSet(\n        charSet,\n        true,\n        maxCountOrShouldIncludeStrChars\n      );\n    }\n\n    return this.ParseCharactersFromCharSet(\n      charSet,\n      maxCountOrShouldIncludeStrChars,\n      maxCount\n    );\n  };\n\n  public readonly ParseCharactersFromCharSet = (\n    charSet: CharacterSet,\n    shouldIncludeChars: boolean = true,\n    maxCount: number = -1\n  ): string | null => {\n    if (maxCount === -1) {\n      maxCount = Number.MAX_SAFE_INTEGER;\n    }\n\n    const startIndex: number = this.index;\n\n    // Optimisation from profiling:\n    // Store in temporary local variables\n    // since they're properties that would have to access\n    // the rule stack every time otherwise.\n    let ii: number = this.index;\n    let cli: number = this.characterInLineIndex;\n    let li: number = this.lineIndex;\n    let count: number = 0;\n    while (\n      ii < this._chars.length &&\n      charSet.set.has(this._chars[ii]) === shouldIncludeChars &&\n      count < maxCount\n    ) {\n      if (this._chars[ii] === \"\\n\") {\n        li += 1;\n        cli = -1;\n      }\n\n      ii += 1;\n      cli += 1;\n      count += 1;\n    }\n\n    this.index = ii;\n    this.characterInLineIndex = cli;\n    this.lineIndex = li;\n\n    const lastCharIndex: number = this.index;\n    if (lastCharIndex > startIndex) {\n      return this._chars.slice(startIndex, this.index).join(\"\");\n    }\n\n    return null;\n  };\n\n  public readonly Peek = (rule: ParseRule): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n    const result: ParseRuleReturn = rule();\n    this.CancelRule(ruleId);\n\n    return result;\n  };\n\n  public ParseUntil(\n    stopRule: ParseRule,\n    pauseCharacters: CharacterSet | null = null,\n    endCharacters: CharacterSet | null = null\n  ): string {\n    const ruleId: number = this.BeginRule();\n    const pauseAndEnd: CharacterSet = new CharacterSet();\n    if (pauseCharacters !== null) {\n      pauseAndEnd.set = new Set([\n        ...pauseAndEnd.set.values(),\n        ...pauseCharacters.set.values(),\n      ]);\n    }\n\n    if (endCharacters !== null) {\n      pauseAndEnd.set = new Set([\n        ...pauseAndEnd.set.values(),\n        ...endCharacters.set.values(),\n      ]);\n    }\n\n    let parsedString = \"\";\n    let ruleResultAtPause: ParseRuleReturn | null = null;\n\n    // Keep attempting to parse strings up to the pause (and end) points.\n    //  - At each of the pause points, attempt to parse according to the rule\n    //  - When the end point is reached (or EOF), we're done\n    do {\n      // TODO: Perhaps if no pause or end characters are passed, we should check *every* character for stopRule?\n      const partialParsedString: string | null =\n        this.ParseUntilCharactersFromCharSet(pauseAndEnd);\n\n      if (partialParsedString) {\n        parsedString += partialParsedString;\n      }\n\n      // Attempt to run the parse rule at this pause point\n      ruleResultAtPause = this.Peek(stopRule);\n\n      // Rule completed - we're done\n      if (ruleResultAtPause !== null) {\n        break;\n      } else {\n        if (this.endOfInput) {\n          break;\n        }\n\n        // Reached a pause point, but rule failed. Step past and continue parsing string\n        const pauseCharacter: string = this.currentCharacter;\n        if (\n          pauseCharacters !== null &&\n          pauseCharacters.set.has(pauseCharacter)\n        ) {\n          parsedString += pauseCharacter;\n          if (pauseCharacter === \"\\n\") {\n            this.lineIndex += 1;\n            this.characterInLineIndex = -1;\n          }\n\n          this.index += 1;\n          this.characterInLineIndex += 1;\n\n          continue;\n        } else {\n          break;\n        }\n      }\n    } while (true);\n\n    if (parsedString.length > 0) {\n      return this.SucceedRule(ruleId, String(parsedString)) as string;\n    }\n\n    return this.FailRule(ruleId) as string;\n  }\n\n  // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  public readonly ParseInt = (): number | null => {\n    const oldIndex: number = this.index;\n    const oldCharacterInLineIndex: number = this.characterInLineIndex;\n    const negative: boolean = this.ParseString(\"-\") !== null;\n\n    // Optional whitespace\n    this.ParseCharactersFromString(\" \\t\");\n\n    const parsedString = this.ParseCharactersFromCharSet(\n      StringParser.numbersCharacterSet\n    );\n    if (parsedString === null) {\n      // Roll back and fail\n      this.index = oldIndex;\n      this.characterInLineIndex = oldCharacterInLineIndex;\n\n      return null;\n    }\n\n    let parsedInt: number;\n    if (!Number.isNaN(Number(parsedString))) {\n      parsedInt = Number(parsedString);\n      return negative ? -parsedInt : parsedInt;\n    }\n\n    this.Error(\n      \"Failed to read integer value: \" +\n        parsedString +\n        \". Perhaps it's out of the range of acceptable numbers ink supports? (\" +\n        Number.MIN_SAFE_INTEGER +\n        \" to \" +\n        Number.MAX_SAFE_INTEGER +\n        \")\"\n    );\n\n    return null;\n  };\n\n  // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  public readonly ParseFloat = (): number | null => {\n    const oldIndex: number = this.index;\n    const oldCharacterInLineIndex: number = this.characterInLineIndex;\n\n    const leadingInt: number | null = this.ParseInt();\n    if (leadingInt !== null) {\n      if (this.ParseString(\".\") !== null) {\n        const afterDecimalPointStr = this.ParseCharactersFromCharSet(\n          StringParser.numbersCharacterSet\n        );\n\n        return Number(`${leadingInt}.${afterDecimalPointStr}`);\n      }\n    }\n\n    // Roll back and fail\n    this.index = oldIndex;\n    this.characterInLineIndex = oldCharacterInLineIndex;\n\n    return null;\n  };\n\n  public readonly ParseNewline = (): string => {\n    const ruleId: number = this.BeginRule();\n\n    // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n    // 2nd May 2016: Always collapse \\r\\n to just \\n\n    this.ParseString(\"\\r\");\n\n    if (this.ParseString(\"\\n\") === null) {\n      return this.FailRule(ruleId) as string;\n    }\n\n    return this.SucceedRule(ruleId, \"\\n\") as string;\n  };\n}\n","import { CharacterSet } from \"./CharacterSet\";\nimport { StringParser } from \"./StringParser/StringParser\";\n\n/// <summary>\n/// Pre-pass before main ink parser runs. It actually performs two main tasks:\n///  - comment elimination to simplify the parse rules in the main parser\n///  - Conversion of Windows line endings (\\r\\n) to the simpler Unix style (\\n), so\n///    we don't have to worry about them later.\n/// </summary>\nexport class CommentEliminator extends StringParser {\n  public _commentOrNewlineStartCharacter = new CharacterSet(\"/\\r\\n\");\n  public _commentBlockEndCharacter = new CharacterSet(\"*\");\n  public _newlineCharacters = new CharacterSet(\"\\n\\r\");\n\n  public readonly Process = (): string => {\n    // Make both comments and non-comments optional to handle trivial empty file case (or *only* comments)\n    const stringList: string[] = this.Interleave<string>(\n      this.Optional(this.CommentsAndNewlines),\n      this.Optional(this.MainInk)\n    );\n\n    if (stringList !== null) {\n      return stringList.join(\"\");\n    } else {\n      return \"\";\n    }\n  };\n\n  public readonly MainInk = () =>\n    this.ParseUntil(\n      this.CommentsAndNewlines,\n      this._commentOrNewlineStartCharacter,\n      null\n    );\n\n  public readonly CommentsAndNewlines = () => {\n    let newLines: string[] = this.Interleave<string>(\n      this.Optional(this.ParseNewline),\n      this.Optional(this.ParseSingleComment)\n    );\n\n    if (newLines !== null) {\n      return newLines.join(\"\");\n    }\n\n    return null;\n  };\n\n  // Valid comments always return either an empty string or pure newlines,\n  // which we want to keep so that line numbers stay the same\n  public readonly ParseSingleComment = () =>\n    this.OneOf([this.EndOfLineComment, this.BlockComment]);\n\n  public readonly EndOfLineComment = () => {\n    if (this.ParseString(\"//\") === null) {\n      return null;\n    }\n\n    this.ParseUntilCharactersFromCharSet(this._newlineCharacters);\n\n    return \"\";\n  };\n\n  public readonly BlockComment = () => {\n    if (this.ParseString(\"/*\") === null) {\n      return null;\n    }\n\n    const startLineIndex: number = this.lineIndex;\n    const commentResult = this.ParseUntil(\n      this.String(\"*/\"),\n      this._commentBlockEndCharacter,\n      null\n    );\n\n    if (!this.endOfInput) {\n      this.ParseString(\"*/\");\n    }\n\n    // Count the number of lines that were inside the block, and replicate them as newlines\n    // so that the line indexing still works from the original source\n    if (commentResult != null) {\n      return \"\\n\".repeat(this.lineIndex - startLineIndex);\n    }\n\n    // No comment at all\n    return null;\n  };\n\n  public PreProcessInputString(str: string): string {\n    return str;\n  }\n}\n","import { ConditionalSingleBranch } from \"./ConditionalSingleBranch\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\n\nexport class Conditional extends ParsedObject {\n  private _reJoinTarget: RuntimeControlCommand | null = null;\n\n  constructor(\n    public initialCondition: Expression,\n    public branches: ConditionalSingleBranch[]\n  ) {\n    super();\n\n    if (this.initialCondition) {\n      this.AddContent(this.initialCondition);\n    }\n\n    if (this.branches !== null) {\n      this.AddContent(this.branches);\n    }\n  }\n\n  get typeName(): string {\n    return \"Conditional\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Initial condition\n    if (this.initialCondition) {\n      container.AddContent(this.initialCondition.runtimeObject);\n    }\n\n    // Individual branches\n    for (const branch of this.branches) {\n      const branchContainer = branch.runtimeObject;\n      container.AddContent(branchContainer);\n    }\n\n    // If it's a switch-like conditional, each branch\n    // will have a \"duplicate\" operation for the original\n    // switched value. If there's no final else clause\n    // and we fall all the way through, we need to clean up.\n    // (An else clause doesn't dup but it *does* pop)\n    if (\n      this.initialCondition !== null &&\n      this.branches[0].ownExpression !== null &&\n      !this.branches[this.branches.length - 1].isElse\n    ) {\n      container.AddContent(RuntimeControlCommand.PopEvaluatedValue());\n    }\n\n    // Target for branches to rejoin to\n    this._reJoinTarget = RuntimeControlCommand.NoOp();\n    container.AddContent(this._reJoinTarget);\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    const pathToReJoin = this._reJoinTarget!.path;\n\n    for (const branch of this.branches) {\n      if (!branch.returnDivert) {\n        throw new Error();\n      }\n\n      branch.returnDivert.targetPath = pathToReJoin;\n    }\n\n    super.ResolveReferences(context);\n  }\n}\n","import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { StringValue } from \"../../../engine/Value\";\n\nexport class Text extends ParsedObject {\n  constructor(public text: string) {\n    super();\n  }\n  get typeName(): string {\n    return \"Text\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject =>\n    new StringValue(this.text);\n\n  public readonly toString = (): string => this.text;\n}\n","import { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ConstantDeclaration extends ParsedObject {\n  get constantName(): string | undefined {\n    return this.constantIdentifier?.name;\n  }\n  public constantIdentifier: Identifier;\n\n  private _expression: Expression | null = null;\n\n  get expression(): Expression {\n    if (!this._expression) {\n      throw new Error();\n    }\n\n    return this._expression;\n  }\n\n  constructor(name: Identifier, assignedExpression: Expression) {\n    super();\n\n    this.constantIdentifier = name;\n\n    // Defensive programming in case parsing of assignedExpression failed\n    if (assignedExpression) {\n      this._expression = this.AddContent(assignedExpression) as Expression;\n    }\n  }\n\n  get typeName(): string {\n    return \"CONST\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    // Global declarations don't generate actual procedural\n    // runtime objects, but instead add a global variable to the story itself.\n    // The story then initialises them all in one go at the start of the game.\n    return null;\n  };\n\n  public ResolveReferences(context: Story) {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(\n      this,\n      this.constantIdentifier,\n      SymbolType.Var\n    );\n  }\n}\n","export enum FlowLevel {\n  Story, // 0\n  Knot, // 1\n  Stitch, // 2\n  // not actually a FlowBase, but used for diverts\n  WeavePoint, // 3\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { INamedContent } from \"../../../../engine/INamedContent\";\nimport { IWeavePoint } from \"../IWeavePoint\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class Gather extends ParsedObject implements INamedContent, IWeavePoint {\n  get name(): string | null {\n    return this.identifier?.name || null;\n  }\n  public identifier?: Identifier;\n\n  get runtimeContainer(): RuntimeContainer {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  constructor(\n    identifier: Identifier | null,\n    public readonly indentationDepth: number\n  ) {\n    super();\n\n    if (identifier) this.identifier = identifier;\n  }\n\n  get typeName(): string {\n    return \"Gather\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    container.name = this.name;\n\n    if (this.story.countAllVisits) {\n      container.visitsShouldBeCounted = true;\n    }\n\n    container.countingAtStartOnly = true;\n\n    // A gather can have null content, e.g. it's just purely a line with \"-\"\n    if (this.content) {\n      for (const c of this.content) {\n        container.AddContent(c.runtimeObject);\n      }\n    }\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.identifier && (this.identifier.name || \"\").length > 0) {\n      context.CheckForNamingCollisions(\n        this,\n        this.identifier,\n        SymbolType.SubFlowAndWeave\n      );\n    }\n  }\n\n  public readonly toString = (): string =>\n    `- ${this.identifier?.name ? \"(\" + this.identifier?.name + \")\" : \"gather\"}`;\n}\n","import { asOrNull, filterUndef } from \"../../../engine/TypeAssertion\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\nimport { Weave } from \"./Weave\";\n\nexport class Path {\n  private _baseTargetLevel: FlowLevel | null;\n  private components: Identifier[] | null;\n\n  get baseTargetLevel() {\n    if (this.baseLevelIsAmbiguous) {\n      return FlowLevel.Story;\n    }\n\n    return this._baseTargetLevel;\n  }\n\n  get baseLevelIsAmbiguous(): boolean {\n    return !this._baseTargetLevel;\n  }\n\n  get firstComponent(): string | null {\n    if (this.components == null || !this.components.length) {\n      return null;\n    }\n\n    return this.components[0].name;\n  }\n\n  get numberOfComponents(): number {\n    return this.components ? this.components.length : 0;\n  }\n\n  private _dotSeparatedComponents: string | null = null;\n\n  get dotSeparatedComponents(): string {\n    if (this._dotSeparatedComponents == null) {\n      this._dotSeparatedComponents = (this.components ? this.components : [])\n        .map((c) => c.name)\n        .filter(filterUndef)\n        .join(\".\");\n    }\n    return this._dotSeparatedComponents;\n  }\n\n  constructor(\n    argOne: FlowLevel | Identifier[] | Identifier,\n    argTwo?: Identifier[]\n  ) {\n    if (Object.values(FlowLevel).includes(argOne as FlowLevel)) {\n      this._baseTargetLevel = argOne as FlowLevel;\n      this.components = argTwo || [];\n    } else if (Array.isArray(argOne)) {\n      this._baseTargetLevel = null;\n      this.components = argOne || [];\n    } else {\n      this._baseTargetLevel = null;\n      this.components = [argOne as Identifier];\n    }\n  }\n\n  get typeName(): string {\n    return \"Path\";\n  }\n\n  public readonly toString = (): string => {\n    if (this.components === null || this.components.length === 0) {\n      if (this.baseTargetLevel === FlowLevel.WeavePoint) {\n        return \"-> <next gather point>\";\n      }\n\n      return \"<invalid Path>\";\n    }\n\n    return `-> ${this.dotSeparatedComponents}`;\n  };\n\n  public readonly ResolveFromContext = (\n    context: ParsedObject\n  ): ParsedObject | null => {\n    if (this.components == null || this.components.length == 0) {\n      return null;\n    }\n\n    // Find base target of path from current context. e.g.\n    //   ==> BASE.sub.sub\n    let baseTargetObject = this.ResolveBaseTarget(context);\n    if (baseTargetObject === null) {\n      return null;\n    }\n\n    // Given base of path, resolve final target by working deeper into hierarchy\n    //  e.g. ==> base.mid.FINAL\n    if (this.components.length > 1) {\n      return this.ResolveTailComponents(baseTargetObject);\n    }\n\n    return baseTargetObject;\n  };\n\n  // Find the root object from the base, i.e. root from:\n  //    root.sub1.sub2\n  public readonly ResolveBaseTarget = (\n    originalContext: ParsedObject\n  ): ParsedObject | null => {\n    const firstComp = this.firstComponent;\n\n    // Work up the ancestry to find the node that has the named object\n    let ancestorContext: ParsedObject | null = originalContext;\n    while (ancestorContext) {\n      // Only allow deep search when searching deeper from original context.\n      // Don't allow search upward *then* downward, since that's searching *everywhere*!\n      // Allowed examples:\n      //  - From an inner gather of a stitch, you should search up to find a knot called 'x'\n      //    at the root of a story, but not a stitch called 'x' in that knot.\n      //  - However, from within a knot, you should be able to find a gather/choice\n      //    anywhere called 'x'\n      // (that latter example is quite loose, but we allow it)\n      const deepSearch: boolean = ancestorContext === originalContext;\n\n      const foundBase = this.GetChildFromContext(\n        ancestorContext,\n        firstComp,\n        null,\n        deepSearch\n      );\n\n      if (foundBase) {\n        return foundBase;\n      }\n\n      ancestorContext = ancestorContext.parent;\n    }\n\n    return null;\n  };\n\n  // Find the final child from path given root, i.e.:\n  //   root.sub.finalChild\n  public readonly ResolveTailComponents = (\n    rootTarget: ParsedObject\n  ): ParsedObject | null => {\n    let foundComponent: ParsedObject | null = rootTarget;\n\n    if (!this.components) return null;\n\n    for (let ii = 1; ii < this.components.length; ++ii) {\n      const compName = this.components[ii].name;\n\n      let minimumExpectedLevel: FlowLevel;\n      let foundFlow = asOrNull(foundComponent, FlowBase);\n      if (foundFlow !== null) {\n        minimumExpectedLevel = (foundFlow.flowLevel + 1) as FlowLevel;\n      } else {\n        minimumExpectedLevel = FlowLevel.WeavePoint;\n      }\n\n      foundComponent = this.GetChildFromContext(\n        foundComponent,\n        compName,\n        minimumExpectedLevel\n      );\n\n      if (foundComponent === null) {\n        break;\n      }\n    }\n\n    return foundComponent;\n  };\n\n  // See whether \"context\" contains a child with a given name at a given flow level\n  // Can either be a named knot/stitch (a FlowBase) or a weave point within a Weave (Choice or Gather)\n  // This function also ignores any other object types that are neither FlowBase nor Weave.\n  // Called from both ResolveBase (force deep) and ResolveTail for the individual components.\n  public readonly GetChildFromContext = (\n    context: ParsedObject,\n    childName: string | null,\n    minimumLevel: FlowLevel | null,\n    forceDeepSearch: boolean = false\n  ): ParsedObject | null => {\n    // null childLevel means that we don't know where to find it\n    const ambiguousChildLevel: boolean = minimumLevel === null;\n\n    // Search for WeavePoint within Weave\n    const weaveContext = asOrNull(context, Weave);\n    if (\n      childName &&\n      weaveContext !== null &&\n      (ambiguousChildLevel || minimumLevel === FlowLevel.WeavePoint)\n    ) {\n      return weaveContext.WeavePointNamed(childName) as ParsedObject;\n    }\n\n    // Search for content within Flow (either a sub-Flow or a WeavePoint)\n    let flowContext = asOrNull(context, FlowBase);\n    if (childName && flowContext !== null) {\n      // When searching within a Knot, allow a deep searches so that\n      // named weave points (choices and gathers) can be found within any stitch\n      // Otherwise, we just search within the immediate object.\n      const shouldDeepSearch =\n        forceDeepSearch || flowContext.flowLevel === FlowLevel.Knot;\n\n      return flowContext.ContentWithNameAtLevel(\n        childName,\n        minimumLevel,\n        shouldDeepSearch\n      );\n    }\n\n    return null;\n  };\n}\n","import { Expression } from \"./Expression/Expression\";\nimport { ParsedObject } from \"./Object\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Void } from \"../../../engine/Void\";\n\nexport class ReturnType extends ParsedObject {\n  public returnedExpression: Expression | null = null;\n\n  constructor(returnedExpression: Expression | null = null) {\n    super();\n\n    if (returnedExpression) {\n      this.returnedExpression = this.AddContent(\n        returnedExpression\n      ) as Expression;\n    }\n  }\n\n  get typeName(): string {\n    return \"ReturnType\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    if (this.returnedExpression) {\n      // Evaluate expression\n      container.AddContent(this.returnedExpression.runtimeObject);\n    } else {\n      // Return Runtime.Void when there's no expression to evaluate\n      // (This evaluation will just add the Void object to the evaluation stack)\n      container.AddContent(RuntimeControlCommand.EvalStart());\n      container.AddContent(new Void());\n      container.AddContent(RuntimeControlCommand.EvalEnd());\n    }\n\n    // Then pop the call stack\n    // (the evaluated expression will leave the return value on the evaluation stack)\n    container.AddContent(RuntimeControlCommand.PopFunction());\n\n    return container;\n  };\n}\n","// import { FlowBase } from './FlowBase';\n\nexport function ClosestFlowBase(obj: any): any | null {\n  let ancestor = obj.parent;\n  while (ancestor) {\n    if (ancestor.hasOwnProperty(\"iamFlowbase\") && ancestor.iamFlowbase()) {\n      return ancestor as any;\n    }\n\n    ancestor = ancestor.parent;\n  }\n\n  return null;\n}\n","import { DebugMetadata } from \"../../../engine/DebugMetadata\";\n\nexport class Identifier {\n  public name: string;\n  public debugMetadata: DebugMetadata | null = null;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  get typeName(): string {\n    return \"Identifier\";\n  }\n\n  public static Done(): Identifier {\n    return new Identifier(\"DONE\");\n  }\n\n  public readonly toString = (): string => this.name || \"undefined identifer\";\n}\n","import { Argument } from \"../Argument\";\nimport { Choice } from \"../Choice\";\nimport { Divert } from \"../Divert/Divert\";\nimport { DivertTarget } from \"../Divert/DivertTarget\";\nimport { FlowLevel } from \"./FlowLevel\";\nimport { Gather } from \"../Gather/Gather\";\nimport { INamedContent } from \"../../../../engine/INamedContent\";\n// import { Knot } from '../Knot';\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { ReturnType } from \"../ReturnType\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\n//import { Story } from '../Story';\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment } from \"../Variable/VariableAssignment\";\nimport { Weave } from \"../Weave\";\nimport { ClosestFlowBase } from \"./ClosestFlowBase\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\ntype VariableResolveResult = {\n  found: boolean;\n  isGlobal: boolean;\n  isArgument: boolean;\n  isTemporary: boolean;\n  ownerFlow: FlowBase;\n};\n\n// Base class for Knots and Stitches\nexport abstract class FlowBase extends ParsedObject implements INamedContent {\n  public abstract readonly flowLevel: FlowLevel;\n\n  public _rootWeave: Weave | null = null;\n  public _subFlowsByName: Map<string, FlowBase> = new Map();\n  public _startingSubFlowDivert: RuntimeDivert | null = null;\n  public _startingSubFlowRuntime: RuntimeObject | null = null;\n  public _firstChildFlow: FlowBase | null = null;\n  public variableDeclarations: Map<string, VariableAssignment> = new Map();\n\n  get hasParameters() {\n    return this.args !== null && this.args.length > 0;\n  }\n\n  get subFlowsByName() {\n    return this._subFlowsByName;\n  }\n\n  get typeName(): string {\n    if (this.isFunction) {\n      return \"Function\";\n    }\n\n    return String(this.flowLevel);\n  }\n\n  get name(): string | null {\n    return this.identifier?.name || null;\n  }\n\n  public identifier: Identifier | null = null;\n  public args: Argument[] | null = null;\n\n  constructor(\n    identifier: Identifier | null,\n    topLevelObjects: ParsedObject[] | null = null,\n    args: Argument[] | null = null,\n    public readonly isFunction: boolean = false,\n    isIncludedStory: boolean = false\n  ) {\n    super();\n\n    this.identifier = identifier;\n    this.args = args;\n\n    if (topLevelObjects === null) {\n      topLevelObjects = [];\n    }\n\n    // Used by story to add includes\n    this.PreProcessTopLevelObjects(topLevelObjects);\n\n    topLevelObjects = this.SplitWeaveAndSubFlowContent(\n      topLevelObjects,\n      this.GetType() == \"Story\" && !isIncludedStory\n    );\n\n    this.AddContent(topLevelObjects);\n  }\n\n  public iamFlowbase = () => true;\n\n  public readonly SplitWeaveAndSubFlowContent = (\n    contentObjs: ParsedObject[],\n    isRootStory: boolean\n  ): ParsedObject[] => {\n    const weaveObjs: ParsedObject[] = [];\n    const subFlowObjs: ParsedObject[] = [];\n\n    this._subFlowsByName = new Map();\n\n    for (const obj of contentObjs) {\n      const subFlow = asOrNull(obj, FlowBase);\n      if (subFlow) {\n        if (this._firstChildFlow === null) {\n          this._firstChildFlow = subFlow;\n        }\n\n        subFlowObjs.push(obj);\n        if (subFlow.identifier?.name) {\n          this._subFlowsByName.set(subFlow.identifier?.name, subFlow);\n        }\n      } else {\n        weaveObjs.push(obj);\n      }\n    }\n\n    // Implicit final gather in top level story for ending without warning that you run out of content\n    if (isRootStory) {\n      weaveObjs.push(\n        new Gather(null, 1),\n        new Divert(new Path(Identifier.Done()))\n      );\n    }\n\n    const finalContent: ParsedObject[] = [];\n\n    if (weaveObjs.length > 0) {\n      this._rootWeave = new Weave(weaveObjs, 0);\n      finalContent.push(this._rootWeave);\n    }\n\n    if (subFlowObjs.length > 0) {\n      finalContent.push(...subFlowObjs);\n    }\n    return finalContent;\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public PreProcessTopLevelObjects(_: ParsedObject[]): void {\n    // empty by default, used by Story to process included file references\n  }\n\n  public VariableResolveResult?: VariableResolveResult | null | undefined;\n\n  public ResolveVariableWithName = (\n    varName: string,\n    fromNode: ParsedObject\n  ): VariableResolveResult => {\n    const result: VariableResolveResult = {} as any;\n\n    // Search in the stitch / knot that owns the node first\n    const ownerFlow = fromNode === null ? this : ClosestFlowBase(fromNode);\n\n    if (ownerFlow) {\n      // Argument\n      if (ownerFlow.args !== null) {\n        for (const arg of ownerFlow.args) {\n          if (arg.identifier?.name === varName) {\n            result.found = true;\n            result.isArgument = true;\n            result.ownerFlow = ownerFlow;\n            return result;\n          }\n        }\n      }\n\n      // Temp\n      if (\n        ownerFlow !== this.story &&\n        ownerFlow.variableDeclarations.has(varName)\n      ) {\n        result.found = true;\n        result.ownerFlow = ownerFlow;\n        result.isTemporary = true;\n\n        return result;\n      }\n    }\n\n    // Global\n    if (this.story.variableDeclarations.has(varName)) {\n      result.found = true;\n      result.ownerFlow = this.story;\n      result.isGlobal = true;\n\n      return result;\n    }\n\n    result.found = false;\n\n    return result;\n  };\n\n  public AddNewVariableDeclaration = (varDecl: VariableAssignment): void => {\n    const varName = varDecl.variableName;\n    if (this.variableDeclarations.has(varName)) {\n      const varab = this.variableDeclarations.get(varName)!;\n      let prevDeclError = \"\";\n      const debugMetadata = varab.debugMetadata;\n      if (debugMetadata) {\n        prevDeclError = ` (${varab.debugMetadata})`;\n      }\n\n      this.Error(\n        `found declaration variable '${varName}' that was already declared${prevDeclError}`,\n        varDecl,\n        false\n      );\n\n      return;\n    }\n\n    this.variableDeclarations.set(varDecl.variableName, varDecl);\n  };\n\n  public ResolveWeavePointNaming = (): void => {\n    // Find all weave points and organise them by name ready for\n    // diverting. Also detect naming collisions.\n    if (this._rootWeave) {\n      this._rootWeave.ResolveWeavePointNaming();\n    }\n\n    for (const [, value] of this._subFlowsByName) {\n      if (value.hasOwnProperty(\"ResolveWeavePointNaming\")) {\n        value.ResolveWeavePointNaming();\n      }\n    }\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    let foundReturn: ReturnType | null = null;\n    if (this.isFunction) {\n      this.CheckForDisallowedFunctionFlowControl();\n    } else if (\n      this.flowLevel === FlowLevel.Knot ||\n      this.flowLevel === FlowLevel.Stitch\n    ) {\n      // Non-functon: Make sure knots and stitches don't attempt to use Return statement\n      foundReturn = this.Find(ReturnType)();\n\n      if (foundReturn !== null) {\n        this.Error(\n          `Return statements can only be used in knots that are declared as functions: == function ${this.identifier} ==`,\n          foundReturn\n        );\n      }\n    }\n\n    const container = new RuntimeContainer();\n    container.name = this.identifier?.name as string;\n\n    if (this.story.countAllVisits) {\n      container.visitsShouldBeCounted = true;\n    }\n\n    this.GenerateArgumentVariableAssignments(container);\n\n    // Run through content defined for this knot/stitch:\n    //  - First of all, any initial content before a sub-stitch\n    //    or any weave content is added to the main content container\n    //  - The first inner knot/stitch is automatically entered, while\n    //    the others are only accessible by an explicit divert\n    //       - The exception to this rule is if the knot/stitch takes\n    //         parameters, in which case it can't be auto-entered.\n    //  - Any Choices and Gathers (i.e. IWeavePoint) found are\n    //    processsed by GenerateFlowContent.\n    let contentIdx: number = 0;\n    while (this.content !== null && contentIdx < this.content.length) {\n      const obj: ParsedObject = this.content[contentIdx];\n\n      // Inner knots and stitches\n      if (obj instanceof FlowBase) {\n        const childFlow: FlowBase = obj;\n        const childFlowRuntime = childFlow.runtimeObject;\n\n        // First inner stitch - automatically step into it\n        // 20/09/2016 - let's not auto step into knots\n        if (\n          contentIdx === 0 &&\n          !childFlow.hasParameters &&\n          this.flowLevel === FlowLevel.Knot\n        ) {\n          this._startingSubFlowDivert = new RuntimeDivert();\n          container.AddContent(this._startingSubFlowDivert);\n          this._startingSubFlowRuntime = childFlowRuntime;\n        }\n\n        // Check for duplicate knots/stitches with same name\n        const namedChild = childFlowRuntime as RuntimeObject & INamedContent;\n        const existingChild: INamedContent | null =\n          container.namedContent.get(namedChild.name!) || null;\n\n        if (existingChild) {\n          const errorMsg = `${this.GetType()} already contains flow named '${\n            namedChild.name\n          }' (at ${(existingChild as any as RuntimeObject).debugMetadata})`;\n          this.Error(errorMsg, childFlow);\n        }\n\n        container.AddToNamedContentOnly(namedChild);\n      } else if (obj) {\n        // Other content (including entire Weaves that were grouped in the constructor)\n        // At the time of writing, all FlowBases have a maximum of one piece of \"other content\"\n        // and it's always the root Weave\n        container.AddContent(obj.runtimeObject);\n      }\n\n      contentIdx += 1;\n    }\n\n    // CHECK FOR FINAL LOOSE ENDS!\n    // Notes:\n    //  - Functions don't need to terminate - they just implicitly return\n    //  - If return statement was found, don't continue finding warnings for missing control flow,\n    // since it's likely that a return statement has been used instead of a ->-> or something,\n    // or the writer failed to mark the knot as a function.\n    //  - _rootWeave may be null if it's a knot that only has stitches\n    if (\n      this.flowLevel !== FlowLevel.Story &&\n      !this.isFunction &&\n      this._rootWeave !== null &&\n      foundReturn === null\n    ) {\n      this._rootWeave.ValidateTermination(this.WarningInTermination);\n    }\n\n    return container;\n  };\n\n  public readonly GenerateArgumentVariableAssignments = (\n    container: RuntimeContainer\n  ): void => {\n    if (this.args === null || this.args.length === 0) {\n      return;\n    }\n\n    // Assign parameters in reverse since they'll be popped off the evaluation stack\n    // No need to generate EvalStart and EvalEnd since there's nothing being pushed\n    // back onto the evaluation stack.\n    for (let ii = this.args.length - 1; ii >= 0; --ii) {\n      const paramName = this.args[ii].identifier?.name || null;\n      const assign = new RuntimeVariableAssignment(paramName, true);\n      container.AddContent(assign);\n    }\n  };\n\n  public readonly ContentWithNameAtLevel = (\n    name: string,\n    level: FlowLevel | null = null,\n    deepSearch: boolean = false\n  ): ParsedObject | null => {\n    // Referencing self?\n    if (level === this.flowLevel || level === null) {\n      if (name === this.identifier?.name) {\n        return this;\n      }\n    }\n\n    if (level === FlowLevel.WeavePoint || level === null) {\n      let weavePointResult: ParsedObject | null = null;\n\n      if (this._rootWeave) {\n        weavePointResult = this._rootWeave.WeavePointNamed(\n          name\n        ) as ParsedObject;\n        if (weavePointResult) {\n          return weavePointResult;\n        }\n      }\n\n      // Stop now if we only wanted a result if it's a weave point?\n      if (level === FlowLevel.WeavePoint) {\n        return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n      }\n    }\n\n    // If this flow would be incapable of containing the requested level, early out\n    // (e.g. asking for a Knot from a Stitch)\n    if (level !== null && level < this.flowLevel) {\n      return null;\n    }\n\n    let subFlow: FlowBase | null = this._subFlowsByName.get(name) || null;\n\n    if (subFlow && (level === null || level === subFlow.flowLevel)) {\n      return subFlow;\n    }\n\n    return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n  };\n\n  public readonly DeepSearchForAnyLevelContent = (name: string) => {\n    const weaveResultSelf = this.ContentWithNameAtLevel(\n      name,\n      FlowLevel.WeavePoint,\n      false\n    );\n\n    if (weaveResultSelf) {\n      return weaveResultSelf;\n    }\n\n    for (const [, value] of this._subFlowsByName) {\n      const deepResult = value.ContentWithNameAtLevel(name, null, true);\n\n      if (deepResult) {\n        return deepResult;\n      }\n    }\n\n    return null;\n  };\n\n  public ResolveReferences(context: any): void {\n    if (this._startingSubFlowDivert) {\n      if (!this._startingSubFlowRuntime) {\n        throw new Error();\n      }\n\n      this._startingSubFlowDivert.targetPath =\n        this._startingSubFlowRuntime.path;\n    }\n\n    super.ResolveReferences(context);\n\n    // Check validity of parameter names\n    if (this.args !== null) {\n      for (const arg of this.args) {\n        context.CheckForNamingCollisions(\n          this,\n          arg.identifier,\n          SymbolType.Arg,\n          \"argument\"\n        );\n      }\n\n      // Separately, check for duplicate arugment names, since they aren't Parsed.Objects,\n      // so have to be checked independently.\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        for (let jj = ii + 1; jj < this.args.length; jj += 1) {\n          if (\n            this.args[ii].identifier?.name == this.args[jj].identifier?.name\n          ) {\n            this.Error(\n              `Multiple arguments with the same name: '${this.args[ii].identifier}'`\n            );\n          }\n        }\n      }\n    }\n\n    // Check naming collisions for knots and stitches\n    if (this.flowLevel !== FlowLevel.Story) {\n      // Weave points aren't FlowBases, so this will only be knot or stitch\n      const symbolType =\n        this.flowLevel === FlowLevel.Knot\n          ? SymbolType.Knot\n          : SymbolType.SubFlowAndWeave;\n\n      context.CheckForNamingCollisions(this, this.identifier, symbolType);\n    }\n  }\n\n  public readonly CheckForDisallowedFunctionFlowControl = (): void => {\n    // if (!(this instanceof Knot)) { // cannont use Knot here because of circular dependancy\n    if (this.flowLevel !== FlowLevel.Knot) {\n      this.Error(\n        \"Functions cannot be stitches - i.e. they should be defined as '== function myFunc ==' rather than internal to another knot.\"\n      );\n    }\n\n    // Not allowed sub-flows\n    for (const [key, value] of this._subFlowsByName) {\n      this.Error(\n        `Functions may not contain stitches, but saw '${key}' within the function '${this.identifier}'`,\n        value\n      );\n    }\n\n    if (!this._rootWeave) {\n      throw new Error();\n    }\n\n    const allDiverts = this._rootWeave.FindAll<Divert>(Divert)();\n    for (const divert of allDiverts) {\n      if (!divert.isFunctionCall && !(divert.parent instanceof DivertTarget)) {\n        this.Error(\n          `Functions may not contain diverts, but saw '${divert}'`,\n          divert\n        );\n      }\n    }\n\n    const allChoices = this._rootWeave.FindAll<Choice>(Choice)();\n    for (const choice of allChoices) {\n      this.Error(\n        `Functions may not contain choices, but saw '${choice}'`,\n        choice\n      );\n    }\n  };\n\n  public readonly WarningInTermination = (terminatingObject: ParsedObject) => {\n    let message: string =\n      \"Apparent loose end exists where the flow runs out. Do you need a '-> DONE' statement, choice or divert?\";\n    if (terminatingObject.parent === this._rootWeave && this._firstChildFlow) {\n      message = `${message} Note that if you intend to enter '${this._firstChildFlow.identifier}' next, you need to divert to it explicitly.`;\n    }\n\n    const terminatingDivert = asOrNull(terminatingObject, Divert);\n    if (terminatingDivert && terminatingDivert.isTunnel) {\n      message += ` When final tunnel to '${terminatingDivert.target} ->' returns it won't have anywhere to go.`;\n    }\n\n    this.Warning(message, terminatingObject);\n  };\n\n  public readonly toString = (): string =>\n    `${this.typeName} '${this.identifier}'`;\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Text } from \"./Text\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport class ContentList extends ParsedObject {\n  public dontFlatten: boolean = false;\n\n  get runtimeContainer(): RuntimeContainer {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  constructor(objects?: ParsedObject[], ...moreObjects: ParsedObject[]) {\n    super();\n\n    if (objects) {\n      this.AddContent(objects);\n    }\n\n    if (moreObjects) {\n      this.AddContent(moreObjects);\n    }\n  }\n\n  get typeName(): string {\n    return \"ContentList\";\n  }\n\n  public readonly TrimTrailingWhitespace = (): void => {\n    for (let ii = this.content.length - 1; ii >= 0; --ii) {\n      const text = asOrNull(this.content[ii], Text);\n      if (text === null) {\n        break;\n      }\n\n      text.text = text.text.replace(new RegExp(/[ \\t]/g), \"\");\n      if (text.text.length === 0) {\n        this.content.splice(ii, 1);\n      } else {\n        break;\n      }\n    }\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    if (this.content !== null) {\n      for (const obj of this.content) {\n        const contentObjRuntime = obj.runtimeObject;\n\n        // Some objects (e.g. author warnings) don't generate runtime objects\n        if (contentObjRuntime) {\n          container.AddContent(contentObjRuntime);\n        }\n      }\n    }\n\n    if (this.dontFlatten) {\n      this.story.DontFlattenContainer(container);\n    }\n\n    return container;\n  };\n\n  public toString = (): string => `ContentList(${this.content.join(\", \")})`;\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ContentList } from \"../ContentList\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { Story } from \"../Story\";\nimport { VariableReference as RuntimeVariableReference } from \"../../../../engine/VariableReference\";\nimport { Weave } from \"../Weave\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull, filterUndef } from \"../../../../engine/TypeAssertion\";\n\nexport class VariableReference extends Expression {\n  private _runtimeVarRef: RuntimeVariableReference | null = null;\n\n  // - Normal variables have a single item in their \"path\"\n  // - Knot/stitch names for read counts are actual dot-separated paths\n  //   (though this isn't actually used at time of writing)\n  // - List names are dot separated: listName.itemName (or just itemName)\n  get name() {\n    return this.path.join(\".\");\n  }\n\n  get path(): string[] {\n    return this.pathIdentifiers.map((id) => id.name!).filter(filterUndef);\n  }\n\n  get identifier(): Identifier | null {\n    if (!this.pathIdentifiers || this.pathIdentifiers.length == 0) {\n      return null;\n    }\n    const name = this.path.join(\".\");\n    const id = new Identifier(name);\n\n    return id;\n  }\n\n  // Only known after GenerateIntoContainer has run\n  public isConstantReference: boolean = false;\n  public isListItemReference: boolean = false;\n\n  get runtimeVarRef() {\n    return this._runtimeVarRef;\n  }\n\n  constructor(public readonly pathIdentifiers: Identifier[]) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"ref\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    let constantValue: Expression | null | undefined = this.story.constants.get(\n      this.name\n    );\n\n    // If it's a constant reference, just generate the literal expression value\n    // It's okay to access the constants at code generation time, since the\n    // first thing the ExportRuntime function does it search for all the constants\n    // in the story hierarchy, so they're all available.\n    if (constantValue) {\n      constantValue.GenerateConstantIntoContainer(container);\n      this.isConstantReference = true;\n\n      return;\n    }\n\n    this._runtimeVarRef = new RuntimeVariableReference(this.name);\n\n    // List item reference?\n    // Path might be to a list (listName.listItemName or just listItemName)\n    if (this.path.length === 1 || this.path.length === 2) {\n      let listItemName: string = \"\";\n      let listName: string = \"\";\n\n      if (this.path.length === 1) {\n        listItemName = this.path[0];\n      } else {\n        listName = this.path[0];\n        listItemName = this.path[1];\n      }\n\n      const listItem = this.story.ResolveListItem(listName, listItemName, this);\n\n      if (listItem) {\n        this.isListItemReference = true;\n      }\n    }\n\n    container.AddContent(this._runtimeVarRef);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Work is already done if it's a constant or list item reference\n    if (this.isConstantReference || this.isListItemReference) {\n      return;\n    }\n\n    // Is it a read count?\n    const parsedPath = new Path(this.pathIdentifiers);\n    const targetForCount: ParsedObject | null =\n      parsedPath.ResolveFromContext(this);\n    if (targetForCount) {\n      if (!targetForCount.containerForCounting) {\n        throw new Error();\n      }\n\n      targetForCount.containerForCounting.visitsShouldBeCounted = true;\n\n      // If this is an argument to a function that wants a variable to be\n      // passed by reference, then the Parsed.Divert will have generated a\n      // Runtime.VariablePointerValue instead of allowing this object\n      // to generate its RuntimeVariableReference. This only happens under\n      // error condition since we shouldn't be passing a read count by\n      // reference, but we don't want it to crash!\n      if (this._runtimeVarRef === null) {\n        return;\n      }\n\n      this._runtimeVarRef.pathForCount = targetForCount.runtimePath;\n      this._runtimeVarRef.name = null;\n\n      // Check for very specific writer error: getting read count and\n      // printing it as content rather than as a piece of logic\n      // e.g. Writing {myFunc} instead of {myFunc()}\n      let targetFlow = asOrNull(targetForCount, FlowBase);\n      if (targetFlow && targetFlow.isFunction) {\n        // Is parent context content rather than logic?\n        if (\n          this.parent instanceof Weave ||\n          this.parent instanceof ContentList ||\n          this.parent instanceof FlowBase\n        ) {\n          this.Warning(\n            `'${targetFlow.identifier}' being used as read count rather than being called as function. Perhaps you intended to write ${targetFlow.identifier}()`\n          );\n        }\n      }\n\n      return;\n    }\n\n    // Couldn't find this multi-part path at all, whether as a divert\n    // target or as a list item reference.\n    if (this.path.length > 1) {\n      let errorMsg = `Could not find target for read count: ${parsedPath}`;\n      if (this.path.length <= 2) {\n        errorMsg += `, or couldn't find list item with the name ${this.path.join(\n          \",\"\n        )}`;\n      }\n\n      this.Error(errorMsg);\n\n      return;\n    }\n\n    if (!context.ResolveVariableWithName(this.name, this).found) {\n      this.Error(`Unresolved variable: ${this.name}`, this);\n    }\n  }\n\n  public readonly toString = (): string => `{${this.path.join(\".\")}}`;\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTarget } from \"./Divert/DivertTarget\";\nimport { Expression } from \"./Expression/Expression\";\nimport { InkList as RuntimeInkList } from \"../../../engine/InkList\";\nimport { ListValue } from \"../../../engine/Value\";\nimport { NativeFunctionCall } from \"../../../engine/NativeFunctionCall\";\nimport { NumberExpression } from \"./Expression/NumberExpression\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { StringValue } from \"../../../engine/Value\";\nimport { VariableReference } from \"./Variable/VariableReference\";\nimport { Identifier } from \"./Identifier\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport class FunctionCall extends Expression {\n  public static readonly IsBuiltIn = (name: string): boolean => {\n    if (NativeFunctionCall.CallExistsWithName(name)) {\n      return true;\n    }\n\n    return (\n      name === \"CHOICE_COUNT\" ||\n      name === \"TURNS_SINCE\" ||\n      name === \"TURNS\" ||\n      name === \"RANDOM\" ||\n      name === \"SEED_RANDOM\" ||\n      name === \"LIST_VALUE\" ||\n      name === \"LIST_RANDOM\" ||\n      name === \"READ_COUNT\"\n    );\n  };\n\n  private _proxyDivert: Divert;\n  get proxyDivert(): Divert {\n    return this._proxyDivert;\n  }\n  private _divertTargetToCount: DivertTarget | null = null;\n  private _variableReferenceToCount: VariableReference | null = null;\n\n  get name(): string {\n    return (this._proxyDivert.target as Path).firstComponent || \"\";\n  }\n\n  get args(): Expression[] {\n    return this._proxyDivert.args;\n  }\n\n  get runtimeDivert(): RuntimeDivert {\n    return this._proxyDivert.runtimeDivert;\n  }\n\n  get isChoiceCount(): boolean {\n    return this.name === \"CHOICE_COUNT\";\n  }\n\n  get isTurns(): boolean {\n    return this.name === \"TURNS\";\n  }\n\n  get isTurnsSince(): boolean {\n    return this.name === \"TURNS_SINCE\";\n  }\n\n  get isRandom(): boolean {\n    return this.name === \"RANDOM\";\n  }\n\n  get isSeedRandom(): boolean {\n    return this.name === \"SEED_RANDOM\";\n  }\n\n  get isListRange(): boolean {\n    return this.name === \"LIST_RANGE\";\n  }\n\n  get isListRandom(): boolean {\n    return this.name === \"LIST_RANDOM\";\n  }\n\n  get isReadCount(): boolean {\n    return this.name === \"READ_COUNT\";\n  }\n\n  public shouldPopReturnedValue: boolean = false;\n\n  constructor(functionName: Identifier, args: Expression[]) {\n    super();\n\n    this._proxyDivert = new Divert(new Path(functionName), args);\n    this._proxyDivert.isFunctionCall = true;\n    this.AddContent(this._proxyDivert);\n  }\n\n  get typeName(): string {\n    return \"FunctionCall\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    const foundList = this.story.ResolveList(this.name);\n\n    let usingProxyDivert: boolean = false;\n\n    if (this.isChoiceCount) {\n      if (this.args.length > 0) {\n        this.Error(\"The CHOICE_COUNT() function shouldn't take any arguments\");\n      }\n\n      container.AddContent(RuntimeControlCommand.ChoiceCount());\n    } else if (this.isTurns) {\n      if (this.args.length > 0) {\n        this.Error(\"The TURNS() function shouldn't take any arguments\");\n      }\n\n      container.AddContent(RuntimeControlCommand.Turns());\n    } else if (this.isTurnsSince || this.isReadCount) {\n      const divertTarget = asOrNull(this.args[0], DivertTarget);\n      const variableDivertTarget = asOrNull(this.args[0], VariableReference);\n\n      if (\n        this.args.length !== 1 ||\n        (divertTarget === null && variableDivertTarget === null)\n      ) {\n        this.Error(\n          `The ${this.name}() function should take one argument: a divert target to the target knot, stitch, gather or choice you want to check. e.g. TURNS_SINCE(-> myKnot)`\n        );\n        return;\n      }\n\n      if (divertTarget) {\n        this._divertTargetToCount = divertTarget;\n        this.AddContent(this._divertTargetToCount);\n\n        this._divertTargetToCount.GenerateIntoContainer(container);\n      } else if (variableDivertTarget) {\n        this._variableReferenceToCount = variableDivertTarget;\n        this.AddContent(this._variableReferenceToCount);\n\n        this._variableReferenceToCount.GenerateIntoContainer(container);\n      }\n\n      if (this.isTurnsSince) {\n        container.AddContent(RuntimeControlCommand.TurnsSince());\n      } else {\n        container.AddContent(RuntimeControlCommand.ReadCount());\n      }\n    } else if (this.isRandom) {\n      if (this.args.length !== 2) {\n        this.Error(\n          \"RANDOM should take 2 parameters: a minimum and a maximum integer\"\n        );\n      }\n\n      // We can type check single values, but not complex expressions\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        const num = asOrNull(this.args[ii], NumberExpression);\n        if (num && !num.isInt()) {\n          const paramName: string = ii === 0 ? \"minimum\" : \"maximum\";\n          this.Error(`RANDOM's ${paramName} parameter should be an integer`);\n        }\n\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(RuntimeControlCommand.Random());\n    } else if (this.isSeedRandom) {\n      if (this.args.length !== 1) {\n        this.Error(\"SEED_RANDOM should take 1 parameter - an integer seed\");\n      }\n\n      const num = asOrNull(this.args[0], NumberExpression);\n      if (num && !num.isInt()) {\n        this.Error(\"SEED_RANDOM's parameter should be an integer seed\");\n      }\n\n      this.args[0].GenerateIntoContainer(container);\n\n      container.AddContent(RuntimeControlCommand.SeedRandom());\n    } else if (this.isListRange) {\n      if (this.args.length !== 3) {\n        this.Error(\n          \"LIST_RANGE should take 3 parameters - a list, a min and a max\"\n        );\n      }\n\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(RuntimeControlCommand.ListRange());\n    } else if (this.isListRandom) {\n      if (this.args.length !== 1) {\n        this.Error(\"LIST_RANDOM should take 1 parameter - a list\");\n      }\n\n      this.args[0].GenerateIntoContainer(container);\n\n      container.AddContent(RuntimeControlCommand.ListRandom());\n    } else if (NativeFunctionCall.CallExistsWithName(this.name)) {\n      const nativeCall = NativeFunctionCall.CallWithName(this.name);\n      if (nativeCall.numberOfParameters !== this.args.length) {\n        let msg = `${FunctionCall.name} should take ${nativeCall.numberOfParameters} parameter`;\n        if (nativeCall.numberOfParameters > 1) {\n          msg += \"s\";\n        }\n\n        this.Error(msg);\n      }\n\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(NativeFunctionCall.CallWithName(this.name));\n    } else if (foundList !== null) {\n      if (this.args.length > 1) {\n        this.Error(\n          \"Can currently only construct a list from one integer (or an empty list from a given list definition)\"\n        );\n      }\n\n      // List item from given int\n      if (this.args.length === 1) {\n        container.AddContent(new StringValue(this.name));\n        this.args[0].GenerateIntoContainer(container);\n        container.AddContent(RuntimeControlCommand.ListFromInt());\n      } else {\n        // Empty list with given origin.\n        const list = new RuntimeInkList();\n        list.SetInitialOriginName(this.name);\n        container.AddContent(new ListValue(list));\n      }\n    } else {\n      // Normal function call\n      container.AddContent(this._proxyDivert.runtimeObject);\n      usingProxyDivert = true;\n    }\n\n    // Don't attempt to resolve as a divert if we're not doing a normal function call\n    if (!usingProxyDivert) {\n      this.content.splice(this.content.indexOf(this._proxyDivert), 1);\n    }\n\n    // Function calls that are used alone on a tilda-based line:\n    //  ~ func()\n    // Should tidy up any returned value from the evaluation stack,\n    // since it's unused.\n    if (this.shouldPopReturnedValue) {\n      container.AddContent(RuntimeControlCommand.PopEvaluatedValue());\n    }\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // If we aren't using the proxy divert after all (e.g. if\n    // it's a native function call), but we still have arguments,\n    // we need to make sure they get resolved since the proxy divert\n    // is no longer in the content array.\n    if (!this.content.includes(this._proxyDivert) && this.args !== null) {\n      for (const arg of this.args) {\n        arg.ResolveReferences(context);\n      }\n    }\n\n    if (this._divertTargetToCount) {\n      const divert = this._divertTargetToCount.divert;\n      const attemptingTurnCountOfVariableTarget =\n        divert.runtimeDivert.variableDivertName != null;\n\n      if (attemptingTurnCountOfVariableTarget) {\n        this.Error(\n          `When getting the TURNS_SINCE() of a variable target, remove the '->' - i.e. it should just be TURNS_SINCE(${divert.runtimeDivert.variableDivertName})`\n        );\n\n        return;\n      }\n\n      const targetObject = divert.targetContent;\n      if (targetObject === null) {\n        if (!attemptingTurnCountOfVariableTarget) {\n          this.Error(\n            `Failed to find target for TURNS_SINCE: '${divert.target}'`\n          );\n        }\n      } else {\n        if (!targetObject.containerForCounting) {\n          throw new Error();\n        }\n\n        targetObject.containerForCounting.turnIndexShouldBeCounted = true;\n      }\n    } else if (this._variableReferenceToCount) {\n      const runtimeVarRef = this._variableReferenceToCount.runtimeVarRef;\n      if (!runtimeVarRef) {\n        throw new Error();\n      }\n\n      if (runtimeVarRef.pathForCount !== null) {\n        this.Error(\n          `Should be '${FunctionCall.name}'(-> '${this._variableReferenceToCount.name}). Usage without the '->' only makes sense for variable targets.`\n        );\n      }\n    }\n  }\n\n  public readonly toString = (): string => {\n    const strArgs = this.args.join(\", \");\n    return `${this.name}(${strArgs})`;\n  };\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\n\nexport class MultipleConditionExpression extends Expression {\n  get subExpressions(): Expression[] {\n    return this.content as Expression[];\n  }\n\n  constructor(conditionExpressions: Expression[]) {\n    super();\n\n    this.AddContent(conditionExpressions);\n  }\n\n  get typeName(): string {\n    return \"MultipleConditionExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    //    A && B && C && D\n    // => (((A B &&) C &&) D &&) etc\n    let isFirst: boolean = true;\n    for (const conditionExpr of this.subExpressions) {\n      conditionExpr.GenerateIntoContainer(container);\n\n      if (!isFirst) {\n        container.AddContent(NativeFunctionCall.CallWithName(\"&&\"));\n      }\n\n      isFirst = false;\n    }\n  };\n}\n","import { BinaryExpression } from \"../Expression/BinaryExpression\";\nimport { Choice } from \"../Choice\";\nimport { Conditional } from \"../Conditional/Conditional\";\nimport { ConditionalSingleBranch } from \"../Conditional/ConditionalSingleBranch\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ParsedObject } from \"../Object\";\nimport { Divert } from \"./Divert\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../../engine/Value\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { FunctionCall } from \"../FunctionCall\";\nimport { MultipleConditionExpression } from \"../Expression/MultipleConditionExpression\";\nimport { Story } from \"../Story\";\nimport { VariableReference } from \"../Variable/VariableReference\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class DivertTarget extends Expression {\n  private _runtimeDivert: RuntimeDivert | null = null;\n  get runtimeDivert(): RuntimeDivert {\n    if (!this._runtimeDivert) {\n      throw new Error();\n    }\n\n    return this._runtimeDivert;\n  }\n\n  private _runtimeDivertTargetValue: DivertTargetValue | null = null;\n  get runtimeDivertTargetValue(): DivertTargetValue {\n    if (!this._runtimeDivertTargetValue) {\n      throw new Error();\n    }\n\n    return this._runtimeDivertTargetValue;\n  }\n\n  public divert: Divert;\n\n  constructor(divert: Divert) {\n    super();\n\n    this.divert = this.AddContent(divert) as Divert;\n  }\n\n  get typeName(): string {\n    return \"DivertTarget\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    this.divert.GenerateRuntimeObject();\n\n    this._runtimeDivert = this.divert.runtimeDivert as RuntimeDivert;\n    this._runtimeDivertTargetValue = new DivertTargetValue();\n\n    container.AddContent(this.runtimeDivertTargetValue);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.divert.isDone || this.divert.isEnd) {\n      this.Error(\n        `Can't use -> DONE or -> END as variable divert targets`,\n        this\n      );\n\n      return;\n    }\n\n    let usageContext: ParsedObject | null = this;\n    while (usageContext && usageContext instanceof Expression) {\n      let badUsage: boolean = false;\n      let foundUsage: boolean = false;\n\n      const usageParent: any = (usageContext as Expression).parent;\n      if (usageParent instanceof BinaryExpression) {\n        // Only allowed to compare for equality\n\n        const binaryExprParent = usageParent;\n        if (\n          binaryExprParent.opName !== \"==\" &&\n          binaryExprParent.opName !== \"!=\"\n        ) {\n          badUsage = true;\n        } else {\n          if (\n            !(\n              binaryExprParent.leftExpression instanceof DivertTarget ||\n              binaryExprParent.leftExpression instanceof VariableReference\n            )\n          ) {\n            badUsage = true;\n          } else if (\n            !(\n              binaryExprParent.rightExpression instanceof DivertTarget ||\n              binaryExprParent.rightExpression instanceof VariableReference\n            )\n          ) {\n            badUsage = true;\n          }\n        }\n\n        foundUsage = true;\n      } else if (usageParent instanceof FunctionCall) {\n        const funcCall = usageParent;\n        if (!funcCall.isTurnsSince && !funcCall.isReadCount) {\n          badUsage = true;\n        }\n\n        foundUsage = true;\n      } else if (usageParent instanceof Expression) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (usageParent instanceof MultipleConditionExpression) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (\n        usageParent instanceof Choice &&\n        (usageParent as Choice).condition === usageContext\n      ) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (\n        usageParent instanceof Conditional ||\n        usageParent instanceof ConditionalSingleBranch\n      ) {\n        badUsage = true;\n        foundUsage = true;\n      }\n\n      if (badUsage) {\n        this.Error(\n          `Can't use a divert target like that. Did you intend to call '${this.divert.target}' as a function: likeThis(), or check the read count: likeThis, with no arrows?`,\n          this\n        );\n      }\n\n      if (foundUsage) {\n        break;\n      }\n\n      usageContext = usageParent;\n    }\n\n    // Example ink for this case:\n    //\n    //     VAR x = -> blah\n    //\n    // ...which means that \"blah\" is expected to be a literal stitch target rather\n    // than a variable name. We can't really intelligently recover from this (e.g. if blah happens to\n    // contain a divert target itself) since really we should be generating a variable reference\n    // rather than a concrete DivertTarget, so we list it as an error.\n    if (this.runtimeDivert.hasVariableTarget) {\n      if (!this.divert.target) {\n        throw new Error();\n      }\n\n      this.Error(\n        `Since '${this.divert.target.dotSeparatedComponents}' is a variable, it shouldn't be preceded by '->' here.`\n      );\n    }\n\n    // Main resolve\n    this.runtimeDivert.targetPath &&\n      (this.runtimeDivertTargetValue.targetPath =\n        this.runtimeDivert.targetPath);\n\n    // Tell hard coded (yet variable) divert targets that they also need to be counted\n    // TODO: Only detect DivertTargets that are values rather than being used directly for\n    // read or turn counts. Should be able to detect this by looking for other uses of containerForCounting\n    let targetContent = this.divert.targetContent;\n    if (targetContent !== null) {\n      let target = targetContent.containerForCounting;\n      if (target !== null) {\n        // Purpose is known: used directly in TURNS_SINCE(-> divTarg)\n        const parentFunc = asOrNull(this.parent, FunctionCall);\n        if (parentFunc && parentFunc.isTurnsSince) {\n          target.turnIndexShouldBeCounted = true;\n        } else {\n          // Unknown purpose, count everything\n          target.visitsShouldBeCounted = true;\n          target.turnIndexShouldBeCounted = true;\n        }\n      }\n\n      // Unfortunately not possible:\n      // https://github.com/inkle/ink/issues/538\n      //\n      // VAR func = -> double\n      //\n      // === function double(ref x)\n      //    ~ x = x * 2\n      //\n      // Because when generating the parameters for a function\n      // to be called, it needs to know ahead of time when\n      // compiling whether to pass a variable reference or value.\n      //\n      let targetFlow = asOrNull(targetContent, FlowBase);\n      if (targetFlow != null && targetFlow.args !== null) {\n        for (const arg of targetFlow.args) {\n          if (arg.isByReference) {\n            this.Error(\n              `Can't store a divert target to a knot or function that has by-reference arguments ('${targetFlow.identifier}' has 'ref ${arg.identifier}').`\n            );\n          }\n        }\n      }\n    }\n  }\n\n  // Equals override necessary in order to check for CONST multiple definition equality\n  public readonly Equals = (obj: ParsedObject): boolean => {\n    const otherDivTarget = asOrNull(obj, DivertTarget);\n    if (\n      !otherDivTarget ||\n      !this.divert.target ||\n      !otherDivTarget.divert.target\n    ) {\n      return false;\n    }\n\n    const targetStr = this.divert.target.dotSeparatedComponents;\n    const otherTargetStr = otherDivTarget.divert.target.dotSeparatedComponents;\n\n    return targetStr === otherTargetStr;\n  };\n}\n","import { Argument } from \"../Argument\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { DivertTarget } from \"./DivertTarget\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { FunctionCall } from \"../FunctionCall\";\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { Path as RuntimePath } from \"../../../../engine/Path\";\nimport { PushPopType } from \"../../../../engine/PushPop\";\nimport { Story } from \"../Story\";\nimport { VariablePointerValue } from \"../../../../engine/Value\";\nimport { VariableReference } from \"../Variable/VariableReference\";\nimport { ClosestFlowBase } from \"../Flow/ClosestFlowBase\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class Divert extends ParsedObject {\n  public readonly args: Expression[] = [];\n\n  public readonly target: Path | null = null;\n  public targetContent: ParsedObject | null = null;\n  private _runtimeDivert: RuntimeDivert | null = null;\n  get runtimeDivert(): RuntimeDivert {\n    if (!this._runtimeDivert) {\n      throw new Error();\n    }\n\n    return this._runtimeDivert;\n  }\n\n  set runtimeDivert(value: RuntimeDivert) {\n    this._runtimeDivert = value;\n  }\n\n  public isFunctionCall: boolean = false;\n  public isEmpty: boolean = false;\n  public isTunnel: boolean = false;\n  public isThread: boolean = false;\n\n  get isEnd(): boolean {\n    return Boolean(this.target && this.target.dotSeparatedComponents === \"END\");\n  }\n\n  get isDone(): boolean {\n    return Boolean(\n      this.target && this.target.dotSeparatedComponents === \"DONE\"\n    );\n  }\n\n  constructor(target?: Path | null | undefined, args?: Expression[]) {\n    super();\n\n    if (target) {\n      this.target = target;\n    }\n\n    if (args) {\n      this.args = args;\n      this.AddContent(args);\n    }\n  }\n\n  get typeName(): string {\n    return \"Divert\";\n  }\n\n  public readonly GenerateRuntimeObject = () => {\n    // End = end flow immediately\n    // Done = return from thread or instruct the flow that it's safe to exit\n    if (this.isEnd) {\n      return RuntimeControlCommand.End();\n    } else if (this.isDone) {\n      return RuntimeControlCommand.Done();\n    }\n\n    this.runtimeDivert = new RuntimeDivert();\n\n    // Normally we resolve the target content during the\n    // Resolve phase, since we expect all runtime objects to\n    // be available in order to find the final runtime path for\n    // the destination. However, we need to resolve the target\n    // (albeit without the runtime target) early so that\n    // we can get information about the arguments - whether\n    // they're by reference - since it affects the code we\n    // generate here.\n    this.ResolveTargetContent();\n\n    this.CheckArgumentValidity();\n\n    // Passing arguments to the knot\n    const requiresArgCodeGen = this.args !== null && this.args.length > 0;\n    if (\n      requiresArgCodeGen ||\n      this.isFunctionCall ||\n      this.isTunnel ||\n      this.isThread\n    ) {\n      const container = new RuntimeContainer();\n\n      // Generate code for argument evaluation\n      // This argument generation is coded defensively - it should\n      // attempt to generate the code for all the parameters, even if\n      // they don't match the expected arguments. This is so that the\n      // parameter objects themselves are generated correctly and don't\n      // get into a state of attempting to resolve references etc\n      // without being generated.\n      if (requiresArgCodeGen) {\n        // Function calls already in an evaluation context\n        if (!this.isFunctionCall) {\n          container.AddContent(RuntimeControlCommand.EvalStart());\n        }\n\n        let targetArguments: Argument[] | null = null;\n        if (this.targetContent) {\n          targetArguments = (this.targetContent as FlowBase).args;\n        }\n\n        for (let ii = 0; ii < this.args.length; ++ii) {\n          const argToPass: Expression = this.args[ii];\n          let argExpected: Argument | null = null;\n          if (targetArguments && ii < targetArguments.length) {\n            argExpected = targetArguments[ii];\n          }\n\n          // Pass by reference: argument needs to be a variable reference\n          if (argExpected && argExpected.isByReference) {\n            const varRef = asOrNull(argToPass, VariableReference);\n            if (!varRef) {\n              this.Error(\n                `Expected variable name to pass by reference to 'ref ${argExpected.identifier}' but saw ${argToPass}`\n              );\n\n              break;\n            }\n\n            // Check that we're not attempting to pass a read count by reference\n            const targetPath = new Path(varRef.pathIdentifiers);\n            const targetForCount: ParsedObject | null =\n              targetPath.ResolveFromContext(this);\n            if (targetForCount) {\n              this.Error(\n                `can't pass a read count by reference. '${\n                  targetPath.dotSeparatedComponents\n                }' is a knot/stitch/label, but '${\n                  this.target!.dotSeparatedComponents\n                }' requires the name of a VAR to be passed.`\n              );\n\n              break;\n            }\n\n            const varPointer = new VariablePointerValue(varRef.name);\n            container.AddContent(varPointer);\n          } else {\n            // Normal value being passed: evaluate it as normal\n            argToPass.GenerateIntoContainer(container);\n          }\n        }\n\n        // Function calls were already in an evaluation context\n        if (!this.isFunctionCall) {\n          container.AddContent(RuntimeControlCommand.EvalEnd());\n        }\n      }\n\n      // Starting a thread? A bit like a push to the call stack below... but not.\n      // It sort of puts the call stack on a thread stack (argh!) - forks the full flow.\n      if (this.isThread) {\n        container.AddContent(RuntimeControlCommand.StartThread());\n      } else if (this.isFunctionCall || this.isTunnel) {\n        // If this divert is a function call, tunnel, we push to the call stack\n        // so we can return again\n        this.runtimeDivert.pushesToStack = true;\n        this.runtimeDivert.stackPushType = this.isFunctionCall\n          ? PushPopType.Function\n          : PushPopType.Tunnel;\n      }\n\n      // Jump into the \"function\" (knot/stitch)\n      container.AddContent(this.runtimeDivert);\n\n      return container;\n    }\n\n    // Simple divert\n    return this.runtimeDivert;\n  };\n\n  // When the divert is to a target that's actually a variable name\n  // rather than an explicit knot/stitch name, try interpretting it\n  // as such by getting the variable name.\n  public readonly PathAsVariableName = () =>\n    this.target ? this.target.firstComponent : null;\n\n  public readonly ResolveTargetContent = (): void => {\n    if (this.isEmpty || this.isEnd) {\n      return;\n    }\n\n    if (this.targetContent === null) {\n      // Is target of this divert a variable name that will be de-referenced\n      // at runtime? If so, there won't be any further reference resolution\n      // we can do at this point.\n      let variableTargetName = this.PathAsVariableName();\n      if (variableTargetName !== null) {\n        const flowBaseScope = asOrNull(ClosestFlowBase(this), FlowBase);\n        if (flowBaseScope) {\n          const resolveResult = flowBaseScope.ResolveVariableWithName(\n            variableTargetName,\n            this\n          );\n\n          if (resolveResult.found) {\n            // Make sure that the flow was typed correctly, given that we know that this\n            // is meant to be a divert target\n            if (\n              resolveResult.isArgument &&\n              resolveResult.ownerFlow &&\n              resolveResult.ownerFlow.args\n            ) {\n              let argument = resolveResult.ownerFlow.args.find(\n                (a) => a.identifier?.name == variableTargetName\n              );\n\n              if (argument && !argument.isDivertTarget) {\n                this.Error(\n                  `Since '${argument.identifier}' is used as a variable divert target (on ${this.debugMetadata}), it should be marked as: -> ${argument.identifier}`,\n                  resolveResult.ownerFlow\n                );\n              }\n            }\n\n            this.runtimeDivert.variableDivertName = variableTargetName;\n            return;\n          }\n        }\n      }\n\n      if (!this.target) {\n        throw new Error();\n      }\n\n      this.targetContent = this.target.ResolveFromContext(this);\n    }\n  };\n\n  public ResolveReferences(context: Story): void {\n    if (this.isEmpty || this.isEnd || this.isDone) {\n      return;\n    } else if (!this.runtimeDivert) {\n      throw new Error();\n    }\n\n    if (this.targetContent) {\n      this.runtimeDivert.targetPath = this.targetContent.runtimePath;\n    }\n\n    // Resolve children (the arguments)\n    super.ResolveReferences(context);\n\n    // May be null if it's a built in function (e.g. TURNS_SINCE)\n    // or if it's a variable target.\n    let targetFlow = asOrNull(this.targetContent, FlowBase);\n    if (targetFlow) {\n      if (!targetFlow.isFunction && this.isFunctionCall) {\n        super.Error(\n          `${targetFlow.identifier} hasn't been marked as a function, but it's being called as one. Do you need to declare the knot as '== function ${targetFlow.identifier} =='?`\n        );\n      } else if (\n        targetFlow.isFunction &&\n        !this.isFunctionCall &&\n        !(this.parent instanceof DivertTarget)\n      ) {\n        super.Error(\n          targetFlow.identifier +\n            \" can't be diverted to. It can only be called as a function since it's been marked as such: '\" +\n            targetFlow.identifier +\n            \"(...)'\"\n        );\n      }\n    }\n\n    // Check validity of target content\n    const targetWasFound = this.targetContent !== null;\n    let isBuiltIn: boolean = false;\n    let isExternal: boolean = false;\n\n    if (!this.target) {\n      throw new Error();\n    } else if (this.target.numberOfComponents === 1) {\n      if (!this.target.firstComponent) {\n        throw new Error();\n      }\n\n      // BuiltIn means TURNS_SINCE, CHOICE_COUNT, RANDOM or SEED_RANDOM\n      isBuiltIn = FunctionCall.IsBuiltIn(this.target.firstComponent);\n\n      // Client-bound function?\n      isExternal = context.IsExternal(this.target.firstComponent);\n\n      if (isBuiltIn || isExternal) {\n        if (!this.isFunctionCall) {\n          super.Error(\n            `${this.target.firstComponent} must be called as a function: ~ ${this.target.firstComponent}()`\n          );\n        }\n\n        if (isExternal) {\n          this.runtimeDivert.isExternal = true;\n          if (this.args !== null) {\n            this.runtimeDivert.externalArgs = this.args.length;\n          }\n\n          this.runtimeDivert.pushesToStack = false;\n          this.runtimeDivert.targetPath = new RuntimePath(\n            this.target.firstComponent\n          );\n\n          this.CheckExternalArgumentValidity(context);\n        }\n\n        return;\n      }\n    }\n\n    // Variable target?\n    if (this.runtimeDivert.variableDivertName != null) {\n      return;\n    }\n\n    if (!targetWasFound && !isBuiltIn && !isExternal) {\n      this.Error(`target not found: '${this.target}'`);\n    }\n  }\n\n  // Returns false if there's an error\n  public readonly CheckArgumentValidity = (): void => {\n    if (this.isEmpty) {\n      return;\n    }\n\n    // Argument passing: Check for errors in number of arguments\n    let numArgs = 0;\n    if (this.args !== null && this.args.length > 0) {\n      numArgs = this.args.length;\n    }\n\n    // Missing content?\n    // Can't check arguments properly. It'll be due to some\n    // other error though, so although there's a problem and\n    // we report false, we don't need to report a specific error.\n    // It may also be because it's a valid call to an external\n    // function, that we check at the resolve stage.\n    if (this.targetContent === null) {\n      return;\n    }\n\n    const targetFlow = asOrNull(this.targetContent, FlowBase);\n\n    // No error, crikey!\n    if (numArgs === 0 && (targetFlow === null || !targetFlow.hasParameters)) {\n      return;\n    } else if (targetFlow === null && numArgs > 0) {\n      this.Error(\n        \"target needs to be a knot or stitch in order to pass arguments\"\n      );\n      return;\n    } else if (\n      targetFlow !== null &&\n      (targetFlow.args === null || (!targetFlow.args && numArgs > 0))\n    ) {\n      this.Error(`target (${targetFlow.name}) doesn't take parameters`);\n      return;\n    } else if (this.parent instanceof DivertTarget) {\n      if (numArgs > 0) {\n        this.Error(`can't store arguments in a divert target variable`);\n      }\n\n      return;\n    }\n\n    const paramCount = targetFlow!.args!.length;\n    if (paramCount !== numArgs) {\n      let butClause: string;\n      if (numArgs === 0) {\n        butClause = \"but there weren't any passed to it\";\n      } else if (numArgs < paramCount) {\n        butClause = `but only got ${numArgs}`;\n      } else {\n        butClause = `but got ${numArgs}`;\n      }\n\n      this.Error(\n        `to '${\n          targetFlow!.identifier\n        }' requires ${paramCount} arguments, ${butClause}`\n      );\n\n      return;\n    }\n\n    // Light type-checking for divert target arguments\n    for (let ii = 0; ii < paramCount; ++ii) {\n      const flowArg: Argument = targetFlow!.args![ii];\n      const divArgExpr: Expression = this.args[ii];\n\n      // Expecting a divert target as an argument, let's do some basic type checking\n      if (flowArg.isDivertTarget) {\n        // Not passing a divert target or any kind of variable reference?\n        let varRef = asOrNull(divArgExpr, VariableReference);\n        if (!(divArgExpr instanceof DivertTarget) && varRef === null) {\n          this.Error(\n            `Target '${\n              targetFlow!.identifier\n            }' expects a divert target for the parameter named -> ${\n              flowArg.identifier\n            } but saw ${divArgExpr}`,\n            divArgExpr\n          );\n        } else if (varRef) {\n          // Passing 'a' instead of '-> a'?\n          // i.e. read count instead of divert target\n          // Unfortunately have to manually resolve here since we're still in code gen\n          const knotCountPath = new Path(varRef.pathIdentifiers);\n          const targetForCount: ParsedObject | null =\n            knotCountPath.ResolveFromContext(varRef);\n          if (targetForCount) {\n            this.Error(\n              `Passing read count of '${knotCountPath.dotSeparatedComponents}' instead of a divert target. You probably meant '${knotCountPath}'`\n            );\n          }\n        }\n      }\n    }\n\n    if (targetFlow === null) {\n      this.Error(\n        \"Can't call as a function or with arguments unless it's a knot or stitch\"\n      );\n      return;\n    }\n\n    return;\n  };\n\n  public readonly CheckExternalArgumentValidity = (context: Story): void => {\n    const externalName: string | null = this.target\n      ? this.target.firstComponent\n      : null;\n    const external = context.externals.get(externalName as string);\n    if (!external) {\n      throw new Error(\"external not found\");\n    }\n\n    const externalArgCount: number = external.argumentNames.length;\n    let ownArgCount = 0;\n    if (this.args) {\n      ownArgCount = this.args.length;\n    }\n\n    if (ownArgCount !== externalArgCount) {\n      this.Error(\n        `incorrect number of arguments sent to external function '${externalName}'. Expected ${externalArgCount} but got ${ownArgCount}`\n      );\n    }\n  };\n\n  public Error(\n    message: string,\n    source: ParsedObject | null = null,\n    isWarning: boolean = false\n  ): void {\n    // Could be getting an error from a nested Divert\n    if (source !== this && source) {\n      super.Error(message, source);\n      return;\n    }\n\n    if (this.isFunctionCall) {\n      super.Error(`Function call ${message}`, source, isWarning);\n    } else {\n      super.Error(`Divert ${message}`, source, isWarning);\n    }\n  }\n\n  public toString = (): string => {\n    let returnString = \"\";\n    if (this.target !== null) {\n      returnString += this.target.toString();\n    } else {\n      return \"-> <empty divert>\";\n    }\n\n    if (this.isTunnel) {\n      returnString += \" ->\";\n    }\n    if (this.isFunctionCall) {\n      returnString += \" ()\";\n    }\n\n    return returnString;\n  };\n}\n","import { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport class GatherPointToResolve {\n  constructor(\n    public divert: RuntimeDivert,\n    public targetRuntimeObj: RuntimeObject\n  ) {}\n}\n","import { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport class SequenceDivertToResolve {\n  constructor(\n    public divert: RuntimeDivert,\n    public targetContent: RuntimeObject\n  ) {}\n}\n","export enum SequenceType {\n  Stopping = 1, // default\n  Cycle = 2,\n  Shuffle = 4,\n  Once = 8,\n}\n","import { ContentList } from \"../ContentList\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { IntValue } from \"../../../../engine/Value\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { SequenceDivertToResolve } from \"./SequenceDivertToResolve\";\nimport { SequenceType } from \"./SequenceType\";\nimport { Story } from \"../Story\";\nimport { Weave } from \"../Weave\";\n\nexport class Sequence extends ParsedObject {\n  private _sequenceDivertsToResolve: SequenceDivertToResolve[] = [];\n\n  public sequenceElements: ParsedObject[];\n\n  constructor(\n    elementContentLists: ContentList[],\n    public readonly sequenceType: SequenceType\n  ) {\n    super();\n\n    this.sequenceType = sequenceType;\n    this.sequenceElements = [];\n\n    for (const elementContentList of elementContentLists) {\n      const contentObjs = elementContentList.content;\n      let seqElObject: ParsedObject | null = null;\n\n      // Don't attempt to create a weave for the sequence element\n      // if the content list is empty. Weaves don't like it!\n      if (contentObjs === null || contentObjs.length === 0) {\n        seqElObject = elementContentList;\n      } else {\n        seqElObject = new Weave(contentObjs);\n      }\n\n      this.sequenceElements.push(seqElObject);\n      this.AddContent(seqElObject);\n    }\n  }\n\n  get typeName(): string {\n    return \"Sequence\";\n  }\n\n  // Generate runtime code that looks like:\n  //\n  //   chosenIndex = MIN(sequence counter, num elements) e.g. for \"Stopping\"\n  //   if chosenIndex == 0, divert to s0\n  //   if chosenIndex == 1, divert to s1  [etc]\n  //\n  //   - s0:\n  //      <content for sequence element>\n  //      divert to no-op\n  //   - s1:\n  //      <content for sequence element>\n  //      divert to no-op\n  //   - s2:\n  //      empty branch if using \"once\"\n  //      divert to no-op\n  //\n  //    no-op\n  //\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    container.visitsShouldBeCounted = true;\n    container.countingAtStartOnly = true;\n\n    this._sequenceDivertsToResolve = [];\n\n    // Get sequence read count\n    container.AddContent(RuntimeControlCommand.EvalStart());\n    container.AddContent(RuntimeControlCommand.VisitIndex());\n\n    const once: boolean = (this.sequenceType & SequenceType.Once) > 0;\n    const cycle: boolean = (this.sequenceType & SequenceType.Cycle) > 0;\n    const stopping: boolean = (this.sequenceType & SequenceType.Stopping) > 0;\n    const shuffle: boolean = (this.sequenceType & SequenceType.Shuffle) > 0;\n\n    let seqBranchCount = this.sequenceElements.length;\n    if (once) {\n      seqBranchCount += 1;\n    }\n\n    // Chosen sequence index:\n    //  - Stopping: take the MIN(read count, num elements - 1)\n    //  - Once: take the MIN(read count, num elements)\n    //    (the last one being empty)\n    if (stopping || once) {\n      //var limit = stopping ? seqBranchCount-1 : seqBranchCount;\n      container.AddContent(new IntValue(seqBranchCount - 1));\n      container.AddContent(NativeFunctionCall.CallWithName(\"MIN\"));\n    } else if (cycle) {\n      // - Cycle: take (read count % num elements)\n      container.AddContent(new IntValue(this.sequenceElements.length));\n      container.AddContent(NativeFunctionCall.CallWithName(\"%\"));\n    }\n\n    // Shuffle\n    if (shuffle) {\n      // Create point to return to when sequence is complete\n      const postShuffleNoOp = RuntimeControlCommand.NoOp();\n\n      // When visitIndex == lastIdx, we skip the shuffle\n      if (once || stopping) {\n        // if( visitIndex == lastIdx ) -> skipShuffle\n        const lastIdx = stopping\n          ? this.sequenceElements.length - 1\n          : this.sequenceElements.length;\n\n        container.AddContent(RuntimeControlCommand.Duplicate());\n        container.AddContent(new IntValue(lastIdx));\n        container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n\n        const skipShuffleDivert = new RuntimeDivert();\n        skipShuffleDivert.isConditional = true;\n        container.AddContent(skipShuffleDivert);\n\n        this.AddDivertToResolve(skipShuffleDivert, postShuffleNoOp);\n      }\n\n      // This one's a bit more complex! Choose the index at runtime.\n      let elementCountToShuffle = this.sequenceElements.length;\n      if (stopping) {\n        elementCountToShuffle -= 1;\n      }\n\n      container.AddContent(new IntValue(elementCountToShuffle));\n      container.AddContent(RuntimeControlCommand.SequenceShuffleIndex());\n      if (once || stopping) {\n        container.AddContent(postShuffleNoOp);\n      }\n    }\n\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n\n    // Create point to return to when sequence is complete\n    const postSequenceNoOp = RuntimeControlCommand.NoOp();\n\n    // Each of the main sequence branches, and one extra empty branch if\n    // we have a \"once\" sequence.\n    for (let elIndex = 0; elIndex < seqBranchCount; elIndex += 1) {\n      // This sequence element:\n      //  if( chosenIndex == this index ) divert to this sequence element\n      // duplicate chosen sequence index, since it'll be consumed by \"==\"\n      container.AddContent(RuntimeControlCommand.EvalStart());\n      container.AddContent(RuntimeControlCommand.Duplicate());\n      container.AddContent(new IntValue(elIndex));\n      container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n      container.AddContent(RuntimeControlCommand.EvalEnd());\n\n      // Divert branch for this sequence element\n      const sequenceDivert = new RuntimeDivert();\n      sequenceDivert.isConditional = true;\n      container.AddContent(sequenceDivert);\n\n      let contentContainerForSequenceBranch: RuntimeContainer;\n\n      // Generate content for this sequence element\n      if (elIndex < this.sequenceElements.length) {\n        const el = this.sequenceElements[elIndex];\n        contentContainerForSequenceBranch =\n          el.runtimeObject as RuntimeContainer;\n      } else {\n        // Final empty branch for \"once\" sequences\n        contentContainerForSequenceBranch = new RuntimeContainer();\n      }\n\n      contentContainerForSequenceBranch.name = `s${elIndex}`;\n      contentContainerForSequenceBranch.InsertContent(\n        RuntimeControlCommand.PopEvaluatedValue(),\n        0\n      );\n\n      // When sequence element is complete, divert back to end of sequence\n      const seqBranchCompleteDivert = new RuntimeDivert();\n      contentContainerForSequenceBranch.AddContent(seqBranchCompleteDivert);\n      container.AddToNamedContentOnly(contentContainerForSequenceBranch);\n\n      // Save the diverts for reference resolution later (in ResolveReferences)\n      this.AddDivertToResolve(\n        sequenceDivert,\n        contentContainerForSequenceBranch\n      );\n      this.AddDivertToResolve(seqBranchCompleteDivert, postSequenceNoOp);\n    }\n\n    container.AddContent(postSequenceNoOp);\n\n    return container;\n  };\n\n  public readonly AddDivertToResolve = (\n    divert: RuntimeDivert,\n    targetContent: RuntimeObject\n  ) => {\n    this._sequenceDivertsToResolve.push(\n      new SequenceDivertToResolve(divert, targetContent)\n    );\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    for (const toResolve of this._sequenceDivertsToResolve) {\n      toResolve.divert.targetPath = toResolve.targetContent.path;\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../engine/Value\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Story } from \"./Story\";\nimport { Void } from \"../../../engine/Void\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\nimport { VariableReference } from \"../../../engine/VariableReference\";\n\nexport class TunnelOnwards extends ParsedObject {\n  private _overrideDivertTarget: DivertTargetValue | null = null;\n\n  private _divertAfter: Divert | null = null;\n  get divertAfter() {\n    return this._divertAfter;\n  }\n\n  set divertAfter(value) {\n    this._divertAfter = value;\n    if (this._divertAfter) {\n      this.AddContent(this._divertAfter);\n    }\n  }\n\n  get typeName(): string {\n    return \"TunnelOnwards\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Set override path for tunnel onwards (or nothing)\n    container.AddContent(RuntimeControlCommand.EvalStart());\n\n    if (this.divertAfter) {\n      // Generate runtime object's generated code and steal the arguments runtime code\n      const returnRuntimeObj = this.divertAfter.GenerateRuntimeObject();\n      const returnRuntimeContainer = returnRuntimeObj as RuntimeContainer;\n      if (returnRuntimeContainer) {\n        // Steal all code for generating arguments from the divert\n        const args = this.divertAfter.args;\n        if (args !== null && args.length > 0) {\n          // Steal everything betwen eval start and eval end\n          let evalStart = -1;\n          let evalEnd = -1;\n          for (\n            let ii = 0;\n            ii < returnRuntimeContainer.content.length;\n            ii += 1\n          ) {\n            const cmd = returnRuntimeContainer.content[\n              ii\n            ] as RuntimeControlCommand;\n            if (cmd) {\n              if (\n                evalStart == -1 &&\n                cmd.commandType === RuntimeControlCommand.CommandType.EvalStart\n              ) {\n                evalStart = ii;\n              } else if (\n                cmd.commandType === RuntimeControlCommand.CommandType.EvalEnd\n              ) {\n                evalEnd = ii;\n              }\n            }\n          }\n\n          for (let ii = evalStart + 1; ii < evalEnd; ii += 1) {\n            const obj = returnRuntimeContainer.content[ii];\n            obj.parent = null; // prevent error of being moved between owners\n            container.AddContent(returnRuntimeContainer.content[ii]);\n          }\n        }\n      }\n      // Supply the divert target for the tunnel onwards target, either variable or more commonly, the explicit name\n      // var returnDivertObj = returnRuntimeObj as Runtime.Divert;\n      let returnDivertObj = asOrNull(returnRuntimeObj, RuntimeDivert);\n      if (returnDivertObj != null && returnDivertObj.hasVariableTarget) {\n        let runtimeVarRef = new VariableReference(\n          returnDivertObj.variableDivertName\n        );\n        container.AddContent(runtimeVarRef);\n      } else {\n        this._overrideDivertTarget = new DivertTargetValue();\n        container.AddContent(this._overrideDivertTarget);\n      }\n    } else {\n      // No divert after tunnel onwards\n      container.AddContent(new Void());\n    }\n\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n    container.AddContent(RuntimeControlCommand.PopTunnel());\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.divertAfter && this.divertAfter.targetContent) {\n      this._overrideDivertTarget!.targetPath =\n        this.divertAfter.targetContent.runtimePath;\n    }\n  }\n\n  public toString = (): string => {\n    return ` -> ${this._divertAfter}`;\n  };\n}\n","import { InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n\n  public TryGetValueForItem(\n    item: InkListItem,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkList as RuntimeInkList } from \"../../../../engine/InkList\";\nimport { InkListItem as RuntimeInkListItem } from \"../../../../engine/InkList\";\nimport { ListDefinition as RuntimeListDefinition } from \"../../../../engine/ListDefinition\";\nimport { ListElementDefinition } from \"./ListElementDefinition\";\nimport { ListValue } from \"../../../../engine/Value\";\nimport { ParsedObject } from \"../Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment } from \"../Variable/VariableAssignment\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ListDefinition extends ParsedObject {\n  public identifier: Identifier | null = null;\n  public variableAssignment: VariableAssignment | null = null;\n\n  get typeName() {\n    return \"ListDefinition\";\n  }\n\n  private _elementsByName: Map<string, ListElementDefinition> | null = null;\n\n  get runtimeListDefinition(): RuntimeListDefinition {\n    const allItems: Map<string, number> = new Map();\n    for (const e of this.itemDefinitions) {\n      if (!allItems.has(e.name!)) {\n        allItems.set(e.name!, e.seriesValue);\n      } else {\n        this.Error(\n          `List '${this.identifier}' contains duplicate items called '${e.name}'`\n        );\n      }\n    }\n\n    return new RuntimeListDefinition(this.identifier?.name || \"\", allItems);\n  }\n\n  public readonly ItemNamed = (\n    itemName: string\n  ): ListElementDefinition | null => {\n    if (this._elementsByName === null) {\n      this._elementsByName = new Map();\n\n      for (const el of this.itemDefinitions) {\n        this._elementsByName.set(el.name!, el);\n      }\n    }\n\n    const foundElement = this._elementsByName.get(itemName) || null;\n\n    return foundElement;\n  };\n\n  constructor(public itemDefinitions: ListElementDefinition[]) {\n    super();\n\n    let currentValue = 1;\n    for (const e of this.itemDefinitions) {\n      if (e.explicitValue !== null) {\n        currentValue = e.explicitValue;\n      }\n\n      e.seriesValue = currentValue;\n\n      currentValue += 1;\n    }\n\n    this.AddContent(itemDefinitions as any);\n  }\n\n  public readonly GenerateRuntimeObject = (): ListValue => {\n    const initialValues = new RuntimeInkList();\n    for (const itemDef of this.itemDefinitions) {\n      if (itemDef.inInitialList) {\n        const item = new RuntimeInkListItem(\n          this.identifier?.name || null,\n          itemDef.name || null\n        );\n        initialValues.Add(item, itemDef.seriesValue);\n      }\n    }\n\n    // Set origin name, so\n    initialValues.SetInitialOriginName(this.identifier?.name || \"\");\n\n    return new ListValue(initialValues);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(this, this.identifier!, SymbolType.List);\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { ClosestFlowBase } from \"../Flow/ClosestFlowBase\";\nimport { ListDefinition } from \"../List/ListDefinition\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class VariableAssignment extends ParsedObject {\n  private _runtimeAssignment: RuntimeVariableAssignment | null = null;\n\n  get variableName(): string {\n    return this.variableIdentifier.name!;\n  }\n  public readonly variableIdentifier: Identifier;\n  public readonly expression: Expression | null = null;\n  public readonly listDefinition: ListDefinition | null = null;\n  public readonly isGlobalDeclaration: boolean;\n  public readonly isNewTemporaryDeclaration: boolean;\n\n  get typeName() {\n    if (this.isNewTemporaryDeclaration) {\n      return \"temp\";\n    } else if (this.isGlobalDeclaration) {\n      if (this.listDefinition !== null) {\n        return \"LIST\";\n      }\n      return \"VAR\";\n    }\n\n    return \"variable assignment\";\n  }\n\n  get isDeclaration(): boolean {\n    return this.isGlobalDeclaration || this.isNewTemporaryDeclaration;\n  }\n\n  constructor({\n    assignedExpression,\n    isGlobalDeclaration,\n    isTemporaryNewDeclaration,\n    listDef,\n    variableIdentifier,\n  }: {\n    readonly assignedExpression?: Expression;\n    readonly isGlobalDeclaration?: boolean;\n    readonly isTemporaryNewDeclaration?: boolean;\n    readonly listDef?: ListDefinition;\n    readonly variableIdentifier: Identifier;\n  }) {\n    super();\n\n    this.variableIdentifier = variableIdentifier;\n    this.isGlobalDeclaration = Boolean(isGlobalDeclaration);\n    this.isNewTemporaryDeclaration = Boolean(isTemporaryNewDeclaration);\n\n    // Defensive programming in case parsing of assignedExpression failed\n    if (listDef instanceof ListDefinition) {\n      this.listDefinition = this.AddContent(listDef) as ListDefinition;\n      this.listDefinition.variableAssignment = this;\n\n      // List definitions are always global\n      this.isGlobalDeclaration = true;\n    } else if (assignedExpression) {\n      this.expression = this.AddContent(assignedExpression) as Expression;\n    }\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    let newDeclScope: FlowBase | null | undefined = null;\n    if (this.isGlobalDeclaration) {\n      newDeclScope = this.story;\n    } else if (this.isNewTemporaryDeclaration) {\n      newDeclScope = ClosestFlowBase(this);\n    }\n\n    if (newDeclScope) {\n      newDeclScope.AddNewVariableDeclaration(this);\n    }\n\n    // Global declarations don't generate actual procedural\n    // runtime objects, but instead add a global variable to the story itself.\n    // The story then initialises them all in one go at the start of the game.\n    if (this.isGlobalDeclaration) {\n      return null;\n    }\n\n    const container = new RuntimeContainer();\n\n    // The expression's runtimeObject is actually another nested container\n    if (this.expression) {\n      container.AddContent(this.expression.runtimeObject);\n    } else if (this.listDefinition) {\n      container.AddContent(this.listDefinition.runtimeObject);\n    }\n\n    this._runtimeAssignment = new RuntimeVariableAssignment(\n      this.variableName,\n      this.isNewTemporaryDeclaration\n    );\n\n    container.AddContent(this._runtimeAssignment);\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // List definitions are checked for conflicts separately\n    if (this.isDeclaration && this.listDefinition === null) {\n      context.CheckForNamingCollisions(\n        this,\n        this.variableIdentifier,\n        this.isGlobalDeclaration ? SymbolType.Var : SymbolType.Temp\n      );\n    }\n\n    // Initial VAR x = [intialValue] declaration, not re-assignment\n    if (this.isGlobalDeclaration) {\n      const variableReference = asOrNull(this.expression, VariableReference);\n      if (\n        variableReference &&\n        !variableReference.isConstantReference &&\n        !variableReference.isListItemReference\n      ) {\n        this.Error(\n          \"global variable assignments cannot refer to other variables, only literal values, constants and list items\"\n        );\n      }\n    }\n\n    if (!this.isNewTemporaryDeclaration) {\n      const resolvedVarAssignment = context.ResolveVariableWithName(\n        this.variableName,\n        this\n      );\n\n      if (!resolvedVarAssignment.found) {\n        if (this.variableName in this.story.constants) {\n          this.Error(\n            `Can't re-assign to a constant (do you need to use VAR when declaring '${this.variableName}'?)`,\n            this\n          );\n        } else {\n          this.Error(\n            `Variable could not be found to assign to: '${this.variableName}'`,\n            this\n          );\n        }\n      }\n\n      // A runtime assignment may not have been generated if it's the initial global declaration,\n      // since these are hoisted out and handled specially in Story.ExportRuntime.\n      if (this._runtimeAssignment) {\n        this._runtimeAssignment.isGlobal = resolvedVarAssignment.isGlobal;\n      }\n    }\n  }\n\n  public readonly toString = (): string =>\n    `${\n      this.isGlobalDeclaration\n        ? \"VAR\"\n        : this.isNewTemporaryDeclaration\n          ? \"~ temp\"\n          : \"\"\n    } ${this.variableName}`;\n}\n","import { AuthorWarning } from \"./AuthorWarning\";\nimport { Choice } from \"./Choice\";\nimport { Conditional } from \"./Conditional/Conditional\";\nimport { ConstantDeclaration } from \"./Declaration/ConstantDeclaration\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTarget } from \"./Divert/DivertTarget\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { Gather } from \"./Gather/Gather\";\nimport { GatherPointToResolve } from \"./Gather/GatherPointToResolve\";\nimport { IWeavePoint } from \"./IWeavePoint\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Sequence } from \"./Sequence/Sequence\";\nimport { Story } from \"./Story\";\nimport { Text } from \"./Text\";\nimport { TunnelOnwards } from \"./TunnelOnwards\";\nimport { VariableAssignment } from \"./Variable/VariableAssignment\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\ntype BadTerminationHandler = (terminatingObj: ParsedObject) => void;\n\n// Used by the FlowBase when constructing the weave flow from\n// a flat list of content objects.\nexport class Weave extends ParsedObject {\n  // Containers can be chained as multiple gather points\n  // get created as the same indentation level.\n  // rootContainer is always the first in the chain, while\n  // currentContainer is the latest.\n  get rootContainer(): RuntimeContainer {\n    if (!this._rootContainer) {\n      this._rootContainer = this.GenerateRuntimeObject();\n    }\n\n    return this._rootContainer;\n  }\n\n  // Keep track of previous weave point (Choice or Gather)\n  // at the current indentation level:\n  //  - to add ordinary content to be nested under it\n  //  - to add nested content under it when it's indented\n  //  - to remove it from the list of loose ends when\n  //     - it has indented content since it's no longer a loose end\n  //     - it's a gather and it has a choice added to it\n  public previousWeavePoint: IWeavePoint | null = null;\n  public addContentToPreviousWeavePoint: boolean = false;\n\n  // Used for determining whether the next Gather should auto-enter\n  public hasSeenChoiceInSection: boolean = false;\n\n  public currentContainer: RuntimeContainer | null = null;\n  public baseIndentIndex: number;\n\n  private _unnamedGatherCount: number = 0;\n  private _choiceCount: number = 0;\n  private _rootContainer: RuntimeContainer | null = null;\n  private _namedWeavePoints: Map<string, IWeavePoint> = new Map();\n  get namedWeavePoints() {\n    return this._namedWeavePoints;\n  }\n\n  // Loose ends are:\n  //  - Choices or Gathers that need to be joined up\n  //  - Explicit Divert to gather points (i.e. \"->\" without a target)\n  public looseEnds: IWeavePoint[] = [];\n\n  public gatherPointsToResolve: GatherPointToResolve[] = [];\n\n  get lastParsedSignificantObject(): ParsedObject | null {\n    if (this.content.length === 0) {\n      return null;\n    }\n\n    // Don't count extraneous newlines or VAR/CONST declarations,\n    // since they're \"empty\" statements outside of the main flow.\n    let lastObject: ParsedObject | null = null;\n    for (let ii = this.content.length - 1; ii >= 0; --ii) {\n      lastObject = this.content[ii];\n\n      let lastText = asOrNull(lastObject, Text);\n      if (lastText && lastText.text === \"\\n\") {\n        continue;\n      }\n\n      if (this.IsGlobalDeclaration(lastObject)) {\n        continue;\n      }\n\n      break;\n    }\n\n    const lastWeave = asOrNull(lastObject, Weave);\n    if (lastWeave) {\n      lastObject = lastWeave.lastParsedSignificantObject;\n    }\n\n    return lastObject;\n  }\n\n  constructor(cont: ParsedObject[], indentIndex: number = -1) {\n    super();\n\n    if (indentIndex == -1) {\n      this.baseIndentIndex = this.DetermineBaseIndentationFromContent(cont);\n    } else {\n      this.baseIndentIndex = indentIndex;\n    }\n\n    this.AddContent(cont);\n\n    this.ConstructWeaveHierarchyFromIndentation();\n  }\n\n  get typeName(): string {\n    return \"Weave\";\n  }\n\n  public readonly ResolveWeavePointNaming = (): void => {\n    const namedWeavePoints = [\n      ...this.FindAll<IWeavePoint>(Gather)(\n        (w) => !(w.name === null || w.name === undefined)\n      ),\n      ...this.FindAll<IWeavePoint>(Choice)(\n        (w) => !(w.name === null || w.name === undefined)\n      ),\n    ];\n    this._namedWeavePoints = new Map();\n\n    for (const weavePoint of namedWeavePoints) {\n      // Check for weave point naming collisions\n      const existingWeavePoint: IWeavePoint | null | undefined =\n        this.namedWeavePoints.get(weavePoint.identifier?.name || \"\");\n\n      if (existingWeavePoint) {\n        const typeName =\n          existingWeavePoint instanceof Gather ? \"gather\" : \"choice\";\n        const existingObj: ParsedObject = existingWeavePoint;\n\n        this.Error(\n          `A ${typeName} with the same label name '${\n            weavePoint.name\n          }' already exists in this context on line ${\n            existingObj.debugMetadata\n              ? existingObj.debugMetadata.startLineNumber\n              : \"NO DEBUG METADATA AVAILABLE\"\n          }`,\n          weavePoint as ParsedObject\n        );\n      }\n      if (weavePoint.identifier?.name) {\n        this.namedWeavePoints.set(weavePoint.identifier?.name, weavePoint);\n      }\n    }\n  };\n\n  public readonly ConstructWeaveHierarchyFromIndentation = (): void => {\n    // Find nested indentation and convert to a proper object hierarchy\n    // (i.e. indented content is replaced with a Weave object that contains\n    // that nested content)\n    let contentIdx = 0;\n    while (contentIdx < this.content.length) {\n      const obj: ParsedObject = this.content[contentIdx];\n\n      // Choice or Gather\n      if (obj instanceof Choice || obj instanceof Gather) {\n        const weavePoint: IWeavePoint = obj;\n        const weaveIndentIdx = weavePoint.indentationDepth - 1;\n\n        // Inner level indentation - recurse\n        if (weaveIndentIdx > this.baseIndentIndex) {\n          // Step through content until indent jumps out again\n          let innerWeaveStartIdx = contentIdx;\n          while (contentIdx < this.content.length) {\n            const innerWeaveObj =\n              asOrNull(this.content[contentIdx], Choice) ||\n              asOrNull(this.content[contentIdx], Gather);\n            if (innerWeaveObj !== null) {\n              const innerIndentIdx = innerWeaveObj.indentationDepth - 1;\n              if (innerIndentIdx <= this.baseIndentIndex) {\n                break;\n              }\n            }\n\n            contentIdx += 1;\n          }\n\n          const weaveContentCount = contentIdx - innerWeaveStartIdx;\n          const weaveContent = this.content.slice(\n            innerWeaveStartIdx,\n            innerWeaveStartIdx + weaveContentCount\n          );\n\n          this.content.splice(innerWeaveStartIdx, weaveContentCount);\n\n          const weave = new Weave(weaveContent, weaveIndentIdx);\n          this.InsertContent(innerWeaveStartIdx, weave);\n\n          // Continue iteration from this point\n          contentIdx = innerWeaveStartIdx;\n        }\n      }\n\n      contentIdx += 1;\n    }\n  };\n\n  // When the indentation wasn't told to us at construction time using\n  // a choice point with a known indentation level, we may be told to\n  // determine the indentation level by incrementing from our closest ancestor.\n  public readonly DetermineBaseIndentationFromContent = (\n    contentList: ParsedObject[]\n  ): number => {\n    for (const obj of contentList) {\n      if (obj instanceof Choice || obj instanceof Gather) {\n        return obj.indentationDepth - 1;\n      }\n    }\n\n    // No weave points, so it doesn't matter\n    return 0;\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeContainer => {\n    this._rootContainer = new RuntimeContainer();\n    this.currentContainer = this._rootContainer;\n    this.looseEnds = [];\n    this.gatherPointsToResolve = [];\n\n    // Iterate through content for the block at this level of indentation\n    //  - Normal content is nested under Choices and Gathers\n    //  - Blocks that are further indented cause recursion\n    //  - Keep track of loose ends so that they can be diverted to Gathers\n    for (const obj of this.content) {\n      // Choice or Gather\n      if (obj instanceof Choice || obj instanceof Gather) {\n        this.AddRuntimeForWeavePoint(obj as IWeavePoint);\n      } else {\n        // Non-weave point\n        if (obj instanceof Weave) {\n          // Nested weave\n          const weave = obj;\n          this.AddRuntimeForNestedWeave(weave);\n          this.gatherPointsToResolve.splice(\n            0,\n            0,\n            ...weave.gatherPointsToResolve\n          );\n        } else {\n          // Other object\n          // May be complex object that contains statements - e.g. a multi-line conditional\n          this.AddGeneralRuntimeContent(obj.runtimeObject);\n        }\n      }\n    }\n\n    // Pass any loose ends up the hierarhcy\n    this.PassLooseEndsToAncestors();\n\n    return this._rootContainer;\n  };\n\n  // Found gather point:\n  //  - gather any loose ends\n  //  - set the gather as the main container to dump new content in\n  public readonly AddRuntimeForGather = (gather: Gather): void => {\n    // Determine whether this Gather should be auto-entered:\n    //  - It is auto-entered if there were no choices in the last section\n    //  - A section is \"since the previous gather\" - so reset now\n    const autoEnter = !this.hasSeenChoiceInSection;\n    this.hasSeenChoiceInSection = false;\n\n    const gatherContainer = gather.runtimeContainer;\n\n    if (!gather.name) {\n      // Use disallowed character so it's impossible to have a name collision\n      gatherContainer.name = `g-${this._unnamedGatherCount}`;\n      this._unnamedGatherCount += 1;\n    }\n\n    if (autoEnter) {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      // Auto-enter: include in main content\n      this.currentContainer.AddContent(gatherContainer);\n    } else {\n      // Don't auto-enter:\n      // Add this gather to the main content, but only accessible\n      // by name so that it isn't stepped into automatically, but only via\n      // a divert from a loose end.\n      this.rootContainer.AddToNamedContentOnly(gatherContainer);\n    }\n\n    // Consume loose ends: divert them to this gather\n    for (const looseEndWeavePoint of this.looseEnds) {\n      const looseEnd = looseEndWeavePoint as ParsedObject;\n\n      // Skip gather loose ends that are at the same level\n      // since they'll be handled by the auto-enter code below\n      // that only jumps into the gather if (current runtime choices == 0)\n      if (looseEnd instanceof Gather) {\n        const prevGather = looseEnd;\n        if (prevGather.indentationDepth == gather.indentationDepth) {\n          continue;\n        }\n      }\n\n      let divert: RuntimeDivert | null = null;\n      if (looseEnd instanceof Divert) {\n        divert = looseEnd.runtimeObject as RuntimeDivert;\n      } else {\n        divert = new RuntimeDivert();\n        const looseWeavePoint = looseEnd as IWeavePoint;\n        if (!looseWeavePoint.runtimeContainer) {\n          throw new Error();\n        }\n\n        looseWeavePoint.runtimeContainer.AddContent(divert);\n      }\n\n      // Pass back knowledge of this loose end being diverted\n      // to the FlowBase so that it can maintain a list of them,\n      // and resolve the divert references later\n      this.gatherPointsToResolve.push(\n        new GatherPointToResolve(divert, gatherContainer)\n      );\n    }\n\n    this.looseEnds = [];\n\n    // Replace the current container itself\n    this.currentContainer = gatherContainer;\n  };\n\n  public readonly AddRuntimeForWeavePoint = (weavePoint: IWeavePoint): void => {\n    // Current level Gather\n    if (weavePoint instanceof Gather) {\n      this.AddRuntimeForGather(weavePoint);\n    }\n\n    // Current level choice\n    else if (weavePoint instanceof Choice) {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      // Gathers that contain choices are no longer loose ends\n      // (same as when weave points get nested content)\n      if (this.previousWeavePoint instanceof Gather) {\n        this.looseEnds.splice(\n          this.looseEnds.indexOf(this.previousWeavePoint),\n          1\n        );\n      }\n\n      // Add choice point content\n      const choice = weavePoint; //, Choice);\n\n      this.currentContainer.AddContent(choice.runtimeObject);\n      if (!choice.innerContentContainer) {\n        throw new Error();\n      } //guaranteed not to happen\n\n      // Add choice's inner content to self\n      choice.innerContentContainer.name = `c-${this._choiceCount}`;\n      this.currentContainer.AddToNamedContentOnly(choice.innerContentContainer);\n      this._choiceCount += 1;\n\n      this.hasSeenChoiceInSection = true;\n    }\n\n    // Keep track of loose ends\n    this.addContentToPreviousWeavePoint = false; // default\n    if (this.WeavePointHasLooseEnd(weavePoint)) {\n      this.looseEnds.push(weavePoint);\n\n      const looseChoice = asOrNull(weavePoint, Choice);\n      if (looseChoice) {\n        this.addContentToPreviousWeavePoint = true;\n      }\n    }\n\n    this.previousWeavePoint = weavePoint;\n  };\n\n  // Add nested block at a greater indentation level\n  public readonly AddRuntimeForNestedWeave = (nestedResult: Weave): void => {\n    // Add this inner block to current container\n    // (i.e. within the main container, or within the last defined Choice/Gather)\n    this.AddGeneralRuntimeContent(nestedResult.rootContainer);\n\n    // Now there's a deeper indentation level, the previous weave point doesn't\n    // count as a loose end (since it will have content to go to)\n    if (this.previousWeavePoint !== null) {\n      this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);\n\n      this.addContentToPreviousWeavePoint = false;\n    }\n  };\n\n  // Normal content gets added into the latest Choice or Gather by default,\n  // unless there hasn't been one yet.\n  public readonly AddGeneralRuntimeContent = (content: RuntimeObject): void => {\n    // Content is allowed to evaluate runtimeObject to null\n    // (e.g. AuthorWarning, which doesn't make it into the runtime)\n    if (content === null) {\n      return;\n    }\n\n    if (this.addContentToPreviousWeavePoint) {\n      if (\n        !this.previousWeavePoint ||\n        !this.previousWeavePoint.runtimeContainer\n      ) {\n        throw new Error();\n      }\n\n      this.previousWeavePoint.runtimeContainer.AddContent(content);\n    } else {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      this.currentContainer.AddContent(content);\n    }\n  };\n\n  public readonly PassLooseEndsToAncestors = () => {\n    if (this.looseEnds.length === 0) {\n      return;\n    }\n\n    // Search for Weave ancestor to pass loose ends to for gathering.\n    // There are two types depending on whether the current weave\n    // is separated by a conditional or sequence.\n    //  - An \"inner\" weave is one that is directly connected to the current\n    //    weave - i.e. you don't have to pass through a conditional or\n    //    sequence to get to it. We're allowed to pass all loose ends to\n    //    one of these.\n    //  - An \"outer\" weave is one that is outside of a conditional/sequence\n    //    that the current weave is nested within. We're only allowed to\n    //    pass gathers (i.e. 'normal flow') loose ends up there, not normal\n    //    choices. The rule is that choices have to be diverted explicitly\n    //    by the author since it's ambiguous where flow should go otherwise.\n    //\n    // e.g.:\n    //\n    //   - top                       <- e.g. outer weave\n    //   {true:\n    //       * choice                <- e.g. inner weave\n    //         * * choice 2\n    //             more content      <- e.g. current weave\n    //       * choice 2\n    //   }\n    //   - more of outer weave\n    //\n    let closestInnerWeaveAncestor: Weave | null = null;\n    let closestOuterWeaveAncestor: Weave | null = null;\n\n    // Find inner and outer ancestor weaves as defined above.\n    let nested = false;\n    for (\n      let ancestor = this.parent;\n      ancestor !== null;\n      ancestor = ancestor.parent\n    ) {\n      // Found ancestor?\n      const weaveAncestor = asOrNull(ancestor, Weave);\n      if (weaveAncestor) {\n        if (!nested && closestInnerWeaveAncestor === null) {\n          closestInnerWeaveAncestor = weaveAncestor;\n        }\n\n        if (nested && closestOuterWeaveAncestor === null) {\n          closestOuterWeaveAncestor = weaveAncestor;\n        }\n      }\n\n      // Weaves nested within Sequences or Conditionals are\n      // \"sealed\" - any loose ends require explicit diverts.\n      if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n        nested = true;\n      }\n    }\n\n    // No weave to pass loose ends to at all?\n    if (\n      closestInnerWeaveAncestor === null &&\n      closestOuterWeaveAncestor === null\n    ) {\n      return;\n    }\n\n    // Follow loose end passing logic as defined above\n    for (let ii = this.looseEnds.length - 1; ii >= 0; ii -= 1) {\n      const looseEnd = this.looseEnds[ii];\n      let received = false;\n\n      if (nested) {\n        // This weave is nested within a conditional or sequence:\n        //  - choices can only be passed up to direct ancestor (\"inner\") weaves\n        //  - gathers can be passed up to either, but favour the closer (inner) weave\n        //    if there is one\n        if (looseEnd instanceof Choice && closestInnerWeaveAncestor !== null) {\n          closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);\n          received = true;\n        } else if (!(looseEnd instanceof Choice)) {\n          const receivingWeave =\n            closestInnerWeaveAncestor || closestOuterWeaveAncestor;\n          if (receivingWeave !== null) {\n            receivingWeave.ReceiveLooseEnd(looseEnd);\n            received = true;\n          }\n        }\n      } else {\n        // No nesting, all loose ends can be safely passed up\n        if (closestInnerWeaveAncestor?.hasOwnProperty(\"ReceiveLooseEnd\")) {\n          closestInnerWeaveAncestor!.ReceiveLooseEnd(looseEnd);\n        }\n        received = true;\n      }\n\n      if (received) {\n        this.looseEnds.splice(ii, 1);\n      }\n    }\n  };\n\n  public readonly ReceiveLooseEnd = (childWeaveLooseEnd: IWeavePoint): void => {\n    this.looseEnds.push(childWeaveLooseEnd);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Check that choices nested within conditionals and sequences are terminated\n    if (this.looseEnds !== null && this.looseEnds.length > 0) {\n      let isNestedWeave = false;\n      for (\n        let ancestor = this.parent;\n        ancestor !== null;\n        ancestor = ancestor.parent\n      ) {\n        if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n          isNestedWeave = true;\n          break;\n        }\n      }\n\n      if (isNestedWeave) {\n        this.ValidateTermination(this.BadNestedTerminationHandler);\n      }\n    }\n\n    for (const gatherPoint of this.gatherPointsToResolve) {\n      gatherPoint.divert.targetPath = gatherPoint.targetRuntimeObj.path;\n    }\n\n    this.CheckForWeavePointNamingCollisions();\n  }\n\n  public readonly WeavePointNamed = (name: string): IWeavePoint | null => {\n    if (!this.namedWeavePoints) {\n      return null;\n    }\n\n    let weavePointResult: IWeavePoint | null | undefined =\n      this.namedWeavePoints.get(name);\n    if (weavePointResult) {\n      return weavePointResult;\n    }\n\n    return null;\n  };\n\n  // Global VARs and CONSTs are treated as \"outside of the flow\"\n  // when iterating over content that follows loose ends\n  public readonly IsGlobalDeclaration = (obj: ParsedObject) => {\n    const varAss = asOrNull(obj, VariableAssignment);\n    if (varAss && varAss.isGlobalDeclaration && varAss.isDeclaration) {\n      return true;\n    }\n\n    const constDecl = asOrNull(obj, ConstantDeclaration);\n    if (constDecl) {\n      return true;\n    }\n\n    return false;\n  };\n\n  // While analysing final loose ends, we look to see whether there\n  // are any diverts etc which choices etc divert from\n  public readonly ContentThatFollowsWeavePoint = (\n    weavePoint: IWeavePoint\n  ): ParsedObject[] => {\n    const returned = [];\n    const obj = weavePoint as ParsedObject;\n\n    // Inner content first (e.g. for a choice)\n    if (obj.content !== null) {\n      for (const contentObj of obj.content) {\n        // Global VARs and CONSTs are treated as \"outside of the flow\"\n        if (this.IsGlobalDeclaration(contentObj)) {\n          continue;\n        }\n\n        returned.push(contentObj);\n      }\n    }\n\n    const parentWeave = asOrNull(obj.parent, Weave);\n    if (parentWeave === null) {\n      throw new Error(\"Expected weave point parent to be weave?\");\n    }\n\n    const weavePointIdx = parentWeave.content.indexOf(obj);\n    for (let ii = weavePointIdx + 1; ii < parentWeave.content.length; ii += 1) {\n      const laterObj = parentWeave.content[ii];\n\n      // Global VARs and CONSTs are treated as \"outside of the flow\"\n      if (this.IsGlobalDeclaration(laterObj)) {\n        continue;\n      }\n\n      // End of the current flow\n      // if (laterObj instanceof IWeavePoint) // cannot test on interface in ts\n      if (laterObj instanceof Choice || laterObj instanceof Gather) {\n        break;\n      }\n\n      // Other weaves will be have their own loose ends\n      if (laterObj instanceof Weave) {\n        break;\n      }\n\n      returned.push(laterObj);\n    }\n\n    return returned;\n  };\n\n  public readonly ValidateTermination = (\n    badTerminationHandler: BadTerminationHandler\n  ): void => {\n    // Don't worry if the last object in the flow is a \"TODO\",\n    // even if there are other loose ends in other places\n    if (this.lastParsedSignificantObject instanceof AuthorWarning) {\n      return;\n    }\n\n    // By now, any sub-weaves will have passed loose ends up to the root weave (this).\n    // So there are 2 possible situations:\n    //  - There are loose ends from somewhere in the flow.\n    //    These aren't necessarily \"real\" loose ends - they're weave points\n    //    that don't connect to any lower weave points, so we just\n    //    have to check that they terminate properly.\n    //  - This weave is just a list of content with no actual weave points,\n    //    so we just need to check that the list of content terminates.\n\n    const hasLooseEnds: boolean =\n      this.looseEnds !== null && this.looseEnds.length > 0;\n\n    if (hasLooseEnds) {\n      for (const looseEnd of this.looseEnds) {\n        const looseEndFlow = this.ContentThatFollowsWeavePoint(looseEnd);\n        this.ValidateFlowOfObjectsTerminates(\n          looseEndFlow,\n          looseEnd as ParsedObject,\n          badTerminationHandler\n        );\n      }\n    } else {\n      // No loose ends... is there any inner weaving at all?\n      // If not, make sure the single content stream is terminated correctly\n      //\n      // If there's any actual weaving, assume that content is\n      // terminated correctly since we would've had a loose end otherwise\n      for (const obj of this.content) {\n        if (obj instanceof Choice || obj instanceof Divert) {\n          return;\n        }\n      }\n\n      // Straight linear flow? Check it terminates\n      this.ValidateFlowOfObjectsTerminates(\n        this.content,\n        this,\n        badTerminationHandler\n      );\n    }\n  };\n\n  readonly BadNestedTerminationHandler: BadTerminationHandler = (\n    terminatingObj\n  ) => {\n    let conditional: Conditional | null = null;\n    for (\n      let ancestor = terminatingObj.parent;\n      ancestor !== null;\n      ancestor = ancestor.parent\n    ) {\n      if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n        conditional = asOrNull(ancestor, Conditional);\n        break;\n      }\n    }\n\n    let errorMsg =\n      \"Choices nested in conditionals or sequences need to explicitly divert afterwards.\";\n\n    // Tutorialise proper choice syntax if this looks like a single choice within a condition, e.g.\n    // { condition:\n    //      * choice\n    // }\n    if (conditional !== null) {\n      let numChoices = conditional.FindAll<Choice>(Choice)().length;\n      if (numChoices === 1) {\n        errorMsg = `Choices with conditions should be written: '* {condition} choice'. Otherwise, ${errorMsg.toLowerCase()}`;\n      }\n    }\n\n    this.Error(errorMsg, terminatingObj);\n  };\n\n  public readonly ValidateFlowOfObjectsTerminates = (\n    objFlow: ParsedObject[],\n    defaultObj: ParsedObject,\n    badTerminationHandler: BadTerminationHandler\n  ) => {\n    let terminated = false;\n    let terminatingObj: ParsedObject = defaultObj;\n    for (const flowObj of objFlow) {\n      const divert = flowObj.Find(Divert)(\n        (d) =>\n          !d.isThread &&\n          !d.isTunnel &&\n          !d.isFunctionCall &&\n          !(d.parent instanceof DivertTarget)\n      );\n\n      if (divert !== null) {\n        terminated = true;\n      }\n\n      if (flowObj.Find(TunnelOnwards)() != null) {\n        terminated = true;\n        break;\n      }\n\n      terminatingObj = flowObj;\n    }\n\n    if (!terminated) {\n      // Author has left a note to self here - clearly we don't need\n      // to leave them with another warning since they know what they're doing.\n      if (terminatingObj instanceof AuthorWarning) {\n        return;\n      }\n\n      badTerminationHandler(terminatingObj);\n    }\n  };\n\n  public readonly WeavePointHasLooseEnd = (\n    weavePoint: IWeavePoint\n  ): boolean => {\n    // No content, must be a loose end.\n    if (weavePoint.content === null) {\n      return true;\n    }\n\n    // If a weave point is diverted from, it doesn't have a loose end.\n    // Detect a divert object within a weavePoint's main content\n    // Work backwards since we're really interested in the end,\n    // although it doesn't actually make a difference!\n    // (content after a divert will simply be inaccessible)\n    for (let ii = weavePoint.content.length - 1; ii >= 0; --ii) {\n      let innerDivert = asOrNull(weavePoint.content[ii], Divert);\n      if (innerDivert) {\n        const willReturn =\n          innerDivert.isThread ||\n          innerDivert.isTunnel ||\n          innerDivert.isFunctionCall;\n        if (!willReturn) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // Enforce rule that weave points must not have the same\n  // name as any stitches or knots upwards in the hierarchy\n  public readonly CheckForWeavePointNamingCollisions = (): void => {\n    if (!this.namedWeavePoints) {\n      return;\n    }\n\n    const ancestorFlows = [];\n    for (const obj of this.ancestry) {\n      const flow = asOrNull(obj, FlowBase);\n      if (flow) {\n        ancestorFlows.push(flow);\n      } else {\n        break;\n      }\n    }\n\n    for (const [weavePointName, weavePoint] of this.namedWeavePoints) {\n      for (const flow of ancestorFlows) {\n        // Shallow search\n        const otherContentWithName =\n          flow.ContentWithNameAtLevel(weavePointName);\n        if (otherContentWithName && otherContentWithName !== weavePoint) {\n          const errorMsg = `${weavePoint.GetType()} '${weavePointName}' has the same label name as a ${otherContentWithName.GetType()} (on ${\n            otherContentWithName.debugMetadata\n          })`;\n          this.Error(errorMsg, weavePoint);\n        }\n      }\n    }\n  };\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { StringValue } from \"../../../../engine/Value\";\nimport { Story } from \"../Story\";\nimport { Text } from \"../Text\";\nimport { Weave } from \"../Weave\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class ConditionalSingleBranch extends ParsedObject {\n  public _contentContainer: RuntimeContainer | null = null;\n  public _conditionalDivert: RuntimeDivert | null = null;\n  public _ownExpression: Expression | null = null;\n  public _innerWeave: Weave | null = null;\n  // bool condition, e.g.:\n  // { 5 == 4:\n  //   - the true branch\n  //   - the false branch\n  // }\n  public isTrueBranch: boolean = false;\n\n  // When each branch has its own expression like a switch statement,\n  // this is non-null. e.g.\n  // { x:\n  //    - 4: the value of x is four (ownExpression is the value 4)\n  //    - 3: the value of x is three\n  // }\n  get ownExpression() {\n    return this._ownExpression;\n  }\n\n  set ownExpression(value) {\n    this._ownExpression = value;\n    if (this._ownExpression) {\n      this.AddContent(this._ownExpression);\n    }\n  }\n\n  // In the above example, match equality of x with 4 for the first branch.\n  // This is as opposed to simply evaluating boolean equality for each branch,\n  // example when shouldMatchEquality is FALSE:\n  // {\n  //    3 > 2:  This will happen\n  //    2 > 3:  This won't happen\n  // }\n  public matchingEquality: boolean = false;\n\n  public isElse: boolean = false;\n  public isInline: boolean = false;\n\n  public returnDivert: RuntimeDivert | null = null;\n\n  constructor(content?: ParsedObject[] | null | undefined) {\n    super();\n\n    // Branches are allowed to be empty\n    if (content) {\n      this._innerWeave = new Weave(content);\n      this.AddContent(this._innerWeave);\n    }\n  }\n\n  get typeName(): string {\n    return \"ConditionalSingleBranch\";\n  }\n\n  // Runtime content can be summarised as follows:\n  //  - Evaluate an expression if necessary to branch on\n  //  - Branch to a named container if true\n  //       - Divert back to main flow\n  //         (owner Conditional is in control of this target point)\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    // Check for common mistake, of putting \"else:\" instead of \"- else:\"\n    if (this._innerWeave) {\n      for (const c of this._innerWeave.content) {\n        const text = asOrNull(c, Text);\n        if (text) {\n          // Don't need to trim at the start since the parser handles that already\n          if (text.text.startsWith(\"else:\")) {\n            this.Warning(\n              \"Saw the text 'else:' which is being treated as content. Did you mean '- else:'?\",\n              text\n            );\n          }\n        }\n      }\n    }\n\n    const container = new RuntimeContainer();\n\n    // Are we testing against a condition that's used for more than just this\n    // branch? If so, the first thing we need to do is replicate the value that's\n    // on the evaluation stack so that we don't fully consume it, in case other\n    // branches need to use it.\n    const duplicatesStackValue: boolean = this.matchingEquality && !this.isElse;\n\n    if (duplicatesStackValue) {\n      container.AddContent(RuntimeControlCommand.Duplicate());\n    }\n\n    this._conditionalDivert = new RuntimeDivert();\n\n    // else clause is unconditional catch-all, otherwise the divert is conditional\n    this._conditionalDivert.isConditional = !this.isElse;\n\n    // Need extra evaluation?\n    if (!this.isTrueBranch && !this.isElse) {\n      const needsEval: boolean = this.ownExpression !== null;\n      if (needsEval) {\n        container.AddContent(RuntimeControlCommand.EvalStart());\n      }\n\n      if (this.ownExpression) {\n        this.ownExpression.GenerateIntoContainer(container);\n      }\n\n      // Uses existing duplicated value\n      if (this.matchingEquality) {\n        container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n      }\n\n      if (needsEval) {\n        container.AddContent(RuntimeControlCommand.EvalEnd());\n      }\n    }\n\n    // Will pop from stack if conditional\n    container.AddContent(this._conditionalDivert);\n\n    this._contentContainer = this.GenerateRuntimeForContent();\n    this._contentContainer.name = \"b\";\n\n    // Multi-line conditionals get a newline at the start of each branch\n    // (as opposed to the start of the multi-line conditional since the condition\n    //  may evaluate to false.)\n    if (!this.isInline) {\n      this._contentContainer.InsertContent(new StringValue(\"\\n\"), 0);\n    }\n\n    if (duplicatesStackValue || (this.isElse && this.matchingEquality)) {\n      this._contentContainer.InsertContent(\n        RuntimeControlCommand.PopEvaluatedValue(),\n        0\n      );\n    }\n\n    container.AddToNamedContentOnly(this._contentContainer);\n\n    this.returnDivert = new RuntimeDivert();\n    this._contentContainer.AddContent(this.returnDivert);\n\n    return container;\n  };\n\n  public readonly GenerateRuntimeForContent = (): RuntimeContainer => {\n    // Empty branch - create empty container\n    if (this._innerWeave === null) {\n      return new RuntimeContainer();\n    }\n\n    return this._innerWeave.rootContainer;\n  };\n\n  public ResolveReferences(context: Story): void {\n    if (!this._conditionalDivert || !this._contentContainer) {\n      throw new Error();\n    }\n\n    this._conditionalDivert.targetPath = this._contentContainer.path;\n    super.ResolveReferences(context);\n  }\n}\n","export enum CustomFlags {\n  ParsingString = 0x1,\n  TagActive = 0x2,\n}\n","export class DebugMetadata {\n  public startLineNumber: number = 0;\n  public endLineNumber: number = 0;\n  public startCharacterNumber: number = 0;\n  public endCharacterNumber: number = 0;\n  public fileName: string | null = null;\n  public sourceName: string | null = null;\n\n  public Merge(dm: DebugMetadata) {\n    let newDebugMetadata = new DebugMetadata();\n\n    newDebugMetadata.fileName = this.fileName;\n    newDebugMetadata.sourceName = this.sourceName;\n\n    if (this.startLineNumber < dm.startLineNumber) {\n      newDebugMetadata.startLineNumber = this.startLineNumber;\n      newDebugMetadata.startCharacterNumber = this.startCharacterNumber;\n    } else if (this.startLineNumber > dm.startLineNumber) {\n      newDebugMetadata.startLineNumber = dm.startLineNumber;\n      newDebugMetadata.startCharacterNumber = dm.startCharacterNumber;\n    } else {\n      newDebugMetadata.startLineNumber = this.startLineNumber;\n      newDebugMetadata.startCharacterNumber = Math.min(\n        this.startCharacterNumber,\n        dm.startCharacterNumber\n      );\n    }\n\n    if (this.endLineNumber > dm.endLineNumber) {\n      newDebugMetadata.endLineNumber = this.endLineNumber;\n      newDebugMetadata.endCharacterNumber = this.endCharacterNumber;\n    } else if (this.endLineNumber < dm.endLineNumber) {\n      newDebugMetadata.endLineNumber = dm.endLineNumber;\n      newDebugMetadata.endCharacterNumber = dm.endCharacterNumber;\n    } else {\n      newDebugMetadata.endLineNumber = this.endLineNumber;\n      newDebugMetadata.endCharacterNumber = Math.max(\n        this.endCharacterNumber,\n        dm.endCharacterNumber\n      );\n    }\n\n    return newDebugMetadata;\n  }\n\n  public toString() {\n    if (this.fileName !== null) {\n      return `line ${this.startLineNumber} of ${this.fileName}\"`;\n    } else {\n      return \"line \" + this.startLineNumber;\n    }\n  }\n}\n","import { INamedContent } from \"../../../../engine/INamedContent\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ExternalDeclaration extends ParsedObject implements INamedContent {\n  public get name(): string | null {\n    return this.identifier?.name || null;\n  }\n\n  constructor(\n    public readonly identifier: Identifier,\n    public readonly argumentNames: string[]\n  ) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"EXTERNAL\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    this.story.AddExternal(this);\n\n    // No runtime code exists for an external, only metadata\n    return null;\n  };\n\n  public toString(): string {\n    return `EXTERNAL ${this.identifier?.name}`;\n  }\n}\n","import { Argument } from \"./ParsedHierarchy/Argument\";\nimport { Identifier } from \"./ParsedHierarchy/Identifier\";\n\nexport class FlowDecl {\n  constructor(\n    public readonly name: Identifier,\n    public readonly args: Argument[],\n    public readonly isFunction: boolean\n  ) {}\n}\n","import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\n\nexport class Wrap<T extends RuntimeObject> extends ParsedObject {\n  constructor(private _objToWrap: T) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => this._objToWrap;\n}\n","import { Glue as RuntimeGlue } from \"../../../engine/Glue\";\nimport { Wrap } from \"./Wrap\";\n\nexport class Glue extends Wrap<RuntimeGlue> {\n  constructor(glue: RuntimeGlue) {\n    super(glue);\n  }\n\n  get typeName(): string {\n    return \"Glue\";\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ContentList } from \"../ContentList\";\nimport { Expression } from \"./Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { IntValue } from \"../../../../engine/Value\";\nimport { Story } from \"../Story\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\nimport { VariableReference as RuntimeVariableReference } from \"../../../../engine/VariableReference\";\nimport { Weave } from \"../Weave\";\nimport { Identifier } from \"../Identifier\";\n\nexport class IncDecExpression extends Expression {\n  private _runtimeAssignment: RuntimeVariableAssignment | null = null;\n\n  public isInc: boolean;\n  public expression: Expression | null = null;\n\n  constructor(\n    public readonly varIdentifier: Identifier | null,\n    isIncOrExpression: boolean | Expression,\n    isInc?: boolean\n  ) {\n    super();\n\n    if (isIncOrExpression instanceof Expression) {\n      this.expression = isIncOrExpression;\n      this.AddContent(this.expression);\n      this.isInc = Boolean(isInc);\n    } else {\n      this.isInc = isIncOrExpression as boolean;\n    }\n  }\n\n  get typeName(): string {\n    return \"IncDecExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    // x = x + y\n    // ^^^ ^ ^ ^\n    //  4  1 3 2\n    // Reverse polish notation: (x 1 +) (assign to x)\n\n    // 1.\n    container.AddContent(\n      new RuntimeVariableReference(this.varIdentifier?.name || null)\n    );\n\n    // 2.\n    // - Expression used in the form ~ x += y\n    // - Simple version: ~ x++\n    if (this.expression) {\n      this.expression.GenerateIntoContainer(container);\n    } else {\n      container.AddContent(new IntValue(1));\n    }\n\n    // 3.\n    container.AddContent(\n      NativeFunctionCall.CallWithName(this.isInc ? \"+\" : \"-\")\n    );\n\n    // 4.\n    this._runtimeAssignment = new RuntimeVariableAssignment(\n      this.varIdentifier?.name || null,\n      false\n    );\n    container.AddContent(this._runtimeAssignment);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    const varResolveResult = context.ResolveVariableWithName(\n      this.varIdentifier?.name || \"\",\n      this\n    );\n\n    if (!varResolveResult.found) {\n      this.Error(\n        `variable for ${this.incrementDecrementWord} could not be found: '${this.varIdentifier}' after searching: {this.descriptionOfScope}`\n      );\n    }\n\n    if (!this._runtimeAssignment) {\n      throw new Error();\n    }\n\n    this._runtimeAssignment.isGlobal = varResolveResult.isGlobal;\n\n    if (\n      !(this.parent instanceof Weave) &&\n      !(this.parent instanceof FlowBase) &&\n      !(this.parent instanceof ContentList)\n    ) {\n      this.Error(`Can't use ${this.incrementDecrementWord} as sub-expression`);\n    }\n  }\n\n  get incrementDecrementWord(): \"increment\" | \"decrement\" {\n    if (this.isInc) {\n      return \"increment\";\n    }\n\n    return \"decrement\";\n  }\n\n  public readonly toString = (): string => {\n    if (this.expression) {\n      return `${this.varIdentifier?.name}${this.isInc ? \" += \" : \" -= \"}${\n        this.expression\n      }`;\n    }\n\n    return `${this.varIdentifier?.name}` + (this.isInc ? \"++\" : \"--\");\n  };\n}\n","import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Story } from \"./Story\";\n\nexport class IncludedFile extends ParsedObject {\n  constructor(public readonly includedStory: Story | null) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    // Left to the main story to process\n    return null;\n  };\n\n  get typeName(): string {\n    return \"IncludedFile\";\n  }\n}\n","export class InfixOperator {\n  constructor(\n    public readonly type: string,\n    public readonly precedence: number,\n    public readonly requireWhitespace: boolean\n  ) {}\n\n  public readonly toString = (): string => this.type;\n}\n","import { Argument } from \"./Argument\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\nimport { Story } from \"./Story\";\n\nexport class Knot extends FlowBase {\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Knot;\n  }\n\n  constructor(\n    name: Identifier,\n    topLevelObjects: ParsedObject[],\n    args: Argument[],\n    isFunction: boolean\n  ) {\n    super(name, topLevelObjects, args, isFunction);\n  }\n\n  get typeName(): string {\n    return this.isFunction ? \"Function\" : \"Knot\";\n  }\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    let parentStory = this.story;\n\n    // Enforce rule that stitches must not have the same\n    // name as any knots that exist in the story\n    for (const stitchName in this.subFlowsByName) {\n      const knotWithStitchName = parentStory.ContentWithNameAtLevel(\n        stitchName,\n        FlowLevel.Knot,\n        false\n      );\n\n      if (knotWithStitchName) {\n        const stitch = this.subFlowsByName.get(stitchName);\n        const errorMsg = `Stitch '${\n          stitch ? stitch.name : \"NO STITCH FOUND\"\n        }' has the same name as a knot (on ${\n          knotWithStitchName.debugMetadata\n        })`;\n        this.Error(errorMsg, stitch);\n      }\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"../Expression/Expression\";\nimport { InkList as RuntimeInkList } from \"../../../../engine/InkList\";\nimport { InkListItem as RuntimeInkListItem } from \"../../../../engine/InkList\";\nimport { ListElementDefinition } from \"./ListElementDefinition\";\nimport { ListValue } from \"../../../../engine/Value\";\nimport { Identifier } from \"../Identifier\";\n\nexport class List extends Expression {\n  constructor(public readonly itemIdentifierList: Identifier[]) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"List\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    const runtimeRawList = new RuntimeInkList();\n\n    if (this.itemIdentifierList != null) {\n      for (const itemIdentifier of this.itemIdentifierList) {\n        const nameParts = itemIdentifier?.name?.split(\".\") || [];\n\n        let listName: string | null = null;\n        let listItemName: string = \"\";\n        if (nameParts.length > 1) {\n          listName = nameParts[0];\n          listItemName = nameParts[1];\n        } else {\n          listItemName = nameParts[0];\n        }\n\n        const listItem = this.story.ResolveListItem(\n          listName,\n          listItemName,\n          this\n        ) as ListElementDefinition;\n\n        if (listItem === null) {\n          if (listName === null) {\n            this.Error(\n              `Could not find list definition that contains item '${itemIdentifier}'`\n            );\n          } else {\n            this.Error(`Could not find list item ${itemIdentifier}`);\n          }\n        } else {\n          if (listItem.parent == null) {\n            this.Error(\n              `Could not find list definition for item ${itemIdentifier}`\n            );\n            return;\n          }\n          if (!listName) {\n            listName = listItem.parent.identifier?.name || null;\n          }\n\n          const item = new RuntimeInkListItem(listName, listItem.name || null);\n\n          if (runtimeRawList.has(item.serialized())) {\n            this.Warning(`Duplicate of item '${itemIdentifier}' in list.`);\n          } else {\n            runtimeRawList.Add(item, listItem.seriesValue);\n          }\n        }\n      }\n    }\n\n    container.AddContent(new ListValue(runtimeRawList));\n  };\n}\n","import { ListDefinition } from \"./ListDefinition\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ListElementDefinition extends ParsedObject {\n  public seriesValue: number = 0;\n\n  public parent: ListDefinition | null = null;\n\n  get fullName(): string {\n    const parentList = this.parent;\n    if (parentList === null) {\n      throw new Error(\"Can't get full name without a parent list.\");\n    }\n\n    return `${parentList.identifier?.name}.${this.name}`;\n  }\n\n  get typeName(): string {\n    return \"ListElement\";\n  }\n\n  get name(): string | null {\n    return this.indentifier?.name || null;\n  }\n\n  constructor(\n    public readonly indentifier: Identifier,\n    public readonly inInitialList: boolean,\n    public readonly explicitValue: number | null = null\n  ) {\n    super();\n    this.parent = this.parent as ListDefinition;\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    throw new Error(\"Not implemented.\");\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(\n      this,\n      this.indentifier,\n      SymbolType.ListItem\n    );\n  }\n\n  public readonly toString = (): string => this.fullName;\n}\n","export enum StatementLevel {\n  InnerBlock,\n  Stitch,\n  Knot,\n  Top,\n}\n","import { Argument } from \"./Argument\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\n\nexport class Stitch extends FlowBase {\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Stitch;\n  }\n\n  constructor(\n    name: Identifier,\n    topLevelObjects: ParsedObject[],\n    args: Argument[],\n    isFunction: boolean\n  ) {\n    super(name, topLevelObjects, args, isFunction);\n  }\n\n  get typeName(): string {\n    return \"Stitch\";\n  }\n\n  // Fixes TS issue with not being able to access the prototype via `super` in functions\n  // attached to the class as properties.\n  private baseToString = this.toString;\n\n  public toString = (): string => {\n    return `${\n      this.parent !== null ? this.parent + \" > \" : \"\"\n    }${this.baseToString()}`;\n  };\n}\n","import { InkObject } from \"./Object\";\n\n// New version of tags is dynamic - it constructs the tags\n// at runtime based on BeginTag and EndTag control commands.\n// Plain text that's in the output stream is turned into tags\n// when you do story.currentTags.\n// The only place this is used is when flattening tags down\n// to string in advance, during dynamic string generation if\n// there's a tag embedded in it. See how ControlCommand.EndString\n// is implemented in Story.cs for more details + comment\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public tags: string[] | null = null;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n\n  public Clone() {\n    let copy = new Choice();\n    copy.text = this.text;\n    copy.sourcePath = this.sourcePath;\n    copy.index = this.index;\n    copy.targetPath = this.targetPath;\n    copy.originalThreadIndex = this.originalThreadIndex;\n    copy.isInvisibleDefault = this.isInvisibleDefault;\n    if (this.threadAtGeneration !== null)\n      copy.threadAtGeneration = this.threadAtGeneration.Copy();\n\n    return copy;\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      //Explicit float value of the form \"123.00f\"\n      const floatRepresentation = /^([0-9]+.[0-9]+f)$/.exec(str);\n      if (floatRepresentation) {\n        return new FloatValue(parseFloat(floatRepresentation[0]));\n      }\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" +\n        this.toJson(token, [\"parent\"])\n    );\n  }\n\n  public static toJson<T>(\n    me: T,\n    removes?: (keyof T)[],\n    space?: number\n  ): string {\n    return JSON.stringify(\n      me,\n      (k, v) => (removes?.some((r) => r === k) ? undefined : v),\n      space\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    choice.tags = this.JArrayToTags(jObj);\n    return choice;\n  }\n\n  public static JArrayToTags(jObj: Record<string, any>) {\n    if (jObj[\"tags\"]) {\n      return jObj[\"tags\"];\n    } else {\n      return null;\n    }\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    this.WriteChoiceTags(writer, choice);\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteChoiceTags(writer: SimpleJson.Writer, choice: Choice) {\n    if (choice.tags && choice.tags.length > 0) {\n      writer.WritePropertyStart(\"tags\");\n      writer.WriteArrayStart();\n      for (const tag of choice.tags!) {\n        writer.Write(tag);\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n    _controlCommandNames[ControlCommand.CommandType.BeginTag] = \"#\";\n    _controlCommandNames[ControlCommand.CommandType.EndTag] = \"/#\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    // contextIndex 0 means global, so index is actually 1-based\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed =\n        this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container !== null) {\n                storyContext.Warning(\n                  \"When loading state, exact internal story location couldn't be found: '\" +\n                    currentContainerPathStr +\n                    \"', so it was approximated to '\" +\n                    pointer.container.path.toString() +\n                    \"' to recover. Has the story changed since this save data was created?\"\n                );\n              } else {\n                storyContext.Warning(\n                  \"When loading state, exact internal story location couldn't be found: '\" +\n                    currentContainerPathStr +\n                    \"' and it may not be recoverable. Has the story changed since this save data was created?\"\n                );\n              }\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables =\n              JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { InkList } from \"./Story\";\nimport { Path } from \"./Path\";\n\n// Fake class wrapper around VariableState to have correct typing\n// when using the Proxy syntax in typescript\nfunction VariablesStateAccessor<T>(): new () => Pick<T, keyof T> {\n  return class {} as any;\n}\n\ntype VariableStateValue = boolean | string | number | InkList | Path | null;\n\nexport class VariablesState extends VariablesStateAccessor<\n  Record<string, any>\n>() {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  public StartVariableObservation() {\n    this._batchObservingVariableChanges = true;\n    this._changedVariablesForBatchObs = new Set();\n  }\n\n  public CompleteVariableObservation(): Map<string, any> {\n    this._batchObservingVariableChanges = false;\n    let changedVars = new Map<string, any>();\n    if (this._changedVariablesForBatchObs != null) {\n      for (let variableName of this._changedVariablesForBatchObs) {\n        let currentValue = this._globalVariables.get(variableName) as InkObject;\n        this.variableChangedEvent(variableName, currentValue);\n      }\n    }\n    // Patch may still be active - e.g. if we were in the middle of a background save\n    if (this.patch != null) {\n      for (let variableName of this.patch.changedVariables) {\n        let patchedVal = this.patch.TryGetGlobal(variableName, null);\n        if (patchedVal.exists) changedVars.set(variableName, patchedVal);\n      }\n    }\n    this._changedVariablesForBatchObs = null;\n    return changedVars;\n  }\n\n  public NotifyObservers(changedVars: Map<string, any>) {\n    for (const [key, value] of changedVars) {\n      this.variableChangedEvent(key, value);\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string): VariableStateValue;\n  public $(variableName: string, value: VariableStateValue): void;\n  public $(variableName: string, value?: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    super();\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n        ownKeys(target: any) {\n          return [\n            ...new Set([\n              ...target._defaultGlobalVariables.keys(),\n              ...target._globalVariables.keys(),\n            ]),\n          ];\n        },\n        getOwnPropertyDescriptor(target, name) {\n          // called for every property\n          return {\n            enumerable: true,\n            configurable: true,\n            value: target.$(name),\n          };\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // the proxy object is not available in this context. we should warn the\n      // dev but writing to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject =\n          JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer =\n          this.ResolveVariablePointer(varPointer);\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this._batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n\n  private _batchObservingVariableChanges: boolean = false;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 48271) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      // Before parsing the JSON, all floats of the form \"123.0\" are transformed into \"123.0f\"\n      // so that they are recognized as FLOAT in the ink runtime\n      const nativeFloatParsing = JSON.parse(\n        \"0\",\n        // @ts-expect-error : typing\n        (_, __, context) => context != null\n      );\n\n      if (!nativeFloatParsing) {\n        // When the nativeFloatParsing argument is false,\n        // we aggressively replace using a regexp\n        // At time of writing : only happen for Safari iOS and Mac\n        const jsonWithExplicitFloat = text.replace(\n          /(,\\s*)([0-9]+\\.[0]+)([,]*)/g,\n          '$1\"$2f\"$3'\n        );\n        this._rootObject = JSON.parse(jsonWithExplicitFloat);\n      } else {\n        // @ts-expect-error : typing\n        const explicitFloatReviver = (_, value, context) => {\n          // When the nativeFloatParsing argument is true,\n          // we use a custom reviver function\n          //see https://github.com/y-lohse/inkjs/pull/1100#issuecomment-2733148441\n          if (Number.isInteger(value) && context.source.endsWith(\".0\")) {\n            return context.source + \"f\";\n          }\n          return value;\n        };\n        // @ts-expect-error : typing\n        this._rootObject = JSON.parse(text, explicitFloatReviver);\n      }\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null value\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public toString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection(): Record<string, any> | null {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  // Backward compatible changes since v8:\n  // v10: dynamic tags\n  // v9:  multi-flows\n  public readonly kInkSaveStateVersion = 10;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.toString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get previousPathString() {\n    let pointer = this.previousPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"previousPointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      let inTag: boolean = false;\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (!inTag && textContent !== null) {\n          sb.Append(textContent.value);\n        } else {\n          let controlCommand = asOrNull(outputObj, ControlCommand);\n          if (controlCommand !== null) {\n            if (\n              controlCommand.commandType == ControlCommand.CommandType.BeginTag\n            ) {\n              inTag = true;\n            } else if (\n              controlCommand.commandType == ControlCommand.CommandType.EndTag\n            ) {\n              inTag = false;\n            }\n          }\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n      let inTag: boolean = false;\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        let controlCommand = asOrNull(outputObj, ControlCommand);\n        if (controlCommand != null) {\n          if (\n            controlCommand.commandType == ControlCommand.CommandType.BeginTag\n          ) {\n            if (inTag && sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = true;\n          } else if (\n            controlCommand.commandType == ControlCommand.CommandType.EndTag\n          ) {\n            if (sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = false;\n          }\n        } else if (inTag) {\n          let strVal = asOrNull(outputObj, StringValue);\n          if (strVal !== null) {\n            sb.Append(strVal.value);\n          }\n        } else {\n          let tag = asOrNull(outputObj, Tag);\n          if (tag != null && tag.text != null && tag.text.length > 0) {\n            this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n          }\n        }\n      }\n\n      if (sb.Length > 0) {\n        let txt = this.CleanOutputWhitespace(sb.toString());\n        this._currentTags.push(txt);\n        sb.Clear();\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this._currentFlow.name == this.kDefaultFlowName;\n  }\n\n  get aliveFlowNames() {\n    if (this._aliveFlowNamesDirty) {\n      this._aliveFlowNames = [];\n\n      if (this._namedFlows != null) {\n        for (let flowName of this._namedFlows.keys()) {\n          if (flowName != this.kDefaultFlowName) {\n            this._aliveFlowNames.push(flowName);\n          }\n        }\n      }\n\n      this._aliveFlowNamesDirty = false;\n    }\n\n    return this._aliveFlowNames;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._aliveFlowNamesDirty = true;\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n      this._aliveFlowNamesDirty = true;\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n    this._aliveFlowNamesDirty = true;\n  }\n\n  public CopyAndStartPatching(forBackgroundSave: boolean) {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    // When background saving we need to make copies of choices since they each have\n    // a snapshot of the thread at the time of generation since the game could progress\n    // significantly and threads modified during the save process.\n    // However, when doing internal saving and restoring of snapshots this isn't an issue,\n    // and we can simply ref-copy the choices with their existing threads.\n\n    if (forBackgroundSave) {\n      for (let choice of this._currentFlow.currentChoices) {\n        copy._currentFlow.currentChoices.push(choice.Clone());\n      }\n    } else {\n      copy._currentFlow.currentChoices.push(\n        ...this._currentFlow.currentChoices\n      );\n    }\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n        copy._aliveFlowNamesDirty = true;\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices =\n        JsonSerialisation.JArrayToRuntimeObjList(\n          jObject[\"currentChoices\"] as any[]\n        ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n    this._aliveFlowNamesDirty = true;\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(innerStrStart, innerStrEnd);\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(\n            tailLastNewlineIdx + 1,\n            tailLastNewlineIdx + 1 + numSpaces\n          )\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint =\n      this.callStack.currentElement.functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer =\n      Pointer.StartOf(funcContainer);\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(\n            typeof args[i] === \"number\" ||\n            typeof args[i] === \"string\" ||\n            typeof args[i] === \"boolean\" ||\n            args[i] instanceof InkList\n          )\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n              \"number, string, bool or InkList. Argument was \" +\n              (nullIfUndefined(args[i]) === null\n                ? \"null\"\n                : args[i].constructor.name)\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight =\n      this.callStack.currentElement.evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return \"-> \" + returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _aliveFlowNames: string[] | null = null;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n  private _aliveFlowNamesDirty: boolean = true;\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","// TODO: Unify with Compiler.\n\nexport type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 21;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this.state.currentFlowIsDefaultFlow;\n  }\n\n  get aliveFlowNames() {\n    return this.state.aliveFlowNames;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          `WARNING: Version of ink ${Story.inkVersionCurrent} used to build story doesn't match current version of engine (${formatFromFile}). Non-critical, but recommend synchronising.`\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions =\n          JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.toString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.StartVariableObservation();\n    } else if (this._asyncContinueActive && !isAsyncTimeLimited) {\n      this._asyncContinueActive = false;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    let changedVariablesToObserve: Map<string, any> | null = null;\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        changedVariablesToObserve =\n          this._state.variablesState.CompleteVariableObservation();\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \" errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \" warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n    if (\n      changedVariablesToObserve != null &&\n      Object.keys(changedVariablesToObserve).length > 0\n    ) {\n      this._state.variablesState.NotifyObservers(changedVariablesToObserve);\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      prevText.length > 0 &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching(false);\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching(true);\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl =\n      this.PerformLogicAndFlowControl(currentContentObj);\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public PopChoiceStringAndTags(tags: string[]) {\n    let choiceOnlyStrVal = asOrThrows(\n      this.state.PopEvaluationStack(),\n      StringValue\n    );\n\n    while (\n      this.state.evaluationStack.length > 0 &&\n      asOrNull(this.state.PeekEvaluationStack(), Tag) != null\n    ) {\n      let tag = asOrNull(this.state.PopEvaluationStack(), Tag);\n      if (tag) tags.push(tag.text);\n    }\n    return choiceOnlyStrVal.value;\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n    let tags: string[] = [];\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      startText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n    choice.tags = tags.reverse(); //C# is a stack\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents =\n          this.state.variablesState.GetVariableWithName(varName);\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n        // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n        // to try and flatten dynamic tags to strings every time \\n is pushed to output\n        case ControlCommand.CommandType.BeginTag:\n          this.state.PushToOutputStream(evalCommand);\n          break;\n\n        // EndTag has 2 modes:\n        //  - When in string evaluation (for choices)\n        //  - Normal\n        //\n        // The only way you could have an EndTag in the middle of\n        // string evaluation is if we're currently generating text for a\n        // choice, such as:\n        //\n        //   + choice # tag\n        //\n        // In the above case, the ink will be run twice:\n        //  - First, to generate the choice text. String evaluation\n        //    will be on, and the final string will be pushed to the\n        //    evaluation stack, ready to be popped to make a Choice\n        //    object.\n        //  - Second, when ink generates text after choosing the choice.\n        //    On this ocassion, it's not in string evaluation mode.\n        //\n        // On the writing side, we disallow manually putting tags within\n        // strings like this:\n        //\n        //   {\"hello # world\"}\n        //\n        // So we know that the tag must be being generated as part of\n        // choice content. Therefore, when the tag has been generated,\n        // we push it onto the evaluation stack in the exact same way\n        // as the string for the choice content.\n        case ControlCommand.CommandType.EndTag: {\n          if (this.state.inStringEvaluation) {\n            let contentStackForTag: InkObject[] = [];\n            let outputCountConsumed = 0;\n            for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n              let obj = this.state.outputStream[i];\n              outputCountConsumed++;\n\n              // var command = obj as ControlCommand;\n              let command = asOrNull(obj, ControlCommand);\n              if (command != null) {\n                if (\n                  command.commandType == ControlCommand.CommandType.BeginTag\n                ) {\n                  break;\n                } else {\n                  this.Error(\n                    \"Unexpected ControlCommand while extracting tag from choice\"\n                  );\n                  break;\n                }\n              }\n              if (obj instanceof StringValue) {\n                contentStackForTag.push(obj);\n              }\n            }\n\n            // Consume the content that was produced for this string\n            this.state.PopFromOutputStream(outputCountConsumed);\n            // Build string out of the content we collected\n            let sb = new StringBuilder();\n            for (let strVal of contentStackForTag.reverse()) {\n              sb.Append(strVal.toString());\n            }\n            let choiceTag = new Tag(\n              this.state.CleanOutputWhitespace(sb.toString())\n            );\n            // Pushing to the evaluation stack means it gets picked up\n            // when a Choice is generated from the next Choice Point.\n            this.state.PushEvaluationStack(choiceTag);\n          } else {\n            // Otherwise! Simply push EndTag, so that in the output stream we\n            // have a structure of: [BeginTag, \"the tag content\", EndTag]\n            this.state.PushToOutputStream(evalCommand);\n          }\n          break;\n        }\n\n        case ControlCommand.CommandType.EndString: {\n          let contentStackForString: InkObject[] = [];\n          let contentToRetain: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n            if (obj instanceof Tag) {\n              contentToRetain.push(obj);\n            }\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // Rescue the tags that we want actually to keep on the output stack\n          // rather than consume as part of the string we're building.\n          // At the time of writing, this only applies to Tag objects generated\n          // by choices, which are pushed to the stack during string generation.\n          for (let rescuedTag of contentToRetain)\n            this.state.PushToOutputStream(rescuedTag);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n        }\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || maxInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container =\n          this.state.callStack.currentElement.currentPointer.container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._state.inStringEvaluation\n    ) {\n      this.Error(\n        \"External function \" +\n          funcName +\n          ' could not be called because 1) it wasn\\'t marked as lookaheadSafe when BindExternalFunction was called and 2) the story is in the middle of string generation, either because choice text is being generated, or because you have ink like \"hello {func()}\". You can work around this by generating the result of your function into a temporary variable before the string or choice gets generated: ~ temp x = ' +\n          funcName +\n          \"()\"\n      );\n    }\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = true\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = false\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound =\n              this.mainContentContainer.namedContent.has(name);\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers =\n            this._variableObservers.get(specificVariableName);\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let inTag = false;\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let command = asOrNull(c, ControlCommand);\n\n      if (command != null) {\n        if (command.commandType == ControlCommand.CommandType.BeginTag) {\n          inTag = true;\n        } else if (command.commandType == ControlCommand.CommandType.EndTag) {\n          inTag = false;\n        }\n      } else if (inTag) {\n        let str = asOrNull(c, StringValue);\n        if (str !== null) {\n          if (tags === null) tags = [];\n          if (str.value !== null) tags.push(str.value);\n        } else {\n          this.Error(\n            \"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\"\n          );\n        }\n      } else {\n        break;\n      }\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<string, Story.VariableObserver[]> | null =\n    null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n","import { AuthorWarning } from \"./AuthorWarning\";\nimport { ConstantDeclaration } from \"./Declaration/ConstantDeclaration\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { ErrorHandler } from \"../../../engine/Error\";\nimport { ErrorType } from \"../ErrorType\";\nimport { Expression } from \"./Expression/Expression\";\nimport { ExternalDeclaration } from \"./Declaration/ExternalDeclaration\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { IncludedFile } from \"./IncludedFile\";\nimport { ListDefinition } from \"./List/ListDefinition\";\nimport { ListElementDefinition } from \"./List/ListElementDefinition\";\nimport { ParsedObject } from \"./Object\";\nimport { Story as RuntimeStory } from \"../../../engine/Story\";\nimport { SymbolType } from \"./SymbolType\";\nimport { Text } from \"./Text\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../engine/VariableAssignment\";\nimport { Identifier } from \"./Identifier\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\nimport { ClosestFlowBase } from \"./Flow/ClosestFlowBase\";\nimport { FunctionCall } from \"./FunctionCall\";\nimport { Path } from \"./Path\";\nimport { VariableAssignment } from \"./Variable/VariableAssignment\";\n\nexport class Story extends FlowBase {\n  public static readonly IsReservedKeyword = (name?: string): boolean => {\n    switch (name) {\n      case \"true\":\n      case \"false\":\n      case \"not\":\n      case \"return\":\n      case \"else\":\n      case \"VAR\":\n      case \"CONST\":\n      case \"temp\":\n      case \"LIST\":\n      case \"function\":\n        return true;\n    }\n\n    return false;\n  };\n\n  private _errorHandler: ErrorHandler | null = null;\n  private _hadError: boolean = false;\n  private _hadWarning: boolean = false;\n  private _dontFlattenContainers: Set<RuntimeContainer> = new Set();\n  private _listDefs: Map<string, ListDefinition> = new Map();\n\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Story;\n  }\n\n  get hadError(): boolean {\n    return this._hadError;\n  }\n\n  get hadWarning(): boolean {\n    return this._hadWarning;\n  }\n\n  public constants: Map<string, Expression> = new Map();\n  public externals: Map<string, ExternalDeclaration> = new Map();\n\n  // Build setting for exporting:\n  // When true, the visit count for *all* knots, stitches, choices,\n  // and gathers is counted. When false, only those that are direclty\n  // referenced by the ink are recorded. Use this flag to allow game-side\n  // querying of  arbitrary knots/stitches etc.\n  // Storing all counts is more robust and future proof (updates to the story file\n  // that reference previously uncounted visits are possible, but generates a much\n  // larger safe file, with a lot of potentially redundant counts.\n  public countAllVisits: boolean = false;\n\n  constructor(toplevelObjects: ParsedObject[], isInclude: boolean = false) {\n    // Don't do anything much on construction, leave it lightweight until\n    // the ExportRuntime method is called.\n    super(null, toplevelObjects, null, false, isInclude);\n  }\n\n  get typeName(): string {\n    return \"Story\";\n  }\n\n  // Before this function is called, we have IncludedFile objects interspersed\n  // in our content wherever an include statement was.\n  // So that the include statement can be added in a sensible place (e.g. the\n  // top of the file) without side-effects of jumping into a knot that was\n  // defined in that include, we separate knots and stitches from anything\n  // else defined at the top scope of the included file.\n  //\n  // Algorithm: For each IncludedFile we find, split its contents into\n  // knots/stiches and any other content. Insert the normal content wherever\n  // the include statement was, and append the knots/stitches to the very\n  // end of the main story.\n  public PreProcessTopLevelObjects(topLevelContent: ParsedObject[]): void {\n    super.PreProcessTopLevelObjects(topLevelContent);\n\n    const flowsFromOtherFiles = [];\n\n    // Inject included files\n    for (let obj of topLevelContent) {\n      if (obj instanceof IncludedFile) {\n        const file: IncludedFile = obj;\n\n        // Remove the IncludedFile itself\n        const posOfObj = topLevelContent.indexOf(obj);\n        topLevelContent.splice(posOfObj, 1);\n\n        // When an included story fails to load, the include\n        // line itself is still valid, so we have to handle it here\n        if (file.includedStory) {\n          const nonFlowContent: ParsedObject[] = [];\n          const subStory = file.includedStory;\n          // Allow empty file\n          if (subStory.content != null) {\n            for (const subStoryObj of subStory.content) {\n              if (subStoryObj instanceof FlowBase) {\n                flowsFromOtherFiles.push(subStoryObj);\n              } else {\n                nonFlowContent.push(subStoryObj);\n              }\n            }\n\n            // Add newline on the end of the include\n            nonFlowContent.push(new Text(\"\\n\"));\n\n            // Add contents of the file in its place\n            topLevelContent.splice(posOfObj, 0, ...nonFlowContent);\n\n            // Skip past the content of this sub story\n            // (since it will already have recursively included\n            //  any lines from other files)\n          }\n        }\n\n        // Include object has been removed, with possible content inserted,\n        // and position of 'i' will have been determined already.\n        continue;\n      }\n    }\n\n    // Add the flows we collected from the included files to the\n    // end of our list of our content\n    topLevelContent.splice(0, 0, ...flowsFromOtherFiles);\n  }\n\n  public readonly ExportRuntime = (\n    errorHandler: ErrorHandler | null = null\n  ): RuntimeStory | null => {\n    this._errorHandler = errorHandler;\n\n    // Find all constants before main export begins, so that VariableReferences know\n    // whether to generate a runtime variable reference or the literal value\n    this.constants = new Map();\n    for (const constDecl of this.FindAll(ConstantDeclaration)()) {\n      // Check for duplicate definitions\n      const existingDefinition: Expression = this.constants.get(\n        constDecl.constantName!\n      ) as any;\n\n      if (existingDefinition) {\n        if (!existingDefinition.Equals(constDecl.expression)) {\n          const errorMsg = `CONST '${constDecl.constantName}' has been redefined with a different value. Multiple definitions of the same CONST are valid so long as they contain the same value. Initial definition was on ${existingDefinition.debugMetadata}.`;\n          this.Error(errorMsg, constDecl, false);\n        }\n      }\n\n      this.constants.set(constDecl.constantName!, constDecl.expression);\n    }\n\n    // List definitions are treated like constants too - they should be usable\n    // from other variable declarations.\n    this._listDefs = new Map();\n    for (const listDef of this.FindAll<ListDefinition>(ListDefinition)()) {\n      if (listDef.identifier?.name) {\n        this._listDefs.set(listDef.identifier?.name, listDef);\n      }\n    }\n\n    this.externals = new Map();\n\n    // Resolution of weave point names has to come first, before any runtime code generation\n    // since names have to be ready before diverts start getting created.\n    // (It used to be done in the constructor for a weave, but didn't allow us to generate\n    // errors when name resolution failed.)\n    this.ResolveWeavePointNaming();\n\n    // Get default implementation of runtimeObject, which calls ContainerBase's generation method\n    const rootContainer = this.runtimeObject as RuntimeContainer;\n\n    // Export initialisation of global variables\n    // TODO: We *could* add this as a declarative block to the story itself...\n    const variableInitialisation = new RuntimeContainer();\n    variableInitialisation.AddContent(RuntimeControlCommand.EvalStart());\n\n    // Global variables are those that are local to the story and marked as global\n    const runtimeLists = [];\n    for (const [key, value] of this.variableDeclarations) {\n      if (value.isGlobalDeclaration) {\n        if (value.listDefinition) {\n          this._listDefs.set(key, value.listDefinition);\n          variableInitialisation.AddContent(\n            value.listDefinition.runtimeObject!\n          );\n\n          runtimeLists.push(value.listDefinition.runtimeListDefinition);\n        } else {\n          if (!value.expression) {\n            throw new Error();\n          }\n          value.expression.GenerateIntoContainer(variableInitialisation);\n        }\n\n        const runtimeVarAss = new RuntimeVariableAssignment(key, true);\n        runtimeVarAss.isGlobal = true;\n        variableInitialisation.AddContent(runtimeVarAss);\n      }\n    }\n\n    variableInitialisation.AddContent(RuntimeControlCommand.EvalEnd());\n    variableInitialisation.AddContent(RuntimeControlCommand.End());\n\n    if (this.variableDeclarations.size > 0) {\n      variableInitialisation.name = \"global decl\";\n      rootContainer.AddToNamedContentOnly(variableInitialisation);\n    }\n\n    // Signal that it's safe to exit without error, even if there are no choices generated\n    // (this only happens at the end of top level content that isn't in any particular knot)\n    rootContainer.AddContent(RuntimeControlCommand.Done());\n\n    // Replace runtimeObject with Story object instead of the Runtime.Container generated by Parsed.ContainerBase\n    const runtimeStory = new RuntimeStory(rootContainer, runtimeLists);\n\n    this.runtimeObject = runtimeStory;\n\n    if (this.hadError) {\n      return null;\n    }\n\n    // Optimisation step - inline containers that can be\n    this.FlattenContainersIn(rootContainer);\n\n    // Now that the story has been fulled parsed into a hierarchy,\n    // and the derived runtime hierarchy has been built, we can\n    // resolve referenced symbols such as variables and paths.\n    // e.g. for paths \" -> knotName --> stitchName\" into an INKPath (knotName.stitchName)\n    // We don't make any assumptions that the INKPath follows the same\n    // conventions as the script format, so we resolve to actual objects before\n    // translating into an INKPath. (This also allows us to choose whether\n    // we want the paths to be absolute)\n    this.ResolveReferences(this);\n\n    if (this.hadError) {\n      return null;\n    }\n\n    runtimeStory.ResetState();\n\n    return runtimeStory;\n  };\n\n  public readonly ResolveList = (listName: string): ListDefinition | null => {\n    let list: ListDefinition | null | undefined = this._listDefs.get(listName);\n    if (!list) {\n      return null;\n    }\n\n    return list;\n  };\n\n  public readonly ResolveListItem = (\n    listName: string | null,\n    itemName: string,\n    source: ParsedObject | null = null\n  ): ListElementDefinition | null => {\n    let listDef: ListDefinition | null | undefined = null;\n\n    // Search a specific list if we know its name (i.e. the form listName.itemName)\n    if (listName) {\n      if (!(listDef = this._listDefs.get(listName))) {\n        return null;\n      }\n\n      return listDef.ItemNamed(itemName);\n    } else {\n      // Otherwise, try to search all lists\n\n      let foundItem: ListElementDefinition | null = null;\n      let originalFoundList: ListDefinition | null = null;\n\n      for (const [, value] of this._listDefs.entries()) {\n        const itemInThisList = value.ItemNamed(itemName);\n        if (itemInThisList) {\n          if (foundItem) {\n            this.Error(\n              `Ambiguous item name '${itemName}' found in multiple sets, including ${\n                originalFoundList!.identifier\n              } and ${value!.identifier}`,\n              source,\n              false\n            );\n          } else {\n            foundItem = itemInThisList;\n            originalFoundList = value!;\n          }\n        }\n      }\n\n      return foundItem;\n    }\n  };\n\n  public readonly FlattenContainersIn = (container: RuntimeContainer): void => {\n    // Need to create a collection to hold the inner containers\n    // because otherwise we'd end up modifying during iteration\n    const innerContainers = new Set<RuntimeContainer>();\n    if (container.content) {\n      for (const c of container.content) {\n        const innerContainer = asOrNull(c, RuntimeContainer);\n        if (innerContainer) {\n          innerContainers.add(innerContainer);\n        }\n      }\n    }\n\n    // Can't flatten the named inner containers, but we can at least\n    // iterate through their children\n    if (container.namedContent) {\n      for (const [, value] of container.namedContent) {\n        const namedInnerContainer = asOrNull(value, RuntimeContainer);\n        if (namedInnerContainer) {\n          innerContainers.add(namedInnerContainer);\n        }\n      }\n    }\n\n    for (const innerContainer of innerContainers) {\n      this.TryFlattenContainer(innerContainer);\n      this.FlattenContainersIn(innerContainer);\n    }\n  };\n\n  public readonly TryFlattenContainer = (container: RuntimeContainer): void => {\n    if (\n      (container.namedContent && container.namedContent.size > 0) ||\n      container.hasValidName ||\n      this._dontFlattenContainers.has(container)\n    ) {\n      return;\n    }\n\n    // Inline all the content in container into the parent\n    const parentContainer = asOrNull(container.parent, RuntimeContainer);\n    if (parentContainer) {\n      let contentIdx = parentContainer.content.indexOf(container);\n      parentContainer.content.splice(contentIdx, 1);\n\n      const dm = container.ownDebugMetadata;\n\n      if (container.content) {\n        for (const innerContent of container.content) {\n          innerContent.parent = null;\n          if (dm !== null && innerContent.ownDebugMetadata === null) {\n            innerContent.debugMetadata = dm;\n          }\n\n          parentContainer.InsertContent(innerContent, contentIdx);\n          contentIdx += 1;\n        }\n      }\n    }\n  };\n\n  public readonly Error = (\n    message: string,\n    source: ParsedObject | null | undefined,\n    isWarning: boolean | null | undefined\n  ) => {\n    let errorType: ErrorType = isWarning ? ErrorType.Warning : ErrorType.Error;\n\n    let sb = \"\";\n    if (source instanceof AuthorWarning) {\n      sb += \"TODO: \";\n      errorType = ErrorType.Author;\n    } else if (isWarning) {\n      sb += \"WARNING: \";\n    } else {\n      sb += \"ERROR: \";\n    }\n\n    if (\n      source &&\n      source.debugMetadata !== null &&\n      source.debugMetadata.startLineNumber >= 1\n    ) {\n      if (source.debugMetadata.fileName != null) {\n        sb += `'${source.debugMetadata.fileName}' `;\n      }\n\n      sb += `line ${source.debugMetadata.startLineNumber}: `;\n    }\n\n    sb += message;\n\n    message = sb;\n\n    if (this._errorHandler !== null) {\n      this._errorHandler(message, errorType);\n    } else {\n      throw new Error(message);\n    }\n\n    this._hadError = errorType === ErrorType.Error;\n    this._hadWarning = errorType === ErrorType.Warning;\n  };\n\n  public readonly ResetError = (): void => {\n    this._hadError = false;\n    this._hadWarning = false;\n  };\n\n  public readonly IsExternal = (namedFuncTarget: string): boolean =>\n    this.externals.has(namedFuncTarget);\n\n  public readonly AddExternal = (decl: ExternalDeclaration): void => {\n    if (this.externals.has(decl.name!)) {\n      this.Error(\n        `Duplicate EXTERNAL definition of '${decl.name}'`,\n        decl,\n        false\n      );\n    } else if (decl.name) {\n      this.externals.set(decl.name, decl);\n    }\n  };\n\n  public readonly DontFlattenContainer = (\n    container: RuntimeContainer\n  ): void => {\n    this._dontFlattenContainers.add(container);\n  };\n\n  public readonly NameConflictError = (\n    obj: ParsedObject,\n    name: string,\n    existingObj: ParsedObject,\n    typeNameToPrint: string\n  ): void => {\n    obj.Error(\n      `${typeNameToPrint} '${name}': name has already been used for a ${existingObj.typeName.toLowerCase()} on ${\n        existingObj.debugMetadata\n      }`\n    );\n  };\n\n  // Check given symbol type against everything that's of a higher priority in the ordered SymbolType enum (above).\n  // When the given symbol type level is reached, we early-out / return.\n  public readonly CheckForNamingCollisions = (\n    obj: ParsedObject,\n    identifier: Identifier,\n    symbolType: SymbolType,\n    typeNameOverride: string = \"\"\n  ): void => {\n    const typeNameToPrint: string = typeNameOverride || obj.typeName;\n    if (Story.IsReservedKeyword(identifier?.name)) {\n      obj.Error(\n        `'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a reserved keyword`\n      );\n      return;\n    } else if (FunctionCall.IsBuiltIn(identifier?.name || \"\")) {\n      obj.Error(\n        `'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a built in function`\n      );\n\n      return;\n    }\n\n    // Top level knots\n    const maybeKnotOrFunction = this.ContentWithNameAtLevel(\n      identifier?.name || \"\",\n      FlowLevel.Knot\n    );\n\n    const knotOrFunction = asOrNull(maybeKnotOrFunction, FlowBase);\n\n    if (\n      knotOrFunction &&\n      (knotOrFunction !== obj || symbolType === SymbolType.Arg)\n    ) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        knotOrFunction,\n        typeNameToPrint\n      );\n      return;\n    }\n\n    if (symbolType < SymbolType.List) {\n      return;\n    }\n\n    // Lists\n    for (const [key, value] of this._listDefs) {\n      if (\n        identifier?.name === key &&\n        obj !== value &&\n        value.variableAssignment !== obj\n      ) {\n        this.NameConflictError(obj, identifier?.name, value, typeNameToPrint);\n      }\n\n      // We don't check for conflicts between individual elements in\n      // different lists because they are namespaced.\n      if (!(obj instanceof ListElementDefinition)) {\n        for (const item of value.itemDefinitions) {\n          if (identifier?.name === item.name) {\n            this.NameConflictError(\n              obj,\n              identifier?.name || \"\",\n              item,\n              typeNameToPrint\n            );\n          }\n        }\n      }\n    }\n\n    // Don't check for VAR->VAR conflicts because that's handled separately\n    // (necessary since checking looks up in a dictionary)\n    if (symbolType <= SymbolType.Var) {\n      return;\n    }\n\n    // Global variable collision\n    const varDecl: VariableAssignment | null =\n      (identifier?.name && this.variableDeclarations.get(identifier?.name)) ||\n      null;\n    if (\n      varDecl &&\n      varDecl !== obj &&\n      varDecl.isGlobalDeclaration &&\n      varDecl.listDefinition == null\n    ) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        varDecl,\n        typeNameToPrint\n      );\n    }\n\n    if (symbolType < SymbolType.SubFlowAndWeave) {\n      return;\n    }\n\n    // Stitches, Choices and Gathers\n    const path = new Path(identifier);\n    const targetContent = path.ResolveFromContext(obj);\n    if (targetContent && targetContent !== obj) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        targetContent,\n        typeNameToPrint\n      );\n      return;\n    }\n\n    if (symbolType < SymbolType.Arg) {\n      return;\n    }\n\n    // Arguments to the current flow\n    if (symbolType !== SymbolType.Arg) {\n      let flow: FlowBase | null = asOrNull(obj, FlowBase);\n      if (!flow) {\n        flow = ClosestFlowBase(obj);\n      }\n\n      if (flow && flow.hasParameters && flow.args) {\n        for (const arg of flow.args) {\n          if (arg.identifier?.name === identifier?.name) {\n            obj.Error(\n              `${typeNameToPrint} '${identifier}': name has already been used for a argument to ${flow.identifier} on ${flow.debugMetadata}`\n            );\n\n            return;\n          }\n        }\n      }\n    }\n  };\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Expression } from \"./Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { Text } from \"../Text\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class StringExpression extends Expression {\n  get isSingleString() {\n    if (this.content.length !== 1) {\n      return false;\n    }\n\n    const c = this.content[0];\n    if (!(c instanceof Text)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  constructor(content: ParsedObject[]) {\n    super();\n\n    this.AddContent(content);\n  }\n\n  get typeName(): string {\n    return \"String\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    container.AddContent(RuntimeControlCommand.BeginString());\n\n    for (const c of this.content) {\n      container.AddContent(c.runtimeObject);\n    }\n\n    container.AddContent(RuntimeControlCommand.EndString());\n  };\n\n  public readonly toString = (): string => {\n    let sb = \"\";\n    for (const c of this.content) {\n      sb += c;\n    }\n\n    return sb;\n  };\n\n  // Equals override necessary in order to check for CONST multiple definition equality\n  public Equals(obj: ParsedObject): boolean {\n    const otherStr = asOrNull(obj, StringExpression);\n    if (otherStr === null) {\n      return false;\n    }\n\n    // Can only compare direct equality on single strings rather than\n    // complex string expressions that contain dynamic logic\n    if (!this.isSingleString || !otherStr.isSingleString) {\n      return false;\n    }\n\n    const thisTxt = this.toString();\n    const otherTxt = otherStr.toString();\n    return thisTxt === otherTxt;\n  }\n}\n","import { ParsedObject } from \"./Object\";\nimport { ControlCommand } from \"../../../engine/ControlCommand\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\n\nexport class Tag extends ParsedObject {\n  public isStart: boolean;\n  public inChoice: boolean;\n\n  constructor(isStart: boolean, inChoice: boolean = false) {\n    super();\n    this.isStart = isStart;\n    this.inChoice = inChoice;\n  }\n  get typeName(): string {\n    return \"Tag\";\n  }\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    if (this.isStart) {\n      return ControlCommand.BeginTag();\n    } else {\n      return ControlCommand.EndTag();\n    }\n  };\n\n  public readonly toString = () => {\n    if (this.isStart) {\n      return \"#StartTag\";\n    } else {\n      return \"#EndTag\";\n    }\n  };\n}\n\nimport { Tag as RuntimeTag } from \"../../../engine/Tag\";\nimport { Wrap } from \"./Wrap\";\nexport class LegacyTag extends Wrap<RuntimeTag> {\n  constructor(tag: RuntimeTag) {\n    super(tag);\n  }\n  get typeName(): string {\n    return \"Tag\";\n  }\n}\n","import { IFileHandler } from \"../IFileHandler\";\n\n// This class replaces upstream's DefaultFileHandler. It doesn't perform any\n// resolution and warns the user about providing a proper file handler when\n// INCLUDE statements are parsed. Since the JavaScript parser can be executed in\n// different environments, we let the user decide which FileHandler is best for\n// their use-case. See PosixFileHandler and JsonFileHandler.\nexport class DefaultFileHandler implements IFileHandler {\n  constructor(public readonly rootPath?: string) {}\n\n  readonly ResolveInkFilename = (): string => {\n    throw Error(\n      \"Can't resolve filename because no FileHandler was provided when instantiating the parser / compiler.\"\n    );\n  };\n\n  readonly LoadInkFileContents = (): string => {\n    throw Error(\n      \"Can't load ink content because no FileHandler was provided when instantiating the parser / compiler.\"\n    );\n  };\n}\n","import { Argument } from \"./ParsedHierarchy/Argument\";\nimport { AuthorWarning } from \"./ParsedHierarchy/AuthorWarning\";\nimport { BinaryExpression } from \"./ParsedHierarchy/Expression/BinaryExpression\";\nimport { CharacterRange } from \"./CharacterRange\";\nimport { CharacterSet } from \"./CharacterSet\";\nimport { Choice } from \"./ParsedHierarchy/Choice\";\nimport { CommentEliminator } from \"./CommentEliminator\";\nimport { Conditional } from \"./ParsedHierarchy/Conditional/Conditional\";\nimport { ConditionalSingleBranch } from \"./ParsedHierarchy/Conditional/ConditionalSingleBranch\";\nimport { ContentList } from \"./ParsedHierarchy/ContentList\";\nimport { ConstantDeclaration } from \"./ParsedHierarchy/Declaration/ConstantDeclaration\";\nimport { CustomFlags } from \"./CustomFlags\";\nimport { DebugMetadata } from \"../../engine/DebugMetadata\";\nimport { Divert } from \"./ParsedHierarchy/Divert/Divert\";\nimport { DivertTarget } from \"./ParsedHierarchy/Divert/DivertTarget\";\nimport { Expression } from \"./ParsedHierarchy/Expression/Expression\";\nimport { ErrorHandler } from \"../../engine/Error\";\nimport { ExternalDeclaration } from \"./ParsedHierarchy/Declaration/ExternalDeclaration\";\nimport { FlowDecl } from \"./FlowDecl\";\nimport { FunctionCall } from \"./ParsedHierarchy/FunctionCall\";\nimport { Gather } from \"./ParsedHierarchy/Gather/Gather\";\nimport { Glue } from \"./ParsedHierarchy/Glue\";\nimport { Glue as RuntimeGlue } from \"../../engine/Glue\";\nimport { IFileHandler } from \"../IFileHandler\";\nimport { IncDecExpression } from \"./ParsedHierarchy/Expression/IncDecExpression\";\nimport { IncludedFile } from \"./ParsedHierarchy/IncludedFile\";\nimport { InfixOperator } from \"./InfixOperator\";\nimport { Knot } from \"./ParsedHierarchy/Knot\";\nimport { List } from \"./ParsedHierarchy/List/List\";\nimport { ListDefinition } from \"./ParsedHierarchy/List/ListDefinition\";\nimport { ListElementDefinition } from \"./ParsedHierarchy/List/ListElementDefinition\";\nimport { MultipleConditionExpression } from \"./ParsedHierarchy/Expression/MultipleConditionExpression\";\nimport { ParsedObject } from \"./ParsedHierarchy/Object\";\nimport { Path } from \"./ParsedHierarchy/Path\";\nimport { ReturnType } from \"./ParsedHierarchy/ReturnType\";\nimport { Sequence } from \"./ParsedHierarchy/Sequence/Sequence\";\nimport { SequenceType } from \"./ParsedHierarchy/Sequence/SequenceType\";\nimport { StatementLevel } from \"./StatementLevel\";\nimport { Stitch } from \"./ParsedHierarchy/Stitch\";\nimport { Story } from \"./ParsedHierarchy/Story\";\nimport { StringExpression } from \"./ParsedHierarchy/Expression/StringExpression\";\nimport {\n  StringParser,\n  SpecificParseRule,\n  ParseRule,\n  ParseRuleReturn,\n  ParseSuccess,\n} from \"./StringParser/StringParser\";\nimport { StringParserElement } from \"./StringParser/StringParserElement\";\nimport { Tag } from \"./ParsedHierarchy/Tag\";\nimport { Text } from \"./ParsedHierarchy/Text\";\nimport { TunnelOnwards } from \"./ParsedHierarchy/TunnelOnwards\";\nimport { VariableAssignment } from \"./ParsedHierarchy/Variable/VariableAssignment\";\nimport { VariableReference } from \"./ParsedHierarchy/Variable/VariableReference\";\nimport { UnaryExpression } from \"./ParsedHierarchy/Expression/UnaryExpression\";\nimport { asOrNull, filterUndef } from \"../../engine/TypeAssertion\";\nimport { Identifier } from \"./ParsedHierarchy/Identifier\";\nimport { NumberExpression } from \"./ParsedHierarchy/Expression/NumberExpression\";\nimport { ErrorType } from \"./ErrorType\";\nimport { DefaultFileHandler } from \"../FileHandler/DefaultFileHandler\";\n\nexport class InkParser extends StringParser {\n  /**\n   * Begin base InkParser section.\n   */\n\n  get fileHandler(): IFileHandler {\n    if (!this._fileHandler) {\n      throw new Error(\"No FileHandler defined\");\n    }\n    return this._fileHandler;\n  }\n\n  set fileHandler(value: IFileHandler) {\n    this._fileHandler = value;\n  }\n\n  constructor(\n    str: string,\n    filename: string | null = null,\n    externalErrorHandler: ErrorHandler | null = null,\n    rootParser: InkParser | null = null,\n    fileHandler: IFileHandler | null = null\n  ) {\n    super(str);\n\n    this._filename = filename;\n    this.RegisterExpressionOperators();\n    this.GenerateStatementLevelRules();\n\n    this.errorHandler = this.OnStringParserError;\n\n    this._externalErrorHandler = externalErrorHandler;\n\n    if (fileHandler === null) {\n      this._fileHandler = new DefaultFileHandler();\n    } else {\n      this._fileHandler = fileHandler;\n    }\n\n    if (rootParser === null) {\n      this._rootParser = this;\n      this._openFilenames = [];\n\n      if (this._filename !== null) {\n        const fullRootInkPath = this.fileHandler.ResolveInkFilename(\n          this._filename\n        );\n        this._openFilenames.push(fullRootInkPath);\n      }\n    } else {\n      this._rootParser = rootParser;\n    }\n  }\n\n  // Main entry point\n  // NOTE: This method is named Parse() in upstream.\n  public readonly ParseStory = (): Story => {\n    const topLevelContent: ParsedObject[] = this.StatementsAtLevel(\n      StatementLevel.Top\n    );\n\n    // Note we used to return null if there were any errors, but this would mean\n    // that include files would return completely empty rather than attempting to\n    // continue with errors. Returning an empty include files meant that anything\n    // that *did* compile successfully would otherwise be ignored, generating way\n    // more errors than necessary.\n    return new Story(topLevelContent, this._rootParser !== this);\n  };\n\n  public readonly SeparatedList = <T extends ParseRule>(\n    mainRule: SpecificParseRule<T>,\n    separatorRule: ParseRule\n  ): ParseRuleReturn[] | null => {\n    const firstElement: ParseRuleReturn = this.Parse(mainRule);\n    if (firstElement === null) {\n      return null;\n    }\n\n    const allElements = [];\n    allElements.push(firstElement);\n\n    do {\n      const nextElementRuleId: number = this.BeginRule();\n      let sep = separatorRule();\n      if (sep === null) {\n        this.FailRule(nextElementRuleId);\n        break;\n      }\n\n      const nextElement = this.Parse(mainRule);\n      if (nextElement === null) {\n        this.FailRule(nextElementRuleId);\n        break;\n      }\n\n      this.SucceedRule(nextElementRuleId);\n      allElements.push(nextElement);\n    } while (true);\n\n    return allElements;\n  };\n\n  public PreProcessInputString(str: string): string {\n    const commentEliminator = new CommentEliminator(str);\n    return commentEliminator.Process();\n  }\n\n  public readonly CreateDebugMetadata = (\n    stateAtStart: StringParserElement | null,\n    stateAtEnd: StringParserElement\n  ): DebugMetadata => {\n    const md = new DebugMetadata();\n    md.startLineNumber = (stateAtStart?.lineIndex || 0) + 1;\n    md.endLineNumber = stateAtEnd.lineIndex + 1;\n    md.startCharacterNumber = (stateAtStart?.characterInLineIndex || 0) + 1;\n    md.endCharacterNumber = stateAtEnd.characterInLineIndex + 1;\n    md.fileName = this._filename;\n\n    return md;\n  };\n\n  public readonly RuleDidSucceed = (\n    result: ParseRuleReturn,\n    stateAtStart: StringParserElement | null,\n    stateAtEnd: StringParserElement\n  ): void => {\n    // Apply DebugMetadata based on the state at the start of the rule\n    // (i.e. use line number as it was at the start of the rule)\n    const parsedObj = asOrNull(result, ParsedObject);\n    if (parsedObj) {\n      parsedObj.debugMetadata = this.CreateDebugMetadata(\n        stateAtStart,\n        stateAtEnd\n      );\n    }\n\n    // A list of objects that doesn't already have metadata?\n    const parsedListObjs: ParsedObject[] | null = Array.isArray(result)\n      ? (result as ParsedObject[])\n      : null;\n    if (parsedListObjs !== null) {\n      for (const parsedListObj of parsedListObjs) {\n        const singleObj = asOrNull(parsedListObj, ParsedObject);\n        if (!singleObj) continue;\n        if (!parsedListObj.hasOwnDebugMetadata) {\n          parsedListObj.debugMetadata = this.CreateDebugMetadata(\n            stateAtStart,\n            stateAtEnd\n          );\n        }\n      }\n    }\n\n    const id = asOrNull(result, Identifier);\n    if (id != null) {\n      id.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n    }\n  };\n\n  get parsingStringExpression(): boolean {\n    return this.GetFlag(Number(CustomFlags.ParsingString));\n  }\n\n  set parsingStringExpression(value: boolean) {\n    this.SetFlag(Number(CustomFlags.ParsingString), value);\n  }\n\n  get tagActive(): boolean {\n    return this.GetFlag(Number(CustomFlags.TagActive));\n  }\n\n  set tagActive(value: boolean) {\n    this.SetFlag(Number(CustomFlags.TagActive), value);\n  }\n\n  public readonly OnStringParserError = (\n    message: string,\n    index: number,\n    lineIndex: number = 0,\n    isWarning: boolean = false\n  ): void => {\n    const warningType: string = isWarning ? \"WARNING:\" : \"ERROR:\";\n    let fullMessage: string = warningType;\n\n    if (this._filename !== null) {\n      fullMessage += ` '${this._filename}'`;\n    }\n\n    fullMessage += ` line ${lineIndex + 1}: ${message}`;\n\n    if (this._externalErrorHandler !== null) {\n      this._externalErrorHandler(\n        fullMessage,\n        isWarning ? ErrorType.Warning : ErrorType.Error\n      );\n    } else {\n      throw new Error(fullMessage);\n    }\n  };\n\n  public readonly AuthorWarning = (): AuthorWarning | null => {\n    this.Whitespace();\n\n    const identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as unknown as Identifier | null;\n    if (identifier === null || identifier.name !== \"TODO\") {\n      return null;\n    }\n\n    this.Whitespace();\n    this.ParseString(\":\");\n    this.Whitespace();\n\n    const message = this.ParseUntilCharactersFromString(\"\\n\\r\");\n\n    if (message) {\n      return new AuthorWarning(message);\n    }\n\n    return null;\n  };\n\n  /**\n   * End base InkParser section.\n   */\n\n  /**\n   * Begin CharacterRanges section.\n   */\n\n  public static readonly LatinBasic: CharacterRange = CharacterRange.Define(\n    \"\\u0041\",\n    \"\\u007A\",\n    new CharacterSet().AddRange(\"\\u005B\", \"\\u0060\")\n  );\n\n  public static readonly LatinExtendedA: CharacterRange = CharacterRange.Define(\n    \"\\u0100\",\n    \"\\u017F\"\n    // no excludes here\n  );\n\n  public static readonly LatinExtendedB: CharacterRange = CharacterRange.Define(\n    \"\\u0180\",\n    \"\\u024F\"\n    // no excludes here\n  );\n\n  public static readonly Greek: CharacterRange = CharacterRange.Define(\n    \"\\u0370\",\n    \"\\u03FF\",\n    new CharacterSet()\n      .AddRange(\"\\u0378\", \"\\u0385\")\n      .AddCharacters(\"\\u0374\\u0375\\u0378\\u0387\\u038B\\u038D\\u03A2\")\n  );\n\n  public static readonly Cyrillic: CharacterRange = CharacterRange.Define(\n    \"\\u0400\",\n    \"\\u04FF\",\n    new CharacterSet().AddRange(\"\\u0482\", \"\\u0489\")\n  );\n\n  public static readonly Armenian: CharacterRange = CharacterRange.Define(\n    \"\\u0530\",\n    \"\\u058F\",\n    new CharacterSet()\n      .AddCharacters(\"\\u0530\")\n      .AddRange(\"\\u0557\", \"\\u0560\")\n      .AddRange(\"\\u0588\", \"\\u058E\")\n  );\n\n  public static readonly Hebrew: CharacterRange = CharacterRange.Define(\n    \"\\u0590\",\n    \"\\u05FF\",\n    new CharacterSet()\n  );\n\n  public static readonly Arabic: CharacterRange = CharacterRange.Define(\n    \"\\u0600\",\n    \"\\u06FF\",\n    new CharacterSet()\n  );\n\n  public static readonly Korean: CharacterRange = CharacterRange.Define(\n    \"\\uAC00\",\n    \"\\uD7AF\",\n    new CharacterSet()\n  );\n\n  public static readonly Latin1Supplement: CharacterRange =\n    CharacterRange.Define(\"\\u0080\", \"\\u00FF\", new CharacterSet());\n\n  public static readonly Chinese: CharacterRange = CharacterRange.Define(\n    \"\\u4E00\",\n    \"\\u9FFF\",\n    new CharacterSet()\n  );\n\n  private readonly ExtendIdentifierCharacterRanges = (\n    identifierCharSet: CharacterSet\n  ): void => {\n    const characterRanges = InkParser.ListAllCharacterRanges();\n    for (const charRange of characterRanges) {\n      identifierCharSet.AddCharacters(charRange.ToCharacterSet());\n    }\n  };\n\n  /// <summary>\n  /// Gets an array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  /// non-ASCII character ranges that can be used in identifier names.\n  /// </summary>\n  /// <returns>\n  /// An array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  /// non-ASCII character ranges that can be used in identifier names.\n  /// </returns>\n  public static readonly ListAllCharacterRanges = (): CharacterRange[] => [\n    InkParser.LatinBasic,\n    InkParser.LatinExtendedA,\n    InkParser.LatinExtendedB,\n    InkParser.Arabic,\n    InkParser.Armenian,\n    InkParser.Cyrillic,\n    InkParser.Greek,\n    InkParser.Hebrew,\n    InkParser.Korean,\n    InkParser.Latin1Supplement,\n    InkParser.Chinese,\n  ];\n\n  /**\n   * End CharacterRanges section.\n   */\n\n  /**\n   * Begin Choices section.\n   */\n\n  public _parsingChoice: boolean = false;\n\n  public readonly Choice = (): Choice | null => {\n    let onceOnlyChoice: boolean = true;\n    let bullets = this.Interleave<string>(\n      this.OptionalExclude(this.Whitespace),\n      this.String(\"*\")\n    );\n\n    if (!bullets) {\n      bullets = this.Interleave<string>(\n        this.OptionalExclude(this.Whitespace),\n        this.String(\"+\")\n      );\n\n      if (bullets === null) {\n        return null;\n      }\n\n      onceOnlyChoice = false;\n    }\n\n    // Optional name for the choice\n    const optionalName: Identifier = this.Parse(\n      this.BracketedName\n    ) as Identifier;\n\n    this.Whitespace();\n\n    // Allow optional newline right after a choice name\n    if (optionalName != null) this.Newline();\n\n    // Optional condition for whether the choice should be shown to the player\n    const conditionExpr: Expression = this.Parse(\n      this.ChoiceCondition\n    ) as Expression;\n\n    this.Whitespace();\n\n    // Ordinarily we avoid parser state variables like these, since\n    // nesting would require us to store them in a stack. But since you should\n    // never be able to nest choices within choice content, it's fine here.\n    if (this._parsingChoice) {\n      throw new Error(\n        \"Already parsing a choice - shouldn't have nested choices\"\n      );\n    }\n\n    this._parsingChoice = true;\n\n    let startContent: ContentList | null = null;\n    const startTextAndLogic = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n    if (startTextAndLogic) {\n      startContent = new ContentList(startTextAndLogic);\n    }\n\n    let optionOnlyContent: ContentList | null = null;\n    let innerContent: ContentList | null = null;\n\n    // Check for a the weave style format:\n    //   * \"Hello[.\"],\" he said.\n    const hasWeaveStyleInlineBrackets: boolean = this.ParseString(\"[\") !== null;\n    if (hasWeaveStyleInlineBrackets) {\n      this.EndTagIfNecessary(startContent);\n\n      const optionOnlyTextAndLogic = this.Parse(\n        this.MixedTextAndLogic\n      ) as ParsedObject[];\n\n      if (optionOnlyTextAndLogic !== null) {\n        optionOnlyContent = new ContentList(optionOnlyTextAndLogic);\n      }\n\n      this.Expect(this.String(\"]\"), \"closing ']' for weave-style option\");\n\n      this.EndTagIfNecessary(optionOnlyContent);\n\n      let innerTextAndLogic = this.Parse(\n        this.MixedTextAndLogic\n      ) as ParsedObject[];\n      if (innerTextAndLogic !== null) {\n        innerContent = new ContentList(innerTextAndLogic);\n      }\n    }\n\n    this.Whitespace();\n\n    this.EndTagIfNecessary(innerContent ?? startContent);\n\n    // Finally, now we know we're at the end of the main choice body, parse\n    // any diverts separately.\n    const diverts: ParsedObject[] = this.Parse(\n      this.MultiDivert\n    ) as ParsedObject[];\n\n    this._parsingChoice = false;\n\n    this.Whitespace();\n\n    // Completely empty choice without even an empty divert?\n    const emptyContent: boolean =\n      !startContent && !innerContent && !optionOnlyContent;\n\n    if (emptyContent && diverts === null) {\n      this.Warning(\n        \"Choice is completely empty. Interpretting as a default fallback choice. Add a divert arrow to remove this warning: * ->\"\n      );\n    }\n\n    if (!startContent && hasWeaveStyleInlineBrackets && !optionOnlyContent) {\n      // * [] some text\n      this.Warning(\n        \"Blank choice - if you intended a default fallback choice, use the `* ->` syntax\"\n      );\n    }\n\n    if (!innerContent) {\n      innerContent = new ContentList();\n    }\n\n    this.EndTagIfNecessary(innerContent);\n\n    // Normal diverts on the end of a choice - simply add to the normal content\n    if (diverts !== null) {\n      for (const divObj of diverts) {\n        // may be TunnelOnwards\n        const div = asOrNull(divObj, Divert);\n\n        // Empty divert serves no purpose other than to say\n        // \"this choice is intentionally left blank\"\n        // (as an invisible default choice)\n        if (div && div.isEmpty) {\n          continue;\n        }\n\n        innerContent.AddContent(divObj);\n      }\n    }\n\n    // Terminate main content with a newline since this is the end of the line\n    // Note that this will be redundant if the diverts above definitely take\n    // the flow away permanently.\n    innerContent.AddContent(new Text(\"\\n\"));\n\n    const choice = new Choice(startContent!, optionOnlyContent!, innerContent);\n    if (optionalName) choice.identifier = optionalName;\n    choice.indentationDepth = bullets.length;\n    choice.hasWeaveStyleInlineBrackets = hasWeaveStyleInlineBrackets;\n    choice.condition = conditionExpr;\n    choice.onceOnly = onceOnlyChoice;\n    choice.isInvisibleDefault = emptyContent;\n    return choice;\n  };\n\n  public readonly ChoiceCondition = (): Expression | null => {\n    const conditions = this.Interleave<Expression>(\n      this.ChoiceSingleCondition,\n      this.ChoiceConditionsSpace\n    );\n\n    if (conditions === null) {\n      return null;\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    }\n\n    return new MultipleConditionExpression(conditions);\n  };\n\n  public readonly ChoiceConditionsSpace = (): typeof ParseSuccess => {\n    // Both optional\n    // Newline includes initial end of line whitespace\n    this.Newline();\n    this.Whitespace();\n\n    return ParseSuccess;\n  };\n\n  public readonly ChoiceSingleCondition = (): Expression | null => {\n    if (this.ParseString(\"{\") === null) {\n      return null;\n    }\n\n    const condExpr = this.Expect(\n      this.Expression,\n      \"choice condition inside { }\"\n    ) as Expression;\n\n    this.DisallowIncrement(condExpr);\n    this.Expect(this.String(\"}\"), \"closing '}' for choice condition\");\n\n    return condExpr;\n  };\n\n  public readonly Gather = (): Gather | null => {\n    const gatherDashCountObj: number = this.Parse(this.GatherDashes) as number;\n    if (gatherDashCountObj === null) {\n      return null;\n    }\n\n    const gatherDashCount: number = Number(gatherDashCountObj);\n\n    // Optional name for the gather\n    const optionalName: Identifier = this.Parse(\n      this.BracketedName\n    ) as Identifier;\n\n    const gather = new Gather(optionalName, gatherDashCount);\n\n    // Optional newline before gather's content begins\n    this.Newline();\n\n    return gather;\n  };\n\n  public readonly GatherDashes = (): number | null => {\n    this.Whitespace();\n\n    let gatherDashCount: number = 0;\n    while (this.ParseDashNotArrow() !== null) {\n      gatherDashCount += 1;\n      this.Whitespace();\n    }\n\n    if (gatherDashCount === 0) {\n      return null;\n    }\n\n    return gatherDashCount as number;\n  };\n\n  public readonly ParseDashNotArrow = () => {\n    const ruleId = this.BeginRule();\n\n    if (\n      this.ParseString(\"->\") === null &&\n      this.ParseSingleCharacter() === \"-\"\n    ) {\n      return this.SucceedRule(ruleId);\n    }\n\n    return this.FailRule(ruleId);\n  };\n\n  public readonly BracketedName = (): Identifier | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const name = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n    if (name === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing ')' for bracketed name\");\n\n    return name;\n  };\n\n  /**\n   * End Choices section.\n   */\n\n  /**\n   * Begin Conditional section.\n   */\n\n  public readonly InnerConditionalContent = (\n    initialQueryExpression: Expression\n  ): Conditional | null => {\n    if (initialQueryExpression === undefined) {\n      const initialQueryExpression = this.Parse(this.ConditionExpression);\n      const conditional = this.Parse(() =>\n        this.InnerConditionalContent(initialQueryExpression as Expression)\n      ) as Conditional;\n\n      if (conditional === null) {\n        return null;\n      }\n\n      return conditional;\n    }\n\n    let alternatives: ConditionalSingleBranch[] | null;\n    const canBeInline: boolean = initialQueryExpression !== null;\n    const isInline: boolean = this.Parse(this.Newline) === null;\n\n    if (isInline && !canBeInline) {\n      return null;\n    }\n\n    if (isInline) {\n      // Inline innards\n      alternatives = this.InlineConditionalBranches();\n    } else {\n      // Multiline innards\n      alternatives = this.MultilineConditionalBranches();\n\n      if (alternatives === null) {\n        // Allow single piece of content within multi-line expression, e.g.:\n        // { true:\n        //    Some content that isn't preceded by '-'\n        // }\n        if (initialQueryExpression) {\n          let soleContent: ParsedObject[] = this.StatementsAtLevel(\n            StatementLevel.InnerBlock\n          );\n          if (soleContent !== null) {\n            const soleBranch = new ConditionalSingleBranch(soleContent);\n            alternatives = [soleBranch];\n\n            // Also allow a final \"- else:\" clause\n            const elseBranch = this.Parse(\n              this.SingleMultilineCondition\n            ) as ConditionalSingleBranch;\n            if (elseBranch) {\n              if (!elseBranch.isElse) {\n                this.ErrorWithParsedObject(\n                  \"Expected an '- else:' clause here rather than an extra condition\",\n                  elseBranch\n                );\n\n                elseBranch.isElse = true;\n              }\n\n              alternatives.push(elseBranch);\n            }\n          }\n        }\n\n        // Still null?\n        if (alternatives === null) {\n          return null;\n        }\n      } else if (\n        alternatives.length === 1 &&\n        alternatives[0].isElse &&\n        initialQueryExpression\n      ) {\n        // Empty true branch - didn't get parsed, but should insert one for semantic correctness,\n        // and to make sure that any evaluation stack values get tidied up correctly.\n        const emptyTrueBranch = new ConditionalSingleBranch(null);\n        emptyTrueBranch.isTrueBranch = true;\n        alternatives.unshift(emptyTrueBranch);\n      }\n\n      // Like a switch statement\n      // { initialQueryExpression:\n      //    ... match the expression\n      // }\n      if (initialQueryExpression) {\n        let earlierBranchesHaveOwnExpression: boolean = false;\n        for (let ii = 0; ii < alternatives.length; ++ii) {\n          const branch = alternatives[ii];\n          const isLast: boolean = ii === alternatives.length - 1;\n\n          // Matching equality with initial query expression\n          // We set this flag even for the \"else\" clause so that\n          // it knows to tidy up the evaluation stack at the end\n\n          // Match query\n          if (branch.ownExpression) {\n            branch.matchingEquality = true;\n            earlierBranchesHaveOwnExpression = true;\n          } else if (earlierBranchesHaveOwnExpression && isLast) {\n            // Else (final branch)\n            branch.matchingEquality = true;\n            branch.isElse = true;\n          } else {\n            // Binary condition:\n            // { trueOrFalse:\n            //    - when true\n            //    - when false\n            // }\n            if (!isLast && alternatives.length > 2) {\n              this.ErrorWithParsedObject(\n                \"Only final branch can be an 'else'. Did you miss a ':'?\",\n                branch\n              );\n            } else {\n              if (ii === 0) {\n                branch.isTrueBranch = true;\n              } else {\n                branch.isElse = true;\n              }\n            }\n          }\n        }\n      } else {\n        // No initial query, so just a multi-line conditional. e.g.:\n        // {\n        //   - x > 3:  greater than three\n        //   - x == 3: equal to three\n        //   - x < 3:  less than three\n        // }\n\n        for (let ii = 0; ii < alternatives.length; ++ii) {\n          const alt = alternatives[ii];\n          const isLast: boolean = ii === alternatives.length - 1;\n\n          if (alt.ownExpression === null) {\n            if (isLast) {\n              alt.isElse = true;\n            } else {\n              if (alt.isElse) {\n                // Do we ALSO have a valid \"else\" at the end? Let's report the error there.\n                const finalClause = alternatives[alternatives.length - 1];\n                if (finalClause.isElse) {\n                  this.ErrorWithParsedObject(\n                    \"Multiple 'else' cases. Can have a maximum of one, at the end.\",\n                    finalClause\n                  );\n                } else {\n                  this.ErrorWithParsedObject(\n                    \"'else' case in conditional should always be the final one\",\n                    alt\n                  );\n                }\n              } else {\n                this.ErrorWithParsedObject(\n                  \"Branch doesn't have condition. Are you missing a ':'? \",\n                  alt\n                );\n              }\n            }\n          }\n        }\n\n        if (\n          alternatives.length === 1 &&\n          alternatives[0].ownExpression === null\n        ) {\n          this.ErrorWithParsedObject(\n            \"Condition block with no conditions\",\n            alternatives[0]\n          );\n        }\n      }\n    }\n\n    // TODO: Come up with water-tight error conditions... it's quite a flexible system!\n    // e.g.\n    //   - inline conditionals must have exactly 1 or 2 alternatives\n    //   - multiline expression shouldn't have mixed existence of branch-conditions?\n    if (alternatives === null) {\n      return null;\n    }\n\n    for (const branch of alternatives) {\n      branch.isInline = isInline;\n    }\n\n    const cond = new Conditional(initialQueryExpression, alternatives);\n\n    return cond;\n  };\n\n  public readonly InlineConditionalBranches = ():\n    | ConditionalSingleBranch[]\n    | null => {\n    const listOfLists = this.Interleave<ParsedObject[]>(\n      this.MixedTextAndLogic,\n      this.Exclude(this.String(\"|\")),\n      null,\n      false\n    );\n\n    if (listOfLists === null || listOfLists.length === 0) {\n      return null;\n    }\n\n    const result: ConditionalSingleBranch[] = [];\n\n    if (listOfLists.length > 2) {\n      this.Error(\n        \"Expected one or two alternatives separated by '|' in inline conditional\"\n      );\n    } else {\n      const trueBranch = new ConditionalSingleBranch(listOfLists[0]);\n      trueBranch.isTrueBranch = true;\n      result.push(trueBranch);\n\n      if (listOfLists.length > 1) {\n        const elseBranch = new ConditionalSingleBranch(listOfLists[1]);\n        elseBranch.isElse = true;\n        result.push(elseBranch);\n      }\n    }\n\n    return result;\n  };\n\n  public readonly MultilineConditionalBranches = ():\n    | ConditionalSingleBranch[]\n    | null => {\n    this.MultilineWhitespace();\n\n    const multipleConditions = this.OneOrMore(this.SingleMultilineCondition);\n    if (multipleConditions === null) {\n      return null;\n    }\n\n    this.MultilineWhitespace();\n\n    return multipleConditions as ConditionalSingleBranch[];\n  };\n\n  public readonly SingleMultilineCondition =\n    (): ConditionalSingleBranch | null => {\n      this.Whitespace();\n\n      if (\n        // Make sure we're not accidentally parsing a divert\n        this.ParseString(\"->\") !== null ||\n        this.ParseString(\"-\") === null\n      ) {\n        return null;\n      }\n\n      this.Whitespace();\n\n      let expr: Expression | null = null;\n      const isElse: boolean = this.Parse(this.ElseExpression) !== null;\n\n      if (!isElse) {\n        expr = this.Parse(this.ConditionExpression) as Expression;\n      }\n\n      let content: ParsedObject[] = this.StatementsAtLevel(\n        StatementLevel.InnerBlock\n      );\n      if (expr === null && content === null) {\n        this.Error(\"expected content for the conditional branch following '-'\");\n\n        // Recover\n        content = [new Text(\"\")];\n      }\n\n      // Allow additional multiline whitespace, if the statements were empty (valid)\n      // then their surrounding multiline whitespacce needs to be handled manually.\n      // e.g.\n      // { x:\n      //   - 1:    // intentionally left blank, but newline needs to be parsed\n      //   - 2: etc\n      // }\n      this.MultilineWhitespace();\n\n      const branch = new ConditionalSingleBranch(content);\n      branch.ownExpression = expr;\n      branch.isElse = isElse;\n\n      return branch;\n    };\n\n  public readonly ConditionExpression = (): ParsedObject | null => {\n    const expr = this.Parse(this.Expression) as ParsedObject;\n    if (expr === null) {\n      return null;\n    }\n\n    this.DisallowIncrement(expr);\n\n    this.Whitespace();\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    return expr;\n  };\n\n  public readonly ElseExpression = (): typeof ParseSuccess | null => {\n    if (this.ParseString(\"else\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    return ParseSuccess;\n  };\n\n  /**\n   * End Conditional section.\n   */\n\n  /**\n   * Begin Content section.\n   */\n\n  public _nonTextPauseCharacters: CharacterSet | null = null;\n  public _nonTextEndCharacters: CharacterSet | null = null;\n  public _notTextEndCharactersChoice: CharacterSet | null = null;\n  public _notTextEndCharactersString: CharacterSet | null = null;\n\n  public readonly TrimEndWhitespace = (\n    mixedTextAndLogicResults: ParsedObject[],\n    terminateWithSpace: boolean\n  ): void => {\n    // Trim whitespace from end\n    if (mixedTextAndLogicResults.length > 0) {\n      const lastObjIdx = mixedTextAndLogicResults.length - 1;\n      const lastObj = mixedTextAndLogicResults[lastObjIdx];\n      if (lastObj instanceof Text) {\n        const textObj: Text = lastObj;\n        textObj.text = textObj.text.replace(new RegExp(/[ \\t]+$/g), \"\");\n\n        if (terminateWithSpace) {\n          textObj.text += \" \";\n        } else if (textObj.text.length === 0) {\n          // No content left at all? trim the whole object\n          mixedTextAndLogicResults.splice(lastObjIdx, 1);\n\n          // Recurse in case there's more whitespace\n          this.TrimEndWhitespace(mixedTextAndLogicResults, false);\n        }\n      }\n    }\n  };\n\n  public readonly LineOfMixedTextAndLogic = (): ParsedObject[] | null => {\n    // Consume any whitespace at the start of the line\n    // (Except for escaped whitespace)\n    this.Parse(this.Whitespace);\n\n    let result: ParsedObject[] = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n\n    if (!result || !result.length) {\n      return null;\n    }\n\n    // Warn about accidentally writing \"return\" without \"~\"\n    const firstText = result[0] as Text;\n    if (firstText && firstText.text && firstText.text.startsWith(\"return\")) {\n      this.Warning(\n        \"Do you need a '~' before 'return'? If not, perhaps use a glue: <> (since it's lowercase) or rewrite somehow?\"\n      );\n    }\n\n    if (result.length === 0) {\n      return null;\n    }\n\n    const lastObj = result[result.length - 1];\n    if (!(lastObj instanceof Divert)) {\n      this.TrimEndWhitespace(result, false);\n    }\n\n    this.EndTagIfNecessary(result);\n\n    // If the line doens't actually contain any normal text content\n    // but is in fact entirely a tag, then let's not append\n    // a newline, since we want the tag (or tags) to be associated\n    // with the line below rather than being completely independent.\n    let lineIsPureTag =\n      result.length > 0 && result[0] instanceof Tag && result[0].isStart;\n\n    if (!lineIsPureTag) {\n      result.push(new Text(\"\\n\"));\n    }\n\n    this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n    return result;\n  };\n\n  public readonly MixedTextAndLogic = (): ParsedObject[] | null => {\n    // Check for disallowed \"~\" within this context\n    const disallowedTilde = this.ParseObject(this.Spaced(this.String(\"~\")));\n    if (disallowedTilde !== null) {\n      this.Error(\n        \"You shouldn't use a '~' here - tildas are for logic that's on its own line. To do inline logic, use { curly braces } instead\"\n      );\n    }\n\n    // Either, or both interleaved\n    let results: ParsedObject[] = this.Interleave<ParsedObject>(\n      this.Optional(this.ContentText),\n      this.Optional(this.InlineLogicOrGlueOrStartTag)\n    );\n\n    // Terminating divert?\n    // (When parsing content for the text of a choice, diverts aren't allowed.\n    //  The divert on the end of the body of a choice is handled specially.)\n    if (!this._parsingChoice) {\n      const diverts: ParsedObject[] = this.Parse(\n        this.MultiDivert\n      ) as ParsedObject[];\n      if (diverts !== null) {\n        // May not have had any results at all if there's *only* a divert!\n        if (results === null) {\n          results = [];\n        }\n\n        // End previously active tag if necessary\n        this.EndTagIfNecessary(results);\n\n        this.TrimEndWhitespace(results, true);\n\n        results.push(...diverts);\n      }\n    }\n\n    if (!results) {\n      return null;\n    }\n\n    return results;\n  };\n\n  public readonly ContentText = () => {\n    return this.ContentTextAllowingEscapeChar();\n  };\n\n  public readonly ContentTextAllowingEscapeChar = (): Text | null => {\n    let sb: string | null = null;\n\n    do {\n      let str = this.Parse(this.ContentTextNoEscape);\n      const gotEscapeChar: boolean = this.ParseString(\"\\\\\") !== null;\n\n      if (gotEscapeChar || str !== null) {\n        if (sb === null) {\n          sb = \"\";\n        }\n\n        if (str !== null) {\n          sb += String(str);\n        }\n\n        if (gotEscapeChar) {\n          const c: string = this.ParseSingleCharacter();\n          sb += c;\n        }\n      } else {\n        break;\n      }\n    } while (true);\n\n    if (sb !== null) {\n      return new Text(sb);\n    }\n\n    return null;\n  };\n\n  // Content text is an unusual parse rule compared with most since it's\n  // less about saying \"this is is the small selection of stuff that we parse\"\n  // and more \"we parse ANYTHING except this small selection of stuff\".\n  public readonly ContentTextNoEscape = (): string | null => {\n    // Eat through text, pausing at the following characters, and\n    // attempt to parse the nonTextRule.\n    // \"-\": possible start of divert or start of gather\n    // \"<\": possible start of glue\n    if (this._nonTextPauseCharacters === null) {\n      this._nonTextPauseCharacters = new CharacterSet(\"-<\");\n    }\n\n    // If we hit any of these characters, we stop *immediately* without bothering to even check the nonTextRule\n    // \"{\" for start of logic\n    // \"|\" for mid logic branch\n    if (this._nonTextEndCharacters === null) {\n      this._nonTextEndCharacters = new CharacterSet(\"{}|\\n\\r\\\\#\");\n      this._notTextEndCharactersChoice = new CharacterSet(\n        this._nonTextEndCharacters\n      );\n      this._notTextEndCharactersChoice.AddCharacters(\"[]\");\n      this._notTextEndCharactersString = new CharacterSet(\n        this._nonTextEndCharacters\n      );\n      this._notTextEndCharactersString.AddCharacters('\"');\n    }\n\n    // When the ParseUntil pauses, check these rules in case they evaluate successfully\n    const nonTextRule: ParseRule = () =>\n      this.OneOf([\n        this.ParseDivertArrow,\n        this.ParseThreadArrow,\n        this.EndOfLine,\n        this.Glue,\n      ]);\n\n    let endChars: CharacterSet | null = null;\n    if (this.parsingStringExpression) {\n      endChars = this._notTextEndCharactersString;\n    } else if (this._parsingChoice) {\n      endChars = this._notTextEndCharactersChoice;\n    } else {\n      endChars = this._nonTextEndCharacters;\n    }\n\n    const pureTextContent: string = this.ParseUntil(\n      nonTextRule,\n      this._nonTextPauseCharacters,\n      endChars\n    );\n\n    if (pureTextContent !== null) {\n      return pureTextContent;\n    }\n\n    return null;\n  };\n\n  /**\n   * End Content section.\n   */\n\n  /**\n   * Begin Divert section.\n   */\n\n  public readonly MultiDivert = (): ParsedObject[] | null => {\n    this.Whitespace();\n\n    let diverts: ParsedObject[] = [];\n\n    // Try single thread first\n    const threadDivert = this.Parse(this.StartThread) as ParsedObject;\n    if (threadDivert) {\n      diverts = [threadDivert];\n\n      return diverts;\n    }\n\n    // Normal diverts and tunnels\n    const arrowsAndDiverts = this.Interleave<ParsedObject>(\n      this.ParseDivertArrowOrTunnelOnwards,\n      this.DivertIdentifierWithArguments\n    );\n\n    if (!arrowsAndDiverts) {\n      return null;\n    }\n\n    diverts = [];\n\n    this.EndTagIfNecessary(diverts);\n\n    // Possible patterns:\n    //  ->                   -- explicit gather\n    //  ->->                 -- tunnel onwards\n    //  -> div               -- normal divert\n    //  ->-> div             -- tunnel onwards, followed by override divert\n    //  -> div ->            -- normal tunnel\n    //  -> div ->->          -- tunnel then tunnel continue\n    //  -> div -> div        -- tunnel then divert\n    //  -> div -> div ->     -- tunnel then tunnel\n    //  -> div -> div ->->\n    //  -> div -> div ->-> div    (etc)\n\n    // Look at the arrows and diverts\n    for (let ii = 0; ii < arrowsAndDiverts.length; ++ii) {\n      const isArrow: boolean = ii % 2 === 0;\n\n      // Arrow string\n      if (isArrow) {\n        // Tunnel onwards\n        if ((arrowsAndDiverts[ii] as any) === \"->->\") {\n          const tunnelOnwardsPlacementValid: boolean =\n            ii === 0 ||\n            ii === arrowsAndDiverts.length - 1 ||\n            ii === arrowsAndDiverts.length - 2;\n\n          if (!tunnelOnwardsPlacementValid) {\n            this.Error(\n              \"Tunnel onwards '->->' must only come at the begining or the start of a divert\"\n            );\n          }\n\n          const tunnelOnwards = new TunnelOnwards();\n          if (ii < arrowsAndDiverts.length - 1) {\n            const tunnelOnwardDivert = asOrNull(\n              arrowsAndDiverts[ii + 1],\n              Divert\n            );\n            tunnelOnwards.divertAfter = tunnelOnwardDivert;\n          }\n\n          diverts.push(tunnelOnwards);\n\n          // Not allowed to do anything after a tunnel onwards.\n          // If we had anything left it would be caused in the above Error for\n          // the positioning of a ->->\n          break;\n        }\n      } else {\n        // Divert\n        const divert = arrowsAndDiverts[ii] as Divert;\n        // More to come? (further arrows) Must be tunnelling.\n        if (ii < arrowsAndDiverts.length - 1) {\n          divert.isTunnel = true;\n        }\n\n        diverts.push(divert);\n      }\n    }\n\n    // Single -> (used for default choices)\n    if (diverts.length === 0 && arrowsAndDiverts.length === 1) {\n      const gatherDivert = new Divert(null);\n      gatherDivert.isEmpty = true;\n      diverts.push(gatherDivert);\n\n      if (!this._parsingChoice) {\n        this.Error(\"Empty diverts (->) are only valid on choices\");\n      }\n    }\n\n    return diverts;\n  };\n\n  public readonly StartThread = (): Divert | null => {\n    this.Whitespace();\n\n    if (this.ParseThreadArrow() === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const divert = this.Expect(\n      this.DivertIdentifierWithArguments,\n      \"target for new thread\",\n      () => new Divert(null)\n    ) as Divert;\n\n    divert.isThread = true;\n\n    return divert;\n  };\n\n  public readonly DivertIdentifierWithArguments = (): Divert | null => {\n    this.Whitespace();\n\n    const targetComponents: Identifier[] = this.Parse(\n      this.DotSeparatedDivertPathComponents\n    ) as Identifier[];\n\n    if (!targetComponents) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const optionalArguments = this.Parse(\n      this.ExpressionFunctionCallArguments\n    ) as Expression[];\n\n    this.Whitespace();\n\n    const targetPath = new Path(targetComponents);\n\n    return new Divert(targetPath, optionalArguments);\n  };\n\n  public readonly SingleDivert = (): Divert | null => {\n    const diverts = this.Parse(this.MultiDivert) as ParsedObject[];\n    if (!diverts) {\n      return null;\n    }\n\n    // Ideally we'd report errors if we get the\n    // wrong kind of divert, but unfortunately we\n    // have to hack around the fact that sequences use\n    // a very similar syntax.\n    // i.e. if you have a multi-divert at the start\n    // of a sequence, it initially tries to parse it\n    // as a divert target (part of an expression of\n    // a conditional) and gives errors. So instead\n    // we just have to blindly reject it as a single\n    // divert, and give a slightly less nice error\n    // when you DO use a multi divert as a divert taret.\n\n    if (diverts.length !== 1) {\n      return null;\n    }\n\n    const singleDivert = diverts[0];\n    if (singleDivert instanceof TunnelOnwards) {\n      return null;\n    }\n\n    const divert = diverts[0] as Divert;\n    if (divert.isTunnel) {\n      return null;\n    }\n\n    return divert;\n  };\n\n  public readonly DotSeparatedDivertPathComponents = (): Identifier[] =>\n    this.Interleave<Identifier>(\n      this.Spaced(this.IdentifierWithMetadata),\n      this.Exclude(this.String(\".\"))\n    );\n\n  public readonly ParseDivertArrowOrTunnelOnwards = (): string | null => {\n    let numArrows: number = 0;\n    while (this.ParseString(\"->\") !== null) {\n      numArrows += 1;\n    }\n\n    if (numArrows === 0) {\n      return null;\n    } else if (numArrows === 1) {\n      return \"->\";\n    } else if (numArrows === 2) {\n      return \"->->\";\n    }\n\n    this.Error(\n      \"Unexpected number of arrows in divert. Should only have '->' or '->->'\"\n    );\n\n    return \"->->\";\n  };\n\n  public readonly ParseDivertArrow = () => this.ParseString(\"->\");\n\n  public readonly ParseThreadArrow = () => this.ParseString(\"<-\");\n\n  /**\n   * End Divert section.\n   */\n\n  /**\n   * Begin Expressions section.\n   */\n\n  public _binaryOperators: InfixOperator[] = [];\n  public _maxBinaryOpLength: number = 0;\n\n  public readonly TempDeclarationOrAssignment = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const isNewDeclaration: boolean = this.ParseTempKeyword();\n\n    this.Whitespace();\n\n    let varIdentifier: Identifier | null = null;\n    if (isNewDeclaration) {\n      varIdentifier = this.Expect(\n        this.IdentifierWithMetadata,\n        \"variable name\"\n      ) as Identifier;\n    } else {\n      varIdentifier = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    }\n\n    if (varIdentifier === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // += -=\n    const isIncrement: boolean = this.ParseString(\"+\") !== null;\n    const isDecrement: boolean = this.ParseString(\"-\") !== null;\n\n    if (isIncrement && isDecrement) {\n      this.Error(\"Unexpected sequence '+-'\");\n    }\n\n    if (this.ParseString(\"=\") === null) {\n      // Definitely in an assignment expression?\n      if (isNewDeclaration) {\n        this.Error(\"Expected '='\");\n      }\n\n      return null;\n    }\n\n    const assignedExpression: Expression = this.Expect(\n      this.Expression,\n      \"value expression to be assigned\"\n    ) as Expression;\n\n    if (isIncrement || isDecrement) {\n      const result = new IncDecExpression(\n        varIdentifier,\n        assignedExpression,\n        isIncrement\n      );\n      return result;\n    }\n\n    const result = new VariableAssignment({\n      variableIdentifier: varIdentifier,\n      assignedExpression,\n      isTemporaryNewDeclaration: isNewDeclaration,\n    });\n\n    return result;\n  };\n\n  public readonly DisallowIncrement = (expr: ParsedObject): void => {\n    if (expr instanceof IncDecExpression) {\n      this.Error(\n        \"Can't use increment/decrement here. It can only be used on a ~ line\"\n      );\n    }\n  };\n\n  public readonly ParseTempKeyword = () => {\n    const ruleId = this.BeginRule();\n\n    if (this.Parse(this.Identifier) === \"temp\") {\n      this.SucceedRule(ruleId);\n      return true;\n    }\n\n    this.FailRule(ruleId);\n    return false;\n  };\n\n  public readonly ReturnStatement = (): ReturnType | null => {\n    this.Whitespace();\n\n    const returnOrDone = this.Parse(this.Identifier);\n    if (returnOrDone !== \"return\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const expr = this.Parse(this.Expression) as Expression;\n\n    const returnObj = new ReturnType(expr);\n\n    return returnObj;\n  };\n\n  // Pratt Parser\n  // aka \"Top down operator precedence parser\"\n  // http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n  // Algorithm overview:\n  // The two types of precedence are handled in two different ways:\n  //   ((((a . b) . c) . d) . e)\t\t\t#1\n  //   (a . (b . (c . (d . e))))\t\t\t#2\n  // Where #1 is automatically handled by successive loops within the main 'while' in this function,\n  // so long as continuing operators have lower (or equal) precedence (e.g. imagine some series of \"*\"s then \"+\" above.\n  // ...and #2 is handled by recursion of the right hand term in the binary expression parser.\n  // (see link for advice on how to extend for postfix and mixfix operators)\n  public readonly Expression = (\n    minimumPrecedence: number = 0\n  ): Expression | null => {\n    this.Whitespace();\n\n    // First parse a unary expression e.g. \"-a\" or parethensised \"(1 + 2)\"\n    let expr = this.ExpressionUnary();\n    if (expr === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Attempt to parse (possibly multiple) continuing infix expressions (e.g. 1 + 2 + 3)\n    while (true) {\n      const ruleId = this.BeginRule();\n\n      // Operator\n      const infixOp = this.ParseInfixOperator();\n      if (infixOp !== null && infixOp.precedence > minimumPrecedence) {\n        // Expect right hand side of operator\n        const expectationMessage = `right side of '${infixOp.type}' expression`;\n        const multiaryExpr = this.Expect(\n          () => this.ExpressionInfixRight(expr, infixOp),\n          expectationMessage\n        );\n\n        if (multiaryExpr === null) {\n          // Fail for operator and right-hand side of multiary expression\n          this.FailRule(ruleId);\n\n          return null;\n        }\n\n        expr = this.SucceedRule(ruleId, multiaryExpr) as Expression;\n\n        continue;\n      }\n\n      this.FailRule(ruleId);\n      break;\n    }\n\n    this.Whitespace();\n\n    return expr;\n  };\n\n  public readonly ExpressionUnary = (): Expression | null => {\n    // Divert target is a special case - it can't have any other operators\n    // applied to it, and we also want to check for it first so that we don't\n    // confuse \"->\" for subtraction.\n    const divertTarget = this.Parse(this.ExpressionDivertTarget) as Expression;\n    if (divertTarget !== null) {\n      return divertTarget;\n    }\n\n    let prefixOp: string = this.OneOf([\n      this.String(\"-\"),\n      this.String(\"!\"),\n    ]) as string;\n\n    // Don't parse like the string rules above, in case its actually\n    // a variable that simply starts with \"not\", e.g. \"notable\".\n    // This rule uses the Identifier rule, which will scan as much text\n    // as possible before returning.\n    if (prefixOp === null) {\n      prefixOp = this.Parse(this.ExpressionNot) as string;\n    }\n\n    this.Whitespace();\n\n    // - Since we allow numbers at the start of variable names, variable names are checked before literals\n    // - Function calls before variable names in case we see parentheses\n    let expr = this.OneOf([\n      this.ExpressionList,\n      this.ExpressionParen,\n      this.ExpressionFunctionCall,\n      this.ExpressionVariableName,\n      this.ExpressionLiteral,\n    ]) as Expression | null;\n\n    // Only recurse immediately if we have one of the (usually optional) unary ops\n    if (expr === null && prefixOp !== null) {\n      expr = this.ExpressionUnary();\n    }\n\n    if (expr === null) {\n      return null;\n    } else if (prefixOp !== null) {\n      expr = UnaryExpression.WithInner(expr, prefixOp) as Expression;\n    }\n\n    this.Whitespace();\n\n    const postfixOp = this.OneOf([this.String(\"++\"), this.String(\"--\")]);\n\n    if (postfixOp !== null) {\n      const isInc: boolean = postfixOp === \"++\";\n\n      if (!(expr instanceof VariableReference)) {\n        this.Error(\n          `can only increment and decrement variables, but saw '${expr}'.`\n        );\n\n        // Drop down and succeed without the increment after reporting error\n      } else {\n        const varRef = expr as VariableReference;\n        expr = new IncDecExpression(varRef.identifier, isInc);\n      }\n    }\n\n    return expr;\n  };\n\n  public readonly ExpressionNot = (): string | null => {\n    const id = this.Identifier();\n    if (id === \"not\") {\n      return id;\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionLiteral = (): Expression =>\n    this.OneOf([\n      this.ExpressionFloat,\n      this.ExpressionInt,\n      this.ExpressionBool,\n      this.ExpressionString,\n    ]) as Expression;\n\n  public readonly ExpressionDivertTarget = (): Expression | null => {\n    this.Whitespace();\n\n    const divert = this.Parse(this.SingleDivert) as Divert;\n    if (!divert || (divert && divert.isThread)) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    return new DivertTarget(divert);\n  };\n\n  public readonly ExpressionInt = (): NumberExpression | null => {\n    const intOrNull: number = this.ParseInt() as number;\n    if (intOrNull === null) {\n      return null;\n    }\n\n    return new NumberExpression(intOrNull, \"int\");\n  };\n\n  public readonly ExpressionFloat = (): NumberExpression | null => {\n    const floatOrNull: number = this.ParseFloat() as number;\n    if (floatOrNull === null) {\n      return null;\n    }\n\n    return new NumberExpression(floatOrNull, \"float\");\n  };\n\n  public readonly ExpressionString = (): StringExpression | null => {\n    const openQuote = this.ParseString('\"');\n    if (openQuote === null) {\n      return null;\n    }\n\n    // Set custom parser state flag so that within the text parser,\n    // it knows to treat the quote character (\") as an end character\n    this.parsingStringExpression = true;\n\n    let textAndLogic: ParsedObject[] = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n\n    this.Expect(this.String('\"'), \"close quote for string expression\");\n\n    this.parsingStringExpression = false;\n\n    if (textAndLogic === null) {\n      textAndLogic = [new Text(\"\")];\n    } else if (textAndLogic.find((c) => c instanceof Divert)) {\n      this.Error(\"String expressions cannot contain diverts (->)\");\n    }\n\n    return new StringExpression(textAndLogic);\n  };\n\n  public readonly ExpressionBool = (): NumberExpression | null => {\n    const id = this.Parse(this.Identifier);\n    if (id === \"true\") {\n      return new NumberExpression(true, \"bool\");\n    } else if (id === \"false\") {\n      return new NumberExpression(false, \"bool\");\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionFunctionCall = (): Expression | null => {\n    const iden = this.Parse(this.IdentifierWithMetadata);\n    if (iden === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const args = this.Parse(\n      this.ExpressionFunctionCallArguments\n    ) as Expression[];\n    if (args === null) {\n      return null;\n    }\n\n    return new FunctionCall(iden as Identifier, args);\n  };\n\n  public readonly ExpressionFunctionCallArguments = (): Expression[] | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    // \"Exclude\" requires the rule to succeed, but causes actual comma string to be excluded from the list of results\n    const commas: ParseRule = this.Exclude(this.String(\",\"));\n    let args = this.Interleave<Expression>(this.Expression, commas);\n    if (args === null) {\n      args = [];\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing ')' for function call\");\n\n    return args;\n  };\n\n  public readonly ExpressionVariableName = (): Expression | null => {\n    const path = this.Interleave<Identifier>(\n      this.IdentifierWithMetadata,\n      this.Exclude(this.Spaced(this.String(\".\")))\n    );\n\n    if (path === null || Story.IsReservedKeyword(path[0].name)) {\n      return null;\n    }\n\n    return new VariableReference(path);\n  };\n\n  public readonly ExpressionParen = (): Expression | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    const innerExpr = this.Parse(this.Expression) as Expression;\n    if (innerExpr === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing parenthesis ')' for expression\");\n\n    return innerExpr;\n  };\n\n  public readonly ExpressionInfixRight = (\n    left: Expression | null,\n    op: InfixOperator\n  ) => {\n    if (!left) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const right = this.Parse(() =>\n      this.Expression(op.precedence)\n    ) as Expression;\n    if (right) {\n      // We assume that the character we use for the operator's type is the same\n      // as that used internally by e.g. Runtime.Expression.Add, Runtime.Expression.Multiply etc\n      const expr = new BinaryExpression(left, right, op.type);\n      return expr;\n    }\n\n    return null;\n  };\n\n  private readonly ParseInfixOperator = (): InfixOperator | null => {\n    for (const op of this._binaryOperators) {\n      const ruleId: number = this.BeginRule();\n\n      if (this.ParseString(op.type) !== null) {\n        if (op.requireWhitespace) {\n          if (this.Whitespace() === null) {\n            this.FailRule(ruleId);\n\n            continue;\n          }\n        }\n\n        return this.SucceedRule(ruleId, op) as InfixOperator;\n      }\n\n      this.FailRule(ruleId);\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionList = (): List | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // When list has:\n    //  - 0 elements (null list) - this is okay, it's an empty list: \"()\"\n    //  - 1 element - it could be confused for a single non-list related\n    //    identifier expression in brackets, but this is a useless thing\n    //    to do, so we reserve that syntax for a list with one item.\n    //  - 2 or more elements - normal!\n    const memberNames: Identifier[] = this.SeparatedList(\n      this.ListMember,\n      this.Spaced(this.String(\",\"))\n    ) as Identifier[];\n\n    this.Whitespace();\n\n    // May have failed to parse the inner list - the parentheses may\n    // be for a normal expression\n    if (this.ParseString(\")\") === null) {\n      return null;\n    }\n    return new List(memberNames);\n  };\n\n  public readonly ListMember = (): Identifier | null => {\n    this.Whitespace();\n\n    let identifier: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    if (identifier === null) {\n      return null;\n    }\n\n    const dot = this.ParseString(\".\");\n    if (dot !== null) {\n      const identifier2: Identifier = this.Expect(\n        this.IdentifierWithMetadata,\n        `element name within the set ${identifier}`\n      ) as Identifier;\n\n      identifier.name += `.${identifier2?.name}`;\n    }\n\n    this.Whitespace();\n\n    return identifier;\n  };\n\n  public readonly RegisterExpressionOperators = () => {\n    // These will be tried in order, so we need \"<=\" before \"<\"\n    // for correctness\n\n    this.RegisterBinaryOperator(\"&&\", 1);\n    this.RegisterBinaryOperator(\"||\", 1);\n    this.RegisterBinaryOperator(\"and\", 1, true);\n    this.RegisterBinaryOperator(\"or\", 1, true);\n    this.RegisterBinaryOperator(\"==\", 2);\n    this.RegisterBinaryOperator(\">=\", 2);\n    this.RegisterBinaryOperator(\"<=\", 2);\n    this.RegisterBinaryOperator(\"<\", 2);\n    this.RegisterBinaryOperator(\">\", 2);\n    this.RegisterBinaryOperator(\"!=\", 2);\n\n    // (apples, oranges) + cabbages has (oranges, cabbages) === true\n    this.RegisterBinaryOperator(\"?\", 3);\n    this.RegisterBinaryOperator(\"has\", 3, true);\n    this.RegisterBinaryOperator(\"!?\", 3);\n    this.RegisterBinaryOperator(\"hasnt\", 3, true);\n    this.RegisterBinaryOperator(\"^\", 3);\n\n    this.RegisterBinaryOperator(\"+\", 4);\n    this.RegisterBinaryOperator(\"-\", 5);\n    this.RegisterBinaryOperator(\"*\", 6);\n    this.RegisterBinaryOperator(\"/\", 7);\n\n    this.RegisterBinaryOperator(\"%\", 8);\n    this.RegisterBinaryOperator(\"mod\", 8, true);\n  };\n\n  public readonly RegisterBinaryOperator = (\n    op: string,\n    precedence: number,\n    requireWhitespace: boolean = false\n  ): void => {\n    const infix = new InfixOperator(op, precedence, requireWhitespace);\n    this._binaryOperators.push(infix);\n    this._maxBinaryOpLength = Math.max(this._maxBinaryOpLength, op.length);\n  };\n\n  /**\n   * End Expressions section.\n   */\n\n  /**\n   * Begin Include section.\n   */\n\n  private _rootParser: InkParser;\n  private _openFilenames: string[] = [];\n\n  public readonly IncludeStatement = () => {\n    this.Whitespace();\n\n    if (this.ParseString(\"INCLUDE\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    let filename: string = this.Expect(\n      () => this.ParseUntilCharactersFromString(\"\\n\\r\"),\n      \"filename for include statement\"\n    ) as string;\n\n    filename = filename.replace(new RegExp(/[ \\t]+$/g), \"\");\n\n    // Working directory should already have been set up relative to the root ink file.\n    const fullFilename = this.fileHandler.ResolveInkFilename(filename);\n\n    if (this.FilenameIsAlreadyOpen(fullFilename)) {\n      this.Error(\n        `Recursive INCLUDE detected: '${fullFilename}' is already open.`\n      );\n      this.ParseUntilCharactersFromString(\"\\r\\n\");\n      return new IncludedFile(null);\n    } else {\n      this.AddOpenFilename(fullFilename);\n    }\n\n    let includedStory: Story | null = null;\n    let includedString: string = \"\";\n    try {\n      includedString =\n        this._rootParser.fileHandler.LoadInkFileContents(fullFilename);\n    } catch (err) {\n      this.Error(`Failed to load: '${filename}'.\\nError:${err}`);\n    }\n\n    if (includedString != null) {\n      const parser: InkParser = new InkParser(\n        includedString,\n        filename,\n        this._externalErrorHandler,\n        this._rootParser,\n        this.fileHandler\n      );\n\n      includedStory = parser.ParseStory();\n    }\n\n    this.RemoveOpenFilename(fullFilename);\n\n    // Return valid IncludedFile object even if there were errors when parsing.\n    // We don't want to attempt to re-parse the include line as something else,\n    // and we want to include the bits that *are* valid, so we don't generate\n    // more errors than necessary.\n    return new IncludedFile(includedStory);\n  };\n\n  public readonly FilenameIsAlreadyOpen = (fullFilename: string): boolean =>\n    this._rootParser._openFilenames.includes(fullFilename);\n\n  public readonly AddOpenFilename = (fullFilename: string): void => {\n    this._rootParser._openFilenames.push(fullFilename);\n  };\n\n  public readonly RemoveOpenFilename = (fullFilename: string) => {\n    this._rootParser._openFilenames.splice(\n      this._rootParser._openFilenames.indexOf(fullFilename),\n      1\n    );\n  };\n\n  /**\n   * End Include section.\n   */\n\n  /**\n   * Begin Knot section.\n   */\n\n  public readonly KnotDefinition = (): Knot | null => {\n    const knotDecl: FlowDecl = this.Parse(this.KnotDeclaration) as FlowDecl;\n    if (knotDecl === null) {\n      return null;\n    }\n\n    this.Expect(\n      this.EndOfLine,\n      \"end of line after knot name definition\",\n      this.SkipToNextLine\n    );\n\n    const innerKnotStatements: ParseRule = (): ParsedObject[] =>\n      this.StatementsAtLevel(StatementLevel.Knot);\n\n    const content = this.Expect(\n      innerKnotStatements,\n      \"at least one line within the knot\",\n      this.KnotStitchNoContentRecoveryRule\n    ) as ParsedObject[];\n\n    return new Knot(knotDecl.name, content, knotDecl.args, knotDecl.isFunction);\n  };\n\n  public readonly KnotDeclaration = (): FlowDecl | null => {\n    this.Whitespace();\n\n    if (this.KnotTitleEquals() === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const identifier: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    let knotName: Identifier;\n\n    const isFunc: boolean = identifier?.name === \"function\";\n    if (isFunc) {\n      this.Expect(this.Whitespace, \"whitespace after the 'function' keyword\");\n\n      knotName = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    } else {\n      knotName = identifier;\n    }\n\n    if (knotName === null) {\n      this.Error(`Expected the name of the ${isFunc ? \"function\" : \"knot\"}`);\n      knotName = new Identifier(\"\"); // prevent later null ref\n    }\n\n    this.Whitespace();\n\n    const parameterNames: Argument[] = this.Parse(\n      this.BracketedKnotDeclArguments\n    ) as Argument[];\n\n    this.Whitespace();\n\n    // Optional equals after name\n    this.Parse(this.KnotTitleEquals);\n\n    return new FlowDecl(knotName, parameterNames, isFunc);\n  };\n\n  public readonly KnotTitleEquals = (): string | null => {\n    // 2+ \"=\" starts a knot\n    const multiEquals = this.ParseCharactersFromString(\"=\");\n    if (multiEquals === null || multiEquals.length <= 1) {\n      return null;\n    }\n\n    return multiEquals;\n  };\n\n  public readonly StitchDefinition = (): ParseRuleReturn => {\n    const decl = this.Parse(this.StitchDeclaration) as FlowDecl;\n    if (decl === null) {\n      return null;\n    }\n\n    this.Expect(\n      this.EndOfLine,\n      \"end of line after stitch name\",\n      this.SkipToNextLine\n    );\n\n    const innerStitchStatements: ParseRule = () =>\n      this.StatementsAtLevel(StatementLevel.Stitch);\n\n    const content = this.Expect(\n      innerStitchStatements,\n      \"at least one line within the stitch\",\n      this.KnotStitchNoContentRecoveryRule\n    ) as ParsedObject[];\n\n    return new Stitch(decl.name, content, decl.args, decl.isFunction);\n  };\n\n  public readonly StitchDeclaration = (): FlowDecl | null => {\n    this.Whitespace();\n\n    // Single \"=\" to define a stitch\n    if (this.ParseString(\"=\") === null) {\n      return null;\n    }\n\n    // If there's more than one \"=\", that's actually a knot definition (or divert), so this rule should fail\n    if (this.ParseString(\"=\") !== null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Stitches aren't allowed to be functions, but we parse it anyway and report the error later\n    const isFunc: boolean = this.ParseString(\"function\") !== null;\n    if (isFunc) {\n      this.Whitespace();\n    }\n\n    const stitchName: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    if (stitchName === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const flowArgs: Argument[] = this.Parse(\n      this.BracketedKnotDeclArguments\n    ) as Argument[];\n\n    this.Whitespace();\n\n    return new FlowDecl(stitchName, flowArgs, isFunc);\n  };\n\n  public readonly KnotStitchNoContentRecoveryRule = (): ParseRuleReturn => {\n    // Jump ahead to the next knot or the end of the file\n    this.ParseUntil(this.KnotDeclaration, new CharacterSet(\"=\"), null);\n\n    const recoveredFlowContent: ParsedObject[] = [new Text(\"<ERROR IN FLOW>\")];\n\n    return recoveredFlowContent;\n  };\n\n  public readonly BracketedKnotDeclArguments = (): Argument[] | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    let flowArguments = this.Interleave<Argument>(\n      this.Spaced(this.FlowDeclArgument),\n      this.Exclude(this.String(\",\"))\n    );\n\n    this.Expect(this.String(\")\"), \"closing ')' for parameter list\");\n\n    // If no parameters, create an empty list so that this method is type safe and\n    // doesn't attempt to return the ParseSuccess object\n    if (flowArguments === null) {\n      flowArguments = [];\n    }\n\n    return flowArguments;\n  };\n\n  public readonly FlowDeclArgument = (): Argument | null => {\n    // Possible forms:\n    //  name\n    //  -> name      (variable divert target argument\n    //  ref name\n    //  ref -> name  (variable divert target by reference)\n    const firstIden = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    this.Whitespace();\n\n    const divertArrow = this.ParseDivertArrow();\n\n    this.Whitespace();\n\n    const secondIden = this.Parse(this.IdentifierWithMetadata) as Identifier;\n\n    if (firstIden == null && secondIden === null) {\n      return null;\n    }\n\n    const flowArg = new Argument();\n    if (divertArrow !== null) {\n      flowArg.isDivertTarget = true;\n    }\n\n    // Passing by reference\n    if (firstIden !== null && firstIden.name === \"ref\") {\n      if (secondIden === null) {\n        this.Error(\"Expected an parameter name after 'ref'\");\n      }\n\n      flowArg.identifier = secondIden;\n      flowArg.isByReference = true;\n    } else {\n      // Simple argument name\n      if (flowArg.isDivertTarget) {\n        flowArg.identifier = secondIden;\n      } else {\n        flowArg.identifier = firstIden;\n      }\n\n      if (flowArg.identifier === null) {\n        this.Error(\"Expected an parameter name\");\n      }\n\n      flowArg.isByReference = false;\n    }\n\n    return flowArg;\n  };\n\n  public readonly ExternalDeclaration = (): ExternalDeclaration | null => {\n    this.Whitespace();\n\n    const external = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier | null;\n    if (external === null || external.name != \"EXTERNAL\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const funcIdentifier: Identifier =\n      (this.Expect(\n        this.IdentifierWithMetadata,\n        \"name of external function\"\n      ) as Identifier | null) || new Identifier(\"\");\n\n    this.Whitespace();\n\n    let parameterNames = this.Expect(\n      this.BracketedKnotDeclArguments,\n      `declaration of arguments for EXTERNAL, even if empty, i.e. 'EXTERNAL ${funcIdentifier}()'`\n    ) as Argument[];\n\n    if (parameterNames === null) {\n      parameterNames = [];\n    }\n\n    const argNames = parameterNames\n      .map((arg) => arg.identifier?.name)\n      .filter(filterUndef);\n\n    return new ExternalDeclaration(funcIdentifier, argNames);\n  };\n\n  /**\n   * End Knot section.\n   */\n\n  /**\n   * Start Logic section.\n   */\n\n  private _identifierCharSet: CharacterSet | null = null;\n\n  get identifierCharSet(): CharacterSet {\n    if (this._identifierCharSet === null) {\n      (this._identifierCharSet = new CharacterSet())\n        .AddRange(\"A\", \"Z\")\n        .AddRange(\"a\", \"z\")\n        .AddRange(\"0\", \"9\")\n        .Add(\"_\");\n\n      // Enable non-ASCII characters for story identifiers.\n      this.ExtendIdentifierCharacterRanges(this._identifierCharSet);\n    }\n\n    return this._identifierCharSet;\n  }\n\n  public readonly LogicLine = (): ParsedObject | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"~\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Some example lines we need to be able to distinguish between:\n    // ~ temp x = 5  -- var decl + assign\n    // ~ temp x      -- var decl\n    // ~ x = 5       -- var assign\n    // ~ x           -- expr (not var decl or assign)\n    // ~ f()         -- expr\n    // We don't treat variable decl/assign as an expression since we don't want an assignment\n    // to have a return value, or to be used in compound expressions.\n    const afterTilde: ParseRule = () =>\n      this.OneOf([\n        this.ReturnStatement,\n        this.TempDeclarationOrAssignment,\n        this.Expression,\n      ]);\n\n    let result = this.Expect(\n      afterTilde,\n      \"expression after '~'\",\n      this.SkipToNextLine\n    ) as ParsedObject;\n\n    // Prevent further errors, already reported expected expression and have skipped to next line.\n    if (result === null) {\n      return new ContentList();\n    }\n\n    // Parse all expressions, but tell the writer off if they did something useless like:\n    //  ~ 5 + 4\n    // And even:\n    //  ~ false && myFunction()\n    // ...since it's bad practice, and won't do what they expect if\n    // they're expecting C's lazy evaluation.\n    if (\n      result instanceof Expression &&\n      !(result instanceof FunctionCall || result instanceof IncDecExpression)\n    ) {\n      this.Error(\n        \"Logic following a '~' can't be that type of expression. It can only be something like:\\n\\t~ return\\n\\t~ var x = blah\\n\\t~ x++\\n\\t~ myFunction()\"\n      );\n    }\n\n    // Line is pure function call? e.g.\n    //  ~ f()\n    // Add extra pop to make sure we tidy up after ourselves.\n    // We no longer need anything on the evaluation stack.\n    const funCall = asOrNull(result, FunctionCall);\n    if (funCall) {\n      funCall.shouldPopReturnedValue = true;\n    }\n\n    // If the expression contains a function call, then it could produce a text side effect,\n    // in which case it needs a newline on the end. e.g.\n    //  ~ printMyName()\n    //  ~ x = 1 + returnAValueAndAlsoPrintStuff()\n    // If no text gets printed, then the extra newline will have to be culled later.\n    // Multiple newlines on the output will be removed, so there will be no \"leak\" for\n    // long running calculations. It's disappointingly messy though :-/\n    if (result.Find(FunctionCall)() !== null) {\n      result = new ContentList(\n        result as unknown as ParsedObject[],\n        new Text(\"\\n\")\n      );\n    }\n\n    this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n\n    return result as ParsedObject;\n  };\n\n  public readonly VariableDeclaration = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id !== \"VAR\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"variable name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\"\n    );\n\n    this.Whitespace();\n\n    const definition = this.Expect(this.Expression, \"initial value for \");\n\n    const expr = definition as Expression;\n\n    if (expr) {\n      const check =\n        expr instanceof NumberExpression ||\n        expr instanceof StringExpression ||\n        expr instanceof DivertTarget ||\n        expr instanceof VariableReference ||\n        expr instanceof List;\n\n      if (!check) {\n        this.Error(\n          \"initial value for a variable must be a number, constant, list or divert target\"\n        );\n      }\n\n      if (this.Parse(this.ListElementDefinitionSeparator) !== null) {\n        this.Error(\n          \"Unexpected ','. If you're trying to declare a new list, use the LIST keyword, not VAR\"\n        );\n      } else if (expr instanceof StringExpression) {\n        // Ensure string expressions are simple\n        const strExpr = expr as StringExpression;\n        if (!strExpr.isSingleString) {\n          this.Error(\"Constant strings cannot contain any logic.\");\n        }\n      }\n\n      const result = new VariableAssignment({\n        assignedExpression: expr,\n        isGlobalDeclaration: true,\n        variableIdentifier: varName,\n      });\n\n      return result;\n    }\n\n    return null;\n  };\n\n  public readonly ListDeclaration = (): VariableAssignment | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id != \"LIST\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"list name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of the list definition\"\n    );\n\n    this.Whitespace();\n\n    const definition = this.Expect(\n      this.ListDefinition,\n      \"list item names\"\n    ) as ListDefinition;\n\n    if (definition) {\n      definition.identifier = new Identifier(varName.name);\n      return new VariableAssignment({\n        variableIdentifier: varName,\n        listDef: definition,\n      });\n    }\n\n    return null;\n  };\n\n  public readonly ListDefinition = (): ListDefinition | null => {\n    this.AnyWhitespace();\n\n    const allElements = this.SeparatedList(\n      this.ListElementDefinition,\n      this.ListElementDefinitionSeparator\n    ) as ListElementDefinition[];\n\n    if (allElements === null) {\n      return null;\n    }\n\n    return new ListDefinition(allElements);\n  };\n\n  public readonly ListElementDefinitionSeparator = (): string | null => {\n    this.AnyWhitespace();\n\n    if (this.ParseString(\",\") === null) {\n      return null;\n    }\n\n    this.AnyWhitespace();\n\n    return \",\";\n  };\n\n  public readonly ListElementDefinition = () => {\n    const inInitialList = this.ParseString(\"(\") !== null;\n    let needsToCloseParen = inInitialList;\n\n    this.Whitespace();\n\n    const name = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n    if (name === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    if (inInitialList) {\n      if (this.ParseString(\")\") != null) {\n        needsToCloseParen = false;\n        this.Whitespace();\n      }\n    }\n\n    let elementValue: number | null = null;\n    if (this.ParseString(\"=\") !== null) {\n      this.Whitespace();\n\n      const elementValueNum = this.Expect(\n        this.ExpressionInt,\n        \"value to be assigned to list item\"\n      ) as NumberExpression;\n\n      if (elementValueNum !== null) {\n        elementValue = elementValueNum.value as number;\n      }\n\n      if (needsToCloseParen) {\n        this.Whitespace();\n\n        if (this.ParseString(\")\") !== null) {\n          needsToCloseParen = false;\n        }\n      }\n    }\n\n    if (needsToCloseParen) {\n      this.Error(\"Expected closing ')'\");\n    }\n\n    return new ListElementDefinition(name, inInitialList, elementValue);\n  };\n\n  public readonly ConstDeclaration = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id !== \"CONST\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"constant name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\"\n    );\n\n    this.Whitespace();\n\n    const expr = this.Expect(\n      this.Expression,\n      \"initial value for \"\n    ) as Expression;\n\n    const check =\n      expr instanceof NumberExpression ||\n      expr instanceof DivertTarget ||\n      expr instanceof StringExpression;\n\n    if (!check) {\n      this.Error(\n        \"initial value for a constant must be a number or divert target\"\n      );\n    } else if (expr instanceof StringExpression) {\n      // Ensure string expressions are simple\n      const strExpr = expr as StringExpression;\n      if (!strExpr.isSingleString) {\n        this.Error(\"Constant strings cannot contain any logic.\");\n      }\n    }\n\n    const result = new ConstantDeclaration(varName, expr);\n\n    return result;\n  };\n\n  public readonly InlineLogicOrGlueOrStartTag = (): ParsedObject =>\n    this.OneOf([this.InlineLogic, this.Glue, this.StartTag]) as ParsedObject;\n\n  public readonly Glue = (): Glue | null => {\n    // Don't want to parse whitespace, since it might be important\n    // surrounding the glue.\n    const glueStr = this.ParseString(\"<>\");\n    if (glueStr !== null) {\n      return new Glue(new RuntimeGlue());\n    }\n\n    return null;\n  };\n\n  public readonly InlineLogic = () => {\n    if (this.ParseString(\"{\") === null) {\n      return null;\n    }\n\n    let wasParsingString = this.parsingStringExpression;\n    let wasTagActive = this.tagActive;\n\n    this.Whitespace();\n\n    const logic = this.Expect(\n      this.InnerLogic,\n      \"some kind of logic, conditional or sequence within braces: { ... }\"\n    ) as ParsedObject;\n\n    if (logic === null) {\n      this.parsingStringExpression = wasParsingString;\n      return null;\n    }\n\n    this.DisallowIncrement(logic);\n\n    let contentList = asOrNull(logic, ContentList);\n    if (!contentList) {\n      contentList = new ContentList(logic as unknown as ParsedObject[]);\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\"}\"), \"closing brace '}' for inline logic\");\n\n    // Allow nested strings and logic\n    this.parsingStringExpression = wasParsingString;\n\n    // Difference between:\n    //\n    //     1) A thing # {image}.jpg\n    //     2) A {red #red|blue #blue} sequence.\n    //\n    //  When logic ends in (1) we still want tag to continue.\n    //  When logic ends in (2) we want to auto-end the tag.\n    //  Side note: we simply disallow tags within strings.\n    if (!wasTagActive) this.EndTagIfNecessary(contentList);\n\n    return contentList;\n  };\n\n  public readonly InnerLogic = (): ParsedObject | null => {\n    this.Whitespace();\n\n    // Explicitly try the combinations of inner logic\n    // that could potentially have conflicts first.\n\n    // Explicit sequence annotation?\n    const explicitSeqType: SequenceType = this.ParseObject(\n      this.SequenceTypeAnnotation\n    ) as SequenceType;\n\n    if (explicitSeqType !== null) {\n      const contentLists = this.Expect(\n        this.InnerSequenceObjects,\n        \"sequence elements (for cycle/stoping etc)\"\n      ) as ContentList[];\n\n      if (contentLists === null) {\n        return null;\n      }\n\n      return new Sequence(contentLists, explicitSeqType);\n    }\n\n    // Conditional with expression?\n    const initialQueryExpression = this.Parse(\n      this.ConditionExpression\n    ) as Expression;\n    if (initialQueryExpression) {\n      const conditional = this.Expect(\n        () => this.InnerConditionalContent(initialQueryExpression),\n        \"conditional content following query\"\n      ) as Conditional;\n\n      return conditional;\n    }\n\n    // Now try to evaluate each of the \"full\" rules in turn\n    const rules: ParseRule[] = [\n      // Conditional still necessary, since you can have a multi-line conditional\n      // without an initial query expression:\n      // {\n      //   - true:  this is true\n      //   - false: this is false\n      // }\n      this.InnerConditionalContent as ParseRule,\n      this.InnerSequence,\n      this.InnerExpression,\n    ];\n\n    //let wasTagActiveAtStartOfScope = this.tagActive;\n\n    // Adapted from \"OneOf\" structuring rule except that in\n    // order for the rule to succeed, it has to maximally\n    // cover the entire string within the { }. Used to\n    // differentiate between:\n    //  {myVar}                 -- Expression (try first)\n    //  {my content is jolly}   -- sequence with single element\n    for (const rule of rules) {\n      const ruleId: number = this.BeginRule();\n\n      const result: ParsedObject = this.ParseObject(rule) as ParsedObject;\n      if (result) {\n        // Not yet at end?\n        if (this.Peek(this.Spaced(this.String(\"}\"))) === null) {\n          this.FailRule(ruleId);\n        } else {\n          // Full parse of content within braces\n          return this.SucceedRule(ruleId, result) as ParsedObject;\n        }\n      } else {\n        this.FailRule(ruleId);\n      }\n    }\n\n    return null;\n  };\n\n  public readonly InnerExpression = (): ParsedObject => {\n    const expr = this.Parse(this.Expression) as Expression;\n    if (expr) {\n      expr.outputWhenComplete = true;\n    }\n\n    return expr;\n  };\n\n  public readonly IdentifierWithMetadata = (): Identifier | null => {\n    const id = this.Identifier();\n    if (id === null) {\n      return null;\n    }\n    return new Identifier(id);\n  };\n\n  // Note: we allow identifiers that start with a number,\n  // but not if they *only* comprise numbers\n  public readonly Identifier = (): string | null => {\n    // Parse remaining characters (if any)\n    const name = this.ParseCharactersFromCharSet(this.identifierCharSet);\n    if (name === null) {\n      return null;\n    }\n\n    // Reject if it's just a number\n    let isNumberCharsOnly: boolean = true;\n    for (let c of name) {\n      if (!(c >= \"0\" && c <= \"9\")) {\n        isNumberCharsOnly = false;\n        break;\n      }\n    }\n\n    if (isNumberCharsOnly) {\n      return null;\n    }\n\n    return name;\n  };\n\n  /**\n   * End Logic section.\n   */\n\n  /**\n   * Begin Sequences section.\n   */\n\n  public _sequenceTypeSymbols: CharacterSet = new CharacterSet(\"!&~$\");\n\n  public readonly InnerSequence = (): Sequence | null => {\n    this.Whitespace();\n\n    // Default sequence type\n    let seqType: SequenceType = SequenceType.Stopping;\n\n    // Optional explicit sequence type\n    const parsedSeqType: SequenceType = this.Parse(\n      this.SequenceTypeAnnotation\n    ) as SequenceType;\n\n    if (parsedSeqType !== null) {\n      seqType = parsedSeqType;\n    }\n\n    const contentLists = this.Parse(this.InnerSequenceObjects) as ContentList[];\n    if (contentLists === null || contentLists.length <= 1) {\n      return null;\n    }\n\n    return new Sequence(contentLists, seqType);\n  };\n\n  public readonly SequenceTypeAnnotation = (): ParseRuleReturn => {\n    let annotation = this.Parse(\n      this.SequenceTypeSymbolAnnotation\n    ) as SequenceType;\n\n    if (annotation === null) {\n      annotation = this.Parse(this.SequenceTypeWordAnnotation) as SequenceType;\n    }\n\n    if (annotation === null) {\n      return null;\n    }\n\n    switch (annotation) {\n      case SequenceType.Once:\n      case SequenceType.Cycle:\n      case SequenceType.Stopping:\n      case SequenceType.Shuffle:\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n      case SequenceType.Shuffle | SequenceType.Stopping:\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n      case SequenceType.Shuffle | SequenceType.Once:\n        break;\n      default:\n        this.Error(`Sequence type combination not supported: ${annotation}`);\n        return SequenceType.Stopping;\n    }\n\n    return annotation;\n  };\n\n  public readonly SequenceTypeSymbolAnnotation = (): ParseRuleReturn => {\n    if (this._sequenceTypeSymbols === null) {\n      this._sequenceTypeSymbols = new CharacterSet(\"!&~$ \");\n    }\n\n    let sequenceType = 0 as SequenceType;\n    const sequenceAnnotations = this.ParseCharactersFromCharSet(\n      this._sequenceTypeSymbols\n    );\n\n    if (sequenceAnnotations === null) {\n      return null;\n    }\n\n    for (const symbolChar of sequenceAnnotations) {\n      switch (symbolChar) {\n        case \"!\":\n          sequenceType |= SequenceType.Once;\n          break;\n        case \"&\":\n          sequenceType |= SequenceType.Cycle;\n          break;\n        case \"~\":\n          sequenceType |= SequenceType.Shuffle;\n          break;\n        case \"$\":\n          sequenceType |= SequenceType.Stopping;\n          break;\n      }\n    }\n\n    if (sequenceType === (0 as SequenceType)) {\n      return null;\n    }\n\n    return sequenceType;\n  };\n\n  public readonly SequenceTypeWordAnnotation = (): ParseRuleReturn => {\n    const sequenceTypes = this.Interleave<SequenceType | null>(\n      this.SequenceTypeSingleWord,\n      this.Exclude(this.Whitespace)\n    );\n\n    if (sequenceTypes === null || sequenceTypes.length === 0) {\n      return null;\n    }\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    let combinedSequenceType = 0 as SequenceType;\n    for (const seqType of sequenceTypes) {\n      combinedSequenceType |= seqType!;\n    }\n\n    return combinedSequenceType;\n  };\n\n  public readonly SequenceTypeSingleWord = () => {\n    let seqType: SequenceType | null = null;\n\n    const word = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n\n    if (word !== null) {\n      switch (word.name) {\n        case \"once\":\n          seqType = SequenceType.Once;\n          break;\n        case \"cycle\":\n          seqType = SequenceType.Cycle;\n          break;\n        case \"shuffle\":\n          seqType = SequenceType.Shuffle;\n          break;\n        case \"stopping\":\n          seqType = SequenceType.Stopping;\n          break;\n      }\n    }\n\n    if (seqType === null) {\n      return null;\n    }\n\n    return seqType;\n  };\n\n  public readonly InnerSequenceObjects = (): ContentList[] => {\n    const multiline = this.Parse(this.Newline) !== null;\n\n    let result: ContentList[] | null = null;\n    if (multiline) {\n      result = this.Parse(this.InnerMultilineSequenceObjects) as ContentList[];\n    } else {\n      result = this.Parse(this.InnerInlineSequenceObjects) as ContentList[];\n    }\n\n    return result;\n  };\n\n  public readonly InnerInlineSequenceObjects = (): ContentList[] | null => {\n    const interleavedContentAndPipes = this.Interleave<ParsedObject>(\n      this.Optional(this.MixedTextAndLogic),\n      this.String(\"|\"),\n      null,\n      false\n    );\n\n    if (interleavedContentAndPipes === null) {\n      return null;\n    }\n\n    const result = [];\n\n    // The content and pipes won't necessarily be perfectly interleaved in the sense that\n    // the content can be missing, but in that case it's intended that there's blank content.\n    let justHadContent: boolean = false;\n    for (const contentOrPipe of interleavedContentAndPipes) {\n      // Pipe/separator\n      if ((contentOrPipe as any) === \"|\") {\n        // Expected content, saw pipe - need blank content now\n        if (!justHadContent) {\n          // Add blank content\n          result.push(new ContentList());\n        }\n\n        justHadContent = false;\n      } else {\n        // Real content\n        const content = contentOrPipe as unknown as ParsedObject[];\n        if (content === null) {\n          this.Error(\n            `Expected content, but got ${contentOrPipe as unknown as string} (this is an ink compiler bug!)`\n          );\n        } else {\n          result.push(new ContentList(content));\n        }\n\n        justHadContent = true;\n      }\n    }\n\n    // Ended in a pipe? Need to insert final blank content\n    if (!justHadContent) {\n      result.push(new ContentList());\n    }\n\n    return result;\n  };\n\n  public readonly InnerMultilineSequenceObjects = (): ContentList[] | null => {\n    this.MultilineWhitespace();\n\n    const contentLists = this.OneOrMore(\n      this.SingleMultilineSequenceElement\n    ) as ContentList[];\n    if (contentLists === null) {\n      return null;\n    }\n\n    return contentLists;\n  };\n\n  public readonly SingleMultilineSequenceElement = () => {\n    this.Whitespace();\n\n    // Make sure we're not accidentally parsing a divert\n    if (this.ParseString(\"->\") !== null) {\n      return null;\n    }\n\n    if (this.ParseString(\"-\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const content: ParsedObject[] = this.StatementsAtLevel(\n      StatementLevel.InnerBlock\n    );\n\n    if (content === null) {\n      this.MultilineWhitespace();\n    } else {\n      // Add newline at the start of each branch\n      content.unshift(new Text(\"\\n\"));\n    }\n\n    return new ContentList(content);\n  };\n\n  /**\n   * End Sequences section.\n   */\n\n  /**\n   * Begin Statements section.\n   */\n\n  private _statementRulesAtLevel: ParseRule[][] = [];\n  private _statementBreakRulesAtLevel: ParseRule[][] = [];\n\n  public readonly StatementsAtLevel = (\n    level: StatementLevel\n  ): ParsedObject[] => {\n    // Check for error: Should not be allowed gather dashes within an inner block\n    if (level === StatementLevel.InnerBlock) {\n      const badGatherDashCount = this.Parse(this.GatherDashes) as ParsedObject;\n      if (badGatherDashCount !== null) {\n        this.Error(\n          \"You can't use a gather (the dashes) within the { curly braces } context. For multi-line sequences and conditions, you should only use one dash.\"\n        );\n      }\n    }\n\n    return this.Interleave<ParsedObject>(\n      this.Optional(this.MultilineWhitespace),\n      () => this.StatementAtLevel(level),\n      () => this.StatementsBreakForLevel(level)\n    );\n  };\n\n  public readonly StatementAtLevel = (level: StatementLevel): ParsedObject => {\n    const rulesAtLevel: ParseRule[] =\n      this._statementRulesAtLevel[level as number];\n    const statement = this.OneOf(rulesAtLevel) as ReturnType;\n\n    // For some statements, allow them to parse, but create errors, since\n    // writers may think they can use the statement, so it's useful to have\n    // the error message.\n    if (level === StatementLevel.Top) {\n      if (statement instanceof ReturnType) {\n        this.Error(\"should not have return statement outside of a knot\");\n      }\n    }\n\n    return statement;\n  };\n\n  public readonly StatementsBreakForLevel = (\n    level: StatementLevel\n  ): ParseRuleReturn => {\n    this.Whitespace();\n\n    const breakRules: ParseRule[] =\n      this._statementBreakRulesAtLevel[level as number];\n    const breakRuleResult = this.OneOf(breakRules);\n    if (breakRuleResult === null) {\n      return null;\n    }\n\n    return breakRuleResult;\n  };\n\n  public readonly GenerateStatementLevelRules = () => {\n    const levels: StatementLevel[] = Object.values(\n      StatementLevel\n    ) as StatementLevel[];\n\n    this._statementRulesAtLevel = \"f\"\n      .repeat(levels.length)\n      .split(\"f\")\n      .map(() => []);\n\n    this._statementBreakRulesAtLevel = \"f\"\n      .repeat(levels.length)\n      .split(\"f\")\n      .map(() => []);\n\n    for (const level of levels) {\n      const rulesAtLevel: ParseRule[] = [];\n      const breakingRules: ParseRule[] = [];\n\n      // Diverts can go anywhere\n      rulesAtLevel.push(this.Line(this.MultiDivert));\n\n      // Knots can only be parsed at Top/Global scope\n      if (level >= StatementLevel.Top) {\n        rulesAtLevel.push(this.KnotDefinition);\n      }\n\n      rulesAtLevel.push(this.Line(this.Choice));\n\n      rulesAtLevel.push(this.Line(this.AuthorWarning));\n\n      // Gather lines would be confused with multi-line block separators, like\n      // within a multi-line if statement\n      if (level > StatementLevel.InnerBlock) {\n        rulesAtLevel.push(this.Gather);\n      }\n\n      // Stitches (and gathers) can (currently) only go in Knots and top level\n      if (level >= StatementLevel.Knot) {\n        rulesAtLevel.push(this.StitchDefinition);\n      }\n\n      // Global variable declarations can go anywhere\n      rulesAtLevel.push(this.Line(this.ListDeclaration));\n      rulesAtLevel.push(this.Line(this.VariableDeclaration));\n      rulesAtLevel.push(this.Line(this.ConstDeclaration));\n      rulesAtLevel.push(this.Line(this.ExternalDeclaration));\n\n      // Global include can go anywhere\n      rulesAtLevel.push(this.Line(this.IncludeStatement));\n\n      // Normal logic / text can go anywhere\n      rulesAtLevel.push(this.LogicLine);\n      rulesAtLevel.push(this.LineOfMixedTextAndLogic);\n\n      // --------\n      // Breaking rules\n\n      // Break current knot with a new knot\n      if (level <= StatementLevel.Knot) {\n        breakingRules.push(this.KnotDeclaration);\n      }\n\n      // Break current stitch with a new stitch\n      if (level <= StatementLevel.Stitch) {\n        breakingRules.push(this.StitchDeclaration);\n      }\n\n      // Breaking an inner block (like a multi-line condition statement)\n      if (level <= StatementLevel.InnerBlock) {\n        breakingRules.push(this.ParseDashNotArrow);\n        breakingRules.push(this.String(\"}\"));\n      }\n\n      this._statementRulesAtLevel[level as number] = rulesAtLevel;\n      this._statementBreakRulesAtLevel[level as number] = breakingRules;\n    }\n  };\n\n  public readonly SkipToNextLine = (): typeof ParseSuccess => {\n    this.ParseUntilCharactersFromString(\"\\n\\r\");\n    this.ParseNewline();\n\n    return ParseSuccess;\n  };\n\n  // Modifier to turn a rule into one that expects a newline on the end.\n  // e.g. anywhere you can use \"MixedTextAndLogic\" as a rule, you can use\n  // \"Line(MixedTextAndLogic)\" to specify that it expects a newline afterwards.\n  public readonly Line =\n    (inlineRule: ParseRule): ParseRule =>\n    () => {\n      const result = this.ParseObject(inlineRule);\n      if (result === null) {\n        return null;\n      }\n\n      this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n\n      return result;\n    };\n\n  /**\n   * End Statements section.\n   */\n\n  /**\n   * Begin Tags section.\n   */\n\n  public readonly StartTag = (): ParsedObject | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"#\") === null) {\n      return null;\n    }\n\n    if (this.parsingStringExpression) {\n      this.Error(\n        \"Tags aren't allowed inside of strings. Please use \\\\# if you want a hash symbol.\"\n      );\n    }\n\n    let result: ParsedObject | null = null;\n    if (this.tagActive) {\n      let contentList = new ContentList();\n      contentList.AddContent(new Tag(/*isStart:*/ false));\n      contentList.AddContent(new Tag(/*isStart:*/ true));\n      result = contentList;\n    } else {\n      result = new Tag(/*isStart:*/ true);\n    }\n    this.tagActive = true;\n\n    this.Whitespace();\n\n    return result;\n  };\n\n  public EndTagIfNecessary(outputContentList: ParsedObject[] | null): void;\n  public EndTagIfNecessary(outputContentList: ContentList | null): void;\n  public EndTagIfNecessary(\n    outputContentList: ParsedObject[] | ContentList | null\n  ): void {\n    if (this.tagActive) {\n      if (outputContentList != null) {\n        if (outputContentList instanceof ContentList) {\n          outputContentList.AddContent(new Tag(/*isStart:*/ false));\n        } else {\n          outputContentList.push(new Tag(/*isStart:*/ false));\n        }\n      }\n      this.tagActive = false;\n    }\n  }\n\n  /**\n   * End Tags section.\n   */\n\n  /**\n   * Begin Whitespace section.\n   */\n\n  private _inlineWhitespaceChars: CharacterSet = new CharacterSet(\" \\t\");\n\n  // Handles both newline and endOfFile\n  public readonly EndOfLine = () => this.OneOf([this.Newline, this.EndOfFile]);\n\n  // Allow whitespace before the actual newline\n  public readonly Newline = (): typeof ParseSuccess | null => {\n    this.Whitespace();\n\n    const gotNewline: boolean = this.ParseNewline() !== null;\n\n    // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n\n    if (!gotNewline) {\n      return null;\n    }\n\n    return ParseSuccess;\n  };\n\n  public readonly EndOfFile = (): typeof ParseSuccess | null => {\n    this.Whitespace();\n\n    if (!this.endOfInput) return null;\n\n    return ParseSuccess;\n  };\n\n  // General purpose space, returns N-count newlines (fails if no newlines)\n  public readonly MultilineWhitespace = (): typeof ParseSuccess | null => {\n    let newlines: ParseRuleReturn[] | null = this.OneOrMore(this.Newline);\n    if (newlines === null) {\n      return null;\n    }\n\n    // Use content field of Token to say how many newlines there were\n    // (in most circumstances it's unimportant)\n    const numNewlines: number = newlines.length;\n    if (numNewlines >= 1) {\n      return ParseSuccess;\n    }\n\n    return null;\n  };\n\n  public readonly Whitespace = (): typeof ParseSuccess | null => {\n    const doneParsed = this.ParseCharactersFromCharSet(\n      this._inlineWhitespaceChars\n    );\n\n    if (doneParsed !== null) {\n      return ParseSuccess;\n    }\n\n    return null;\n  };\n\n  public readonly Spaced =\n    (rule: ParseRule): ParseRule =>\n    () => {\n      this.Whitespace();\n\n      const result = this.ParseObject(rule);\n      if (result === null) {\n        return null;\n      }\n\n      this.Whitespace();\n\n      return result;\n    };\n\n  public readonly AnyWhitespace = (): typeof ParseSuccess | null => {\n    let anyWhitespace: boolean = false;\n\n    while (this.OneOf([this.Whitespace, this.MultilineWhitespace]) !== null) {\n      anyWhitespace = true;\n    }\n\n    return anyWhitespace ? ParseSuccess : null;\n  };\n\n  public readonly MultiSpaced =\n    (rule: ParseRule): ParseRuleReturn =>\n    () => {\n      this.AnyWhitespace();\n\n      const result = this.ParseObject(rule);\n      if (result === null) {\n        return null;\n      }\n\n      this.AnyWhitespace();\n\n      return result;\n    };\n\n  private _filename: string | null = null;\n  private _externalErrorHandler: ErrorHandler | null = null;\n  private _fileHandler: IFileHandler | null = null;\n\n  /**\n   * End Whitespace section.\n   */\n}\n","import { CompilerOptions } from \"./CompilerOptions\";\nimport { DebugSourceRange } from \"./DebugSourceRange\";\nimport { ErrorType } from \"./Parser/ErrorType\";\nimport { InkParser } from \"./Parser/InkParser\";\nimport { Story } from \"../engine/Story\";\nimport { Story as ParsedStory } from \"./Parser/ParsedHierarchy/Story\";\nimport { DebugMetadata } from \"../engine/DebugMetadata\";\nimport { StringValue } from \"../engine/Value\";\nimport { asOrNull } from \"../engine/TypeAssertion\";\nimport { GenerateStoryStats, Stats } from \"./Stats\";\n\nexport { CompilerOptions } from \"./CompilerOptions\";\nexport { InkParser } from \"./Parser/InkParser\";\nexport { StatementLevel } from \"./Parser/StatementLevel\";\nexport { JsonFileHandler } from \"./FileHandler/JsonFileHandler\";\nexport { InkList, Story } from \"../engine/Story\";\n\nexport class Compiler {\n  private _errors: string[] = [];\n  get errors(): string[] {\n    return this._errors;\n  }\n\n  private _warnings: string[] = [];\n  get warnings(): string[] {\n    return this._warnings;\n  }\n\n  private _authorMessages: string[] = [];\n  get authorMessages(): string[] {\n    return this._authorMessages;\n  }\n\n  private _inputString: string;\n  get inputString(): string {\n    return this._inputString;\n  }\n\n  private _options: CompilerOptions;\n  get options(): CompilerOptions {\n    return this._options;\n  }\n\n  private _parsedStory: ParsedStory | null = null;\n  get parsedStory(): ParsedStory {\n    if (!this._parsedStory) {\n      throw new Error();\n    }\n\n    return this._parsedStory;\n  }\n\n  private _runtimeStory: Story | null = null;\n  get runtimeStory(): Story {\n    if (!this._runtimeStory) {\n      throw new Error(\"Compilation failed.\");\n    }\n\n    return this._runtimeStory;\n  }\n\n  private _parser: InkParser | null = null;\n  get parser(): InkParser {\n    if (!this._parser) {\n      throw new Error();\n    }\n\n    return this._parser;\n  }\n\n  private _debugSourceRanges: DebugSourceRange[] = [];\n  get debugSourceRanges(): DebugSourceRange[] {\n    return this._debugSourceRanges;\n  }\n\n  constructor(inkSource: string, options: CompilerOptions | null = null) {\n    this._inputString = inkSource;\n    this._options = options || new CompilerOptions();\n  }\n\n  public readonly Compile = (): Story => {\n    this._parser = new InkParser(\n      this.inputString,\n      this.options.sourceFilename || null,\n      this.OnError,\n      null,\n      this.options.fileHandler\n    );\n\n    this._parsedStory = this.parser.ParseStory();\n\n    if (this.errors.length === 0) {\n      this.parsedStory.countAllVisits = this.options.countAllVisits;\n      this._runtimeStory = this.parsedStory.ExportRuntime(this.OnError);\n    } else {\n      this._runtimeStory = null;\n    }\n\n    return this.runtimeStory;\n  };\n\n  public readonly RetrieveDebugSourceForLatestContent = (): void => {\n    for (const outputObj of this.runtimeStory.state.outputStream) {\n      const textContent = asOrNull(outputObj, StringValue);\n      if (textContent !== null) {\n        const range = new DebugSourceRange(\n          textContent.value?.length || 0,\n          textContent.debugMetadata,\n          textContent.value || \"unknown\"\n        );\n\n        this.debugSourceRanges.push(range);\n      }\n    }\n  };\n\n  public readonly GenerateStats = (): Stats | null => {\n    if (this._parsedStory === null) {\n      return null;\n    }\n    return GenerateStoryStats(this._parsedStory);\n  };\n\n  public readonly DebugMetadataForContentAtOffset = (\n    offset: number\n  ): DebugMetadata | null => {\n    let currOffset = 0;\n\n    let lastValidMetadata: DebugMetadata | null = null;\n    for (const range of this.debugSourceRanges) {\n      if (range.debugMetadata !== null) {\n        lastValidMetadata = range.debugMetadata;\n      }\n\n      if (offset >= currOffset && offset < currOffset + range.length) {\n        return lastValidMetadata;\n      }\n\n      currOffset += range.length;\n    }\n\n    return null;\n  };\n\n  public readonly OnError = (message: string, errorType: ErrorType) => {\n    switch (errorType) {\n      case ErrorType.Author:\n        this._authorMessages.push(message);\n        break;\n\n      case ErrorType.Warning:\n        this._warnings.push(message);\n        break;\n\n      case ErrorType.Error:\n        this._errors.push(message);\n        break;\n    }\n\n    if (this.options.errorHandler !== null) {\n      this.options.errorHandler(message, errorType);\n    }\n  };\n}\n","import { Choice } from \"./Parser/ParsedHierarchy/Choice\";\nimport { Divert } from \"./Parser/ParsedHierarchy/Divert/Divert\";\nimport { Gather } from \"./Parser/ParsedHierarchy/Gather/Gather\";\nimport { Knot } from \"./Parser/ParsedHierarchy/Knot\";\nimport { Stitch } from \"./Parser/ParsedHierarchy/Stitch\";\nimport { Story } from \"./Parser/ParsedHierarchy/Story\";\nimport { Text } from \"./Parser/ParsedHierarchy/Text\";\n\nexport interface Stats {\n  words: number;\n  knots: number;\n  stitches: number;\n  functions: number;\n  choices: number;\n  gathers: number;\n  diverts: number;\n}\n\nexport function GenerateStoryStats(story: Story): Stats {\n  let allText = story.FindAll(Text)();\n  let words = 0;\n  for (const text of allText) {\n    let wordsInThisStr = 0;\n    let wasWhiteSpace = true;\n    for (const c of text.text) {\n      if (c == \" \" || c == \"\\t\" || c == \"\\n\" || c == \"\\r\") {\n        wasWhiteSpace = true;\n      } else if (wasWhiteSpace) {\n        wordsInThisStr++;\n        wasWhiteSpace = false;\n      }\n    }\n\n    words += wordsInThisStr;\n  }\n\n  const knots = story.FindAll(Knot)();\n  const stitches = story.FindAll(Stitch)();\n  const choices = story.FindAll(Choice)();\n  const gathers = story.FindAll(Gather)((g) => g.debugMetadata != null);\n  const diverts = story.FindAll(Divert)();\n\n  return {\n    words,\n    knots: knots.length,\n    functions: knots.filter((k) => k.isFunction).length,\n    stitches: stitches.length,\n    gathers: gathers.length,\n    diverts: diverts.length - 1,\n    choices: choices.length,\n  };\n}\n","import { IFileHandler } from \"../IFileHandler\";\n\nexport class JsonFileHandler implements IFileHandler {\n  constructor(public readonly fileHierarchy: Record<string, string>) {}\n\n  readonly ResolveInkFilename = (filename: string): string => {\n    if (Object.keys(this.fileHierarchy).includes(filename)) return filename;\n    throw new Error(\n      `Cannot locate ${filename}. Are you trying a relative import ? This is not yet implemented.`\n    );\n  };\n\n  readonly LoadInkFileContents = (filename: string): string => {\n    if (Object.keys(this.fileHierarchy).includes(filename)) {\n      return this.fileHierarchy[filename];\n    } else {\n      throw new Error(`Cannot open ${filename}.`);\n    }\n  };\n}\n"],"names":["CompilerOptions","constructor","sourceFilename","pluginNames","countAllVisits","errorHandler","fileHandler","this","DebugSourceRange","length","debugMetadata","text","ErrorType","Argument","identifier","isByReference","isDivertTarget","typeName","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","Equals","filterUndef","element","undefined","ParsedObject","_alreadyHadError","_alreadyHadWarning","_debugMetadata","_runtimeObject","content","parent","GetType","AddContent","subContent","sub","Array","isArray","ss","hasOwnProperty","push","InsertContent","index","splice","Find","queryFunc","tObj","nestedResult","FindAll","foundSoFar","found","Warning","message","source","value","hasOwnDebugMetadata","Boolean","story","ancestor","runtimeObject","GenerateRuntimeObject","runtimePath","path","containerForCounting","ancestry","result","reverse","ResolveReferences","context","isWarning","AuthorWarning","warningMessage","super","Path","_components","_componentsString","_isRelative","arguments","componentsString","Component","head","tail","concat","relative","isRelative","componentCount","tailComps","slice","self","lastComponent","lastComponentIdx","containsNamedComponent","i","l","isIndex","GetComponent","PathByAppendingPath","pathToAppend","p","upwardMoves","isParent","join","substring","componentStrings","split","str","test","parseInt","toString","otherPath","PathByAppendingComponent","c","Debug","ValueType","PushPopType","parentId","indexOrName","ToParent","otherComp","Assert","condition","console","warn","trace","AssertType","variable","NullException","throwNullException","InkObject","_path","ownDebugMetadata","DebugLineNumberOfPath","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","comps","child","container","Container","namedChild","unshift","indexOf","ResolvePath","nearestContainer","contentContainer","ConvertPathToRelative","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","newPathComps","up","down","CompactPathString","globalPathStr","relativePathStr","Copy","SetChild","prop","StringBuilder","string","Length","Append","AppendLine","AppendFormat","format","args","replace","match","num","Clear","InkListItem","originName","itemName","nameParts","Null","isNull","fullName","otherItem","copy","serialized","JSON","stringify","fromSerializedKey","key","parse","isLikeInkListItem","inkListItem","item","InkList","Map","origins","_originNames","otherList","otherOriginNames","originNames","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","def","TryListGetDefinition","exists","singleElement","Add","Key","Value","FromString","myListItem","listValue","_a","FindSingleItemListWithName","AddItem","itemOrItemName","storyObject","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","newItem","orderedItems","itemVal","ValueForItem","ContainsItemNamed","ContainsKey","has","serializedKey","set","Remove","delete","Count","size","originOfMaxItem","maxOriginName","maxItem","every","initialOriginName","SetInitialOriginNames","initialOriginNames","max","minItem","inverse","list","items","all","Union","union","Intersect","intersection","HasIntersection","Without","listToRemove","Contains","what","GreaterThan","GreaterThanOrEquals","LessThan","LessThanOrEquals","MaxAsList","MinAsList","ListWithSubRange","minBound","maxBound","ordered","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","otherInkList","sort","x","y","localeCompare","singleItem","sb","valueOf","NaN","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","AbstractValue","Create","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","StringValue","String","DivertTargetValue","ListValue","valueObject","BadCastException","targetType","valueType","isTruthy","Bool","Cast","newType","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","isNonWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","targetPath","DivertTarget","VariablePointerValue","variableName","contextIndex","_contextIndex","VariablePointer","List","listOrSingleItem","singleValue","RetainListOriginsForAssignment","oldValue","newValue","oldList","newList","SearchResult","approximate","correctObj","searchResult","_content","namedContent","visitsShouldBeCounted","turnIndexShouldBeCounted","countingAtStartOnly","_pathToFirstLeafContent","namedOnlyContent","namedOnlyContentDict","inkObject","named","existingNamedOnly","AddToNamedContentOnly","countFlags","flags","CountFlags","Visits","Turns","CountStartOnly","flag","pathToFirstLeafContent","internalPathToFirstLeafContent","components","contentObjOrList","contentList","contentObj","TryAddNamedContent","namedContentObj","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","nextContainer","AddContentsOfContainer","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","onlyNamed","ControlCommand","commandType","_commandType","CommandType","NotSet","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","BeginTag","EndTag","Expression","_prototypeRuntimeConstantExpression","outputWhenComplete","RuntimeContainer","RuntimeControlCommand","GenerateIntoContainer","GenerateConstantIntoContainer","runtimeObj","Void","NativeFunctionCall","CallWithName","functionName","CallExistsWithName","GenerateNativeFunctionsIfNecessary","_nativeFunctions","_name","_isPrototype","_prototype","numberOfParameters","_numberOfParameters","Call","parameters","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","_operationFuncs","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","inkObjectVal","castedValue","Identity","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","AddListUnaryOp","Invert","All","ListMin","ListMax","ValueOfList","divertTargetsEqual","d1","d2","divertTargetsNotEqual","AddOpToNativeFunc","AddOpFuncForType","nativeFunc","NumberExpression","subtype","isInt","isFloat","isBool","numberExpression","UnaryExpression","nativeNameForOp","inner","innerExpression","WithInner","innerNumber","BinaryExpression","left","right","opName","leftExpression","rightExpression","NativeNameForOp","leftUnary","CharacterSet","arg","Set","add","AddRange","start","end","charCodeAt","fromCharCode","AddCharacters","chars","FromRange","CharacterRange","_start","_end","excludes","_correspondingCharSet","_excludes","ToCharacterSet","ii","Define","ChoicePoint","onceOnly","_pathOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","pathOnChoice","choiceTargetObj","choiceTarget","pathStringOnChoice","Pointer","Resolve","StartOf","Divert","_targetPath","targetObj","targetPointer","_targetPointer","targetPathString","hasVariableTarget","variableDivertName","stackPushType","pushesToStack","isExternal","externalArgs","isConditional","otherDivert","targetStr","Function","SymbolType","isNewDeclaration","isGlobal","runtimeChoice","_runtimeChoice","_condition","runtimeContainer","_innerContentContainer","innerContentContainer","startContent","choiceOnlyContent","innerContent","_outerContainer","_returnToR1","_returnToR2","_r1Label","_r2Label","_divertToStartContentOuter","_divertToStartContentInner","_startContentRuntimeContainer","hasWeaveStyleInlineBrackets","varAssign","RuntimeVariableAssignment","RuntimeDivert","varDivert","choiceOnlyRuntimeContent","innerChoiceOnlyContent","indentationDepth","CheckForNamingCollisions","SubFlowAndWeave","StringParserElement","characterIndex","characterInLineIndex","lineIndex","reportedErrorInScope","uniqueId","customFlags","CopyFrom","fromElement","_uniqueIdCounter","SquashFrom","StringParserState","currentElement","_stack","_numElements","errorReportedAlreadyInScope","stackHeight","Push","prevElement","newElement","Pop","expectedRuleId","Peek","PeekPenultimate","Squash","penultimateEl","lastEl","NoteErrorReported","el","ParseSuccess","Symbol","StringParser","ParseRule","hadError","BeginRule","state","FailRule","CancelRule","SucceedRule","stateAtSucceedRule","stateAtBeginRule","RuleDidSucceed","finalResult","Expect","rule","recoveryRule","ParseObject","butSaw","lineRemainder","LineRemainder","ErrorOnLine","ErrorWithParsedObject","lineNumber","errorType","ParseUntilCharactersFromString","SetFlag","trueOrFalse","GetFlag","ruleId","stackHeightBefore","Parse","OneOf","array","OneOrMore","results","Optional","Exclude","OptionalExclude","ParseString","TryAddResultToList","flatten","resultCollection","Interleave","ruleA","ruleB","untilTerminator","firstA","lastMainResult","outerResult","remainingLength","cli","li","success","tempIdx","_chars","ParseSingleCharacter","maxCount","ParseCharactersFromString","ParseUntilCharactersFromCharSet","charSet","ParseCharactersFromCharSet","maxCountOrShouldIncludeStrChars","shouldIncludeChars","startIndex","count","ParseInt","oldIndex","oldCharacterInLineIndex","negative","parsedString","numbersCharacterSet","MIN_SAFE_INTEGER","ParseFloat","leadingInt","afterDecimalPointStr","ParseNewline","strPreProc","PreProcessInputString","inputString","currentCharacter","endOfInput","remainingString","ParseUntil","stopRule","pauseCharacters","endCharacters","pauseAndEnd","values","ruleResultAtPause","partialParsedString","pauseCharacter","CommentEliminator","_commentOrNewlineStartCharacter","_commentBlockEndCharacter","_newlineCharacters","Process","stringList","CommentsAndNewlines","MainInk","newLines","ParseSingleComment","EndOfLineComment","BlockComment","startLineIndex","commentResult","repeat","Conditional","initialCondition","branches","_reJoinTarget","branch","branchContainer","ownExpression","isElse","pathToReJoin","returnDivert","Text","ConstantDeclaration","constantName","constantIdentifier","expression","_expression","assignedExpression","Var","FlowLevel","Gather","_b","baseTargetLevel","baseLevelIsAmbiguous","Story","_baseTargetLevel","firstComponent","numberOfComponents","dotSeparatedComponents","_dotSeparatedComponents","filter","argOne","argTwo","WeavePoint","ResolveFromContext","baseTargetObject","ResolveBaseTarget","ResolveTailComponents","originalContext","firstComp","ancestorContext","deepSearch","foundBase","GetChildFromContext","rootTarget","foundComponent","compName","minimumExpectedLevel","foundFlow","FlowBase","flowLevel","childName","minimumLevel","forceDeepSearch","ambiguousChildLevel","weaveContext","Weave","WeavePointNamed","flowContext","shouldDeepSearch","Knot","ContentWithNameAtLevel","Object","ReturnType","returnedExpression","ClosestFlowBase","iamFlowbase","Identifier","hasParameters","subFlowsByName","_subFlowsByName","isFunction","topLevelObjects","isIncludedStory","_rootWeave","_startingSubFlowDivert","_startingSubFlowRuntime","_firstChildFlow","variableDeclarations","SplitWeaveAndSubFlowContent","contentObjs","isRootStory","weaveObjs","subFlowObjs","subFlow","finalContent","ResolveVariableWithName","varName","fromNode","ownerFlow","isArgument","isTemporary","AddNewVariableDeclaration","varDecl","varab","prevDeclError","ResolveWeavePointNaming","foundReturn","CheckForDisallowedFunctionFlowControl","Stitch","GenerateArgumentVariableAssignments","contentIdx","childFlow","childFlowRuntime","existingChild","errorMsg","ValidateTermination","WarningInTermination","paramName","assign","level","weavePointResult","DeepSearchForAnyLevelContent","weaveResultSelf","deepResult","allDiverts","divert","isFunctionCall","allChoices","Choice","choice","terminatingObject","terminatingDivert","isTunnel","target","PreProcessTopLevelObjects","_","Arg","jj","symbolType","ContentList","objects","moreObjects","dontFlatten","TrimTrailingWhitespace","RegExp","contentObjRuntime","DontFlattenContainer","containerForCount","pathForCount","pathStringForCount","VariableReference","pathIdentifiers","id","runtimeVarRef","_runtimeVarRef","isConstantReference","isListItemReference","constantValue","constants","RuntimeVariableReference","listItemName","listName","ResolveListItem","parsedPath","targetForCount","targetFlow","FunctionCall","proxyDivert","_proxyDivert","runtimeDivert","isChoiceCount","isTurns","isTurnsSince","isRandom","isSeedRandom","isListRange","isListRandom","isReadCount","_divertTargetToCount","_variableReferenceToCount","shouldPopReturnedValue","foundList","ResolveList","usingProxyDivert","divertTarget","variableDivertTarget","nativeCall","msg","RuntimeInkList","strArgs","attemptingTurnCountOfVariableTarget","targetObject","IsBuiltIn","MultipleConditionExpression","subExpressions","conditionExpressions","isFirst","conditionExpr","_runtimeDivert","runtimeDivertTargetValue","_runtimeDivertTargetValue","otherDivTarget","isDone","isEnd","usageContext","badUsage","foundUsage","usageParent","binaryExprParent","funcCall","ConditionalSingleBranch","parentFunc","isEmpty","isThread","ResolveTargetContent","CheckArgumentValidity","requiresArgCodeGen","targetArguments","argToPass","argExpected","varRef","varPointer","Tunnel","PathAsVariableName","variableTargetName","flowBaseScope","resolveResult","argument","find","a","numArgs","butClause","flowArg","divArgExpr","knotCountPath","CheckExternalArgumentValidity","externalName","external","externals","externalArgCount","argumentNames","ownArgCount","returnString","targetWasFound","isBuiltIn","IsExternal","RuntimePath","GatherPointToResolve","targetRuntimeObj","SequenceDivertToResolve","SequenceType","Sequence","elementContentLists","sequenceType","_sequenceDivertsToResolve","once","Once","cycle","Cycle","stopping","Stopping","shuffle","Shuffle","seqBranchCount","sequenceElements","postShuffleNoOp","lastIdx","skipShuffleDivert","AddDivertToResolve","elementCountToShuffle","postSequenceNoOp","elIndex","sequenceDivert","contentContainerForSequenceBranch","seqBranchCompleteDivert","elementContentList","seqElObject","toResolve","TunnelOnwards","_overrideDivertTarget","_divertAfter","divertAfter","returnRuntimeObj","returnRuntimeContainer","evalStart","evalEnd","cmd","returnDivertObj","_items","_itemNameToValues","ContainsItem","ListDefinition","runtimeListDefinition","allItems","e","itemDefinitions","seriesValue","RuntimeListDefinition","variableAssignment","_elementsByName","ItemNamed","initialValues","itemDef","inInitialList","RuntimeInkListItem","currentValue","explicitValue","VariableAssignment","variableIdentifier","isNewTemporaryDeclaration","isGlobalDeclaration","listDefinition","isDeclaration","isTemporaryNewDeclaration","listDef","_runtimeAssignment","newDeclScope","Temp","variableReference","resolvedVarAssignment","rootContainer","_rootContainer","namedWeavePoints","_namedWeavePoints","lastParsedSignificantObject","lastObject","lastText","IsGlobalDeclaration","lastWeave","cont","indentIndex","previousWeavePoint","addContentToPreviousWeavePoint","hasSeenChoiceInSection","_unnamedGatherCount","_choiceCount","looseEnds","gatherPointsToResolve","w","weavePoint","existingWeavePoint","existingObj","_c","ConstructWeaveHierarchyFromIndentation","weaveIndentIdx","baseIndentIndex","innerWeaveStartIdx","innerWeaveObj","weaveContentCount","weaveContent","weave","DetermineBaseIndentationFromContent","AddRuntimeForWeavePoint","AddRuntimeForNestedWeave","AddGeneralRuntimeContent","PassLooseEndsToAncestors","AddRuntimeForGather","gather","autoEnter","gatherContainer","looseEndWeavePoint","looseEnd","looseWeavePoint","WeavePointHasLooseEnd","closestInnerWeaveAncestor","closestOuterWeaveAncestor","nested","weaveAncestor","received","ReceiveLooseEnd","receivingWeave","childWeaveLooseEnd","varAss","ContentThatFollowsWeavePoint","returned","parentWeave","laterObj","badTerminationHandler","looseEndFlow","ValidateFlowOfObjectsTerminates","BadNestedTerminationHandler","terminatingObj","conditional","toLowerCase","objFlow","defaultObj","terminated","flowObj","d","innerDivert","CheckForWeavePointNamingCollisions","ancestorFlows","flow","weavePointName","otherContentWithName","isNestedWeave","gatherPoint","_ownExpression","_contentContainer","_conditionalDivert","_innerWeave","isTrueBranch","matchingEquality","isInline","startsWith","duplicatesStackValue","needsEval","GenerateRuntimeForContent","CustomFlags","DebugMetadata","endLineNumber","startCharacterNumber","endCharacterNumber","fileName","sourceName","Merge","newDebugMetadata","ExternalDeclaration","AddExternal","FlowDecl","Wrap","_objToWrap","glue","Glue","IncDecExpression","varIdentifier","isIncOrExpression","isInc","varResolveResult","incrementDecrementWord","IncludedFile","includedStory","InfixOperator","precedence","requireWhitespace","parentStory","stitchName","knotWithStitchName","stitch","itemIdentifierList","runtimeRawList","itemIdentifier","ListElementDefinition","parentList","indentifier","ListItem","StatementLevel","exports","baseToString","tagText","threadAtGeneration","sourcePath","tags","originalThreadIndex","Clone","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","JArrayToRuntimeObjList","jArray","skipLast","jTok","JTokenToRuntimeObject","WriteDictionaryRuntimeObjs","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteListRuntimeObjs","WriteArrayStart","WriteArrayEnd","WriteIntDictionary","dict","WriteIntProperty","WriteRuntimeContainer","divTypeKey","WriteProperty","choicePoint","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","readCountPath","tag","Tag","WriteChoice","JObjectToDictionaryRuntimeObjs","jObject","JObjectToIntDictionary","token","floatRepresentation","exec","firstChar","propValue","varPtr","isDivert","divPushType","readCountVarRef","isVarAss","isGlobalVar","isNewDecl","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","toJson","me","removes","space","k","v","some","r","withoutName","hasNameProperty","hasTerminator","namedContainer","WriteNull","namedContentItem","namedSubContainer","jObj","JArrayToTags","WriteChoiceTags","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","ListDefinitionsToJToken","listDefJson","JTokenToListDefinitions","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","elements","callStack","depth","cs","_threads","callstack","currentElementIndex","currentThread","canPop","_threadCounter","_startOfRoot","storyContext","Reset","toCopy","otherThread","Thread","Element","SetJsonToken","jThreads","jThreadTok","jThreadObj","thread","WriteJson","WriteObject","PushThread","newThread","threadIndex","ForkThread","forkedThread","PopThread","canPopThread","elementIsEvaluateFromGame","FunctionEvaluationFromGame","externalEvaluationStackHeight","outputStreamLengthWithPushed","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","CanPop","pop","GetTemporaryVariableWithName","varValue","temporaryVariables","SetTemporaryVariable","declareNew","contextElement","ContextForVariableNamed","ThreadWithIndex","filtered","callStackTrace","isCurrent","pointer","inExpressionEvaluation","previousPointer","jThreadCallstack","jElTok","currentContainerPathStr","jElementObj","pushPopType","currentContainerPathStrToken","threadPointerResult","temps","clear","prevContentObjPath","prevPath","PointerAtPath","resolvedPointer","VariablesState","variableChangedEvent","callback","variableChangedEventCallbacks","StartVariableObservation","_batchObservingVariableChanges","_changedVariablesForBatchObs","CompleteVariableObservation","changedVars","_globalVariables","patch","changedVariables","patchedVal","TryGetGlobal","NotifyObservers","_callStack","$","varContents","_defaultGlobalVariables","SetGlobal","listDefsOrigin","_listDefsOrigin","Proxy","ownKeys","keys","getOwnPropertyDescriptor","enumerable","configurable","ApplyPatch","namedVarKey","namedVarValue","globals","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","GetVariableWithName","GetRawVariableWithName","ValueAtVariablePointer","TryGetDefaultVariableValue","GlobalVariableExistsWithName","variableValue","Assign","setGlobal","ResolveVariablePointer","existingPointer","SnapshotDefaultGlobals","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","ObserveVariableChange","PRNG","seed","next","nextFloat","StatePatch","_globals","_changedVariables","visitCounts","_visitCounts","turnIndices","_turnIndices","TryGetVisitCount","SetVisitCount","SetTurnIndex","TryGetTurnIndex","SimpleJson","TextToDictionary","Reader","ToDictionary","TextToArray","ToArray","__","explicitFloatReviver","endsWith","_rootObject","jsonWithExplicitFloat","Writer","_currentPropertyName","_currentString","_stateStack","_collectionStack","_propertyNameStack","_jsonObject","StartNewObject","newObject","State","Property","currentCollection","currentPropertyName","propertyName","None","StateElement","innerOrContent","WriteFloatProperty","IncrementChildCount","childCount","PropertyName","escape","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","currEl","Flow","outputStream","currentChoices","jChoiceThreadsObj","LoadFlowChoiceThreads","hasChoiceThreads","jChoiceThreads","foundActiveThread","jSavedChoiceThread","StoryState","ToJson","indented","LoadJson","json","LoadJsonObj","onDidLoadState","VisitCountAtPathString","pathString","visitCountOut","_patch","VisitCountForContainer","containerPathStr","count2","IncrementVisitCountForContainer","currCount","RecordTurnIndexVisitToContainer","currentTurnIndex","TurnsSinceForContainer","index2","callstackDepth","_currentFlow","canContinue","generatedChoices","currentErrors","_currentErrors","currentWarnings","_currentWarnings","variablesState","_variablesState","evaluationStack","_evaluationStack","_currentTurnIndex","currentPathString","previousPathString","hasError","hasWarning","currentText","_outputStreamTextDirty","inTag","outputObj","textContent","controlCommand","_currentText","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","currentTags","_outputStreamTagsDirty","_currentTags","txt","currentFlowName","currentFlowIsDefaultFlow","kDefaultFlowName","aliveFlowNames","_aliveFlowNamesDirty","_aliveFlowNames","_namedFlows","flowName","kInkSaveStateVersion","kMinCompatibleLoadVersion","divertedPointer","storySeed","previousRandom","didSafeExit","OutputStreamDirty","timeSeed","Date","getTime","GoToStart","mainContentContainer","SwitchFlow_Internal","SwitchToDefaultFlow_Internal","RemoveFlow_Internal","CopyAndStartPatching","forBackgroundSave","namedFlowKey","namedFlowValue","RestoreAfterPatch","ApplyAnyPatch","ApplyCountChanges","newCount","isVisit","inkVersionCurrent","jSaveVersion","flowsObj","flowsObjDict","flowsObjDictEntries","entries","namedFlowObjKey","namedFlowObjValue","currFlowName","currentDivertTargetPath","divertPath","ResetErrors","ResetOutput","objs","PushToOutputStream","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","PopFromOutputStream","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","trimIndex","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","inStringEvaluation","PushEvaluationStack","n","PopEvaluationStack","numberOfObjects","PeekEvaluationStack","ForceEnd","TrimWhitespaceFromFunctionEnd","functionStartPoint","PopCallStack","popType","SetChosenPath","incrementingTurnIndex","newPointer","StartFunctionEvaluationFromGame","funcContainer","PassArgumentsToEvaluationStack","TryExitFunctionEvaluationFromGame","CompleteFunctionEvaluationFromGame","originalEvaluationStackHeight","returnedObj","poppedObj","returnVal","AddError","Stopwatch","startTime","ElapsedMilliseconds","Start","Stop","nVal","isFinite","choices","_state","IfAsyncWeCant","_listDefinitions","StartProfiling","EndProfiling","inkVersionMinimumCompatible","onError","onDidContinue","onMakeChoice","onEvaluateFunction","onCompleteEvaluateFunction","onChoosePathString","_prevContainers","allowExternalFunctionFallbacks","_variableObservers","_hasValidatedExternals","_temporaryEvaluationContainer","_asyncContinueActive","_stateSnapshotAtLastNewline","_sawLookaheadUnsafeFunctionAfterNewline","_recursiveContinueCount","_asyncSaving","_profiler","_mainContentContainer","jsonString","_externals","rootObject","versionObj","formatFromFile","listDefsObj","rootToken","ResetState","shouldReturn","VariableStateDidChangeEvent","bind","ResetGlobals","ResetCallstack","originalPointer","ChoosePath","ContinueInternal","SwitchFlow","RemoveFlow","SwitchToDefaultFlow","Continue","ContinueAsync","asyncContinueComplete","millisecsLimitAsync","ValidateExternalBindings","PreContinue","isAsyncTimeLimited","durationStopwatch","ContinueSingleStep","changedVariablesToObserve","RestoreStateSnapshot","PostContinue","err","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","change","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","ContinueMaximally","KnotContainerWithName","pathLengthToUse","CopyStateForBackgroundThreadSave","stateToSave","BackgroundSaveComplete","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","NextContent","atStart","VisitChangedContainersDueToDivert","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","PopChoiceStringAndTags","choiceOnlyStrVal","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","evalCommand","output","overrideTunnelReturnTarget","popped","names","expected","contentStackForTag","outputCountConsumed","command","choiceTag","contentStackForString","contentToRetain","rescuedTag","choiceCount","extraNote","eitherCount","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","listNameVal","generatedListValue","foundItem","targetList","listItemIndex","listEnumerator","randomItem","assignedVal","foundValue","func","funcParams","ChoosePathString","resetCallstack","funcDetail","activityStr","ChooseChoiceIndex","choiceIdx","choiceToChoose","HasFunction","EvaluateFunction","returnTextOutput","trim","outputStreamBefore","stringOutput","textOutput","EvaluateExpression","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","valueObj","funcResult","function","returnObj","BindExternalFunctionGeneral","lookaheadSafe","TryCoerce","BindExternalFunction","coercedArgs","apply","UnbindExternalFunction","missingExternals","from","ObserveVariable","observer","ObserveVariables","variableNames","observers","RemoveVariableObserver","specificVariableName","variableObservers","newValueObj","globalTags","TagsAtStartOfFlowContainerWithPathString","TagsForContentAtPath","flowContainer","firstContent","BuildStringOfContainer","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","_hadError","hadWarning","_hadWarning","toplevelObjects","isInclude","_errorHandler","_dontFlattenContainers","_listDefs","ExportRuntime","constDecl","existingDefinition","variableInitialisation","runtimeLists","runtimeVarAss","runtimeStory","RuntimeStory","FlattenContainersIn","originalFoundList","itemInThisList","innerContainers","innerContainer","namedInnerContainer","TryFlattenContainer","parentContainer","Author","ResetError","namedFuncTarget","decl","NameConflictError","typeNameToPrint","typeNameOverride","IsReservedKeyword","knotOrFunction","topLevelContent","flowsFromOtherFiles","file","posOfObj","nonFlowContent","subStory","subStoryObj","StringExpression","isSingleString","otherStr","isStart","inChoice","DefaultFileHandler","rootPath","ResolveInkFilename","LoadInkFileContents","InkParser","_fileHandler","filename","externalErrorHandler","rootParser","ParseStory","StatementsAtLevel","Top","_rootParser","SeparatedList","mainRule","separatorRule","firstElement","allElements","nextElementRuleId","nextElement","CreateDebugMetadata","stateAtStart","stateAtEnd","md","_filename","parsedObj","parsedListObjs","parsedListObj","OnStringParserError","fullMessage","_externalErrorHandler","Whitespace","IdentifierWithMetadata","ExtendIdentifierCharacterRanges","identifierCharSet","characterRanges","ListAllCharacterRanges","charRange","_parsingChoice","onceOnlyChoice","bullets","optionalName","BracketedName","Newline","ChoiceCondition","startTextAndLogic","MixedTextAndLogic","optionOnlyContent","EndTagIfNecessary","optionOnlyTextAndLogic","innerTextAndLogic","diverts","MultiDivert","emptyContent","divObj","div","conditions","ChoiceSingleCondition","ChoiceConditionsSpace","condExpr","DisallowIncrement","gatherDashCountObj","GatherDashes","gatherDashCount","ParseDashNotArrow","InnerConditionalContent","initialQueryExpression","ConditionExpression","alternatives","canBeInline","InlineConditionalBranches","MultilineConditionalBranches","soleContent","InnerBlock","elseBranch","SingleMultilineCondition","emptyTrueBranch","earlierBranchesHaveOwnExpression","isLast","alt","finalClause","trueBranch","MultilineWhitespace","multipleConditions","expr","ElseExpression","_nonTextPauseCharacters","_nonTextEndCharacters","_notTextEndCharactersChoice","_notTextEndCharactersString","TrimEndWhitespace","mixedTextAndLogicResults","terminateWithSpace","lastObjIdx","lastObj","LineOfMixedTextAndLogic","firstText","EndOfLine","SkipToNextLine","Spaced","ContentText","InlineLogicOrGlueOrStartTag","ContentTextAllowingEscapeChar","ContentTextNoEscape","gotEscapeChar","endChars","parsingStringExpression","pureTextContent","ParseDivertArrow","ParseThreadArrow","threadDivert","arrowsAndDiverts","ParseDivertArrowOrTunnelOnwards","DivertIdentifierWithArguments","tunnelOnwards","tunnelOnwardDivert","gatherDivert","targetComponents","DotSeparatedDivertPathComponents","optionalArguments","ExpressionFunctionCallArguments","SingleDivert","numArrows","_binaryOperators","_maxBinaryOpLength","TempDeclarationOrAssignment","ParseTempKeyword","isIncrement","isDecrement","ReturnStatement","minimumPrecedence","ExpressionUnary","infixOp","ParseInfixOperator","expectationMessage","multiaryExpr","ExpressionInfixRight","ExpressionDivertTarget","prefixOp","ExpressionNot","ExpressionList","ExpressionParen","ExpressionFunctionCall","ExpressionVariableName","ExpressionLiteral","postfixOp","ExpressionFloat","ExpressionInt","ExpressionBool","ExpressionString","intOrNull","floatOrNull","textAndLogic","iden","commas","innerExpr","memberNames","ListMember","identifier2","RegisterExpressionOperators","RegisterBinaryOperator","infix","_openFilenames","IncludeStatement","fullFilename","FilenameIsAlreadyOpen","AddOpenFilename","includedString","RemoveOpenFilename","KnotDefinition","knotDecl","KnotDeclaration","KnotStitchNoContentRecoveryRule","KnotTitleEquals","knotName","isFunc","parameterNames","BracketedKnotDeclArguments","multiEquals","StitchDefinition","StitchDeclaration","flowArgs","flowArguments","FlowDeclArgument","firstIden","divertArrow","secondIden","funcIdentifier","argNames","_identifierCharSet","LogicLine","funCall","VariableDeclaration","ListElementDefinitionSeparator","ListDeclaration","AnyWhitespace","needsToCloseParen","elementValue","elementValueNum","ConstDeclaration","InlineLogic","StartTag","RuntimeGlue","wasParsingString","wasTagActive","tagActive","logic","InnerLogic","explicitSeqType","SequenceTypeAnnotation","contentLists","InnerSequenceObjects","rules","InnerSequence","InnerExpression","isNumberCharsOnly","_sequenceTypeSymbols","seqType","parsedSeqType","annotation","SequenceTypeSymbolAnnotation","SequenceTypeWordAnnotation","sequenceAnnotations","symbolChar","sequenceTypes","SequenceTypeSingleWord","combinedSequenceType","word","InnerMultilineSequenceObjects","InnerInlineSequenceObjects","interleavedContentAndPipes","justHadContent","contentOrPipe","SingleMultilineSequenceElement","_statementRulesAtLevel","_statementBreakRulesAtLevel","StatementAtLevel","StatementsBreakForLevel","rulesAtLevel","statement","breakRules","breakRuleResult","GenerateStatementLevelRules","levels","breakingRules","Line","inlineRule","_inlineWhitespaceChars","EndOfFile","newlines","anyWhitespace","MultiSpaced","fullRootInkPath","ParsingString","TagActive","outputContentList","LatinBasic","LatinExtendedA","LatinExtendedB","Greek","Cyrillic","Armenian","Hebrew","Arabic","Korean","Latin1Supplement","Chinese","errors","_errors","warnings","_warnings","authorMessages","_authorMessages","_inputString","options","_options","parsedStory","_parsedStory","_runtimeStory","parser","_parser","debugSourceRanges","_debugSourceRanges","inkSource","Compile","OnError","RetrieveDebugSourceForLatestContent","range","GenerateStats","allText","words","wordsInThisStr","wasWhiteSpace","knots","stitches","gathers","g","functions","GenerateStoryStats","DebugMetadataForContentAtOffset","offset","currOffset","lastValidMetadata","fileHierarchy"],"mappings":"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"}